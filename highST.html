<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Risk Short-Term Investment Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js" charset="utf-8"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .header h5 {
            margin-top: 0;
            color: #7f8c8d;
        }
        .dashboard {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .controls h3 {
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric-card {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
        }
        .metric-card h3 {
            margin: 10px 0;
            font-size: 1.8rem;
        }
        .metric-card p {
            margin: 0;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        .charts {
            display: grid;
            grid-template-rows: auto;
            gap: 20px;
        }
        .chart-container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .chart-container h3 {
            margin-top: 0;
            margin-bottom: 20px;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        input[type="range"] {
            width: 100%;
        }
        .allocation-display {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
        }
        button {
            width: 100%;
            padding: 10px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 20px;
        }
        button:hover {
            background-color: #2980b9;
        }
        .tab-container {
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .tab.active {
            border-bottom-color: #3498db;
            font-weight: 500;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .warning {
            color: #e74c3c;
            margin-top: 5px;
            font-size: 0.9rem;
        }
        .axis line, .axis path {
            stroke: #ddd;
        }
        .axis text {
            fill: #666;
            font-size: 0.8rem;
        }
        .notes {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        .notes h5 {
            margin-top: 0;
        }
        .notes ul {
            padding-left: 20px;
        }
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 2px;
        }
        .api-error {
            background-color: #fee;
            color: #e74c3c;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        /* CSS for the time period buttons */
        .time-period-buttons {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
        }

        .time-btn {
            flex: 1;
            padding: 8px 0;
            margin: 0 4px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .time-btn:first-child {
            margin-left: 0;
        }

        .time-btn:last-child {
            margin-right: 0;
        }

        .time-btn:hover {
            background-color: #e9ecef;
        }

        .time-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        /* Additional CSS for Portfolio vs upro comparison */
        .portfolio-line {
            stroke-width: 3px;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .upro-line {
            stroke-width: 2px;
            stroke-dasharray: 5, 5;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .outperformance-positive {
            color: #28a745;
            font-weight: bold;
        }

        .outperformance-negative {
            color: #dc3545;
            font-weight: bold;
        }

        .grid line {
            stroke: #e0e0e0;
            stroke-opacity: 0.7;
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }
        .loading:after {
            content: '...';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        .tooltip-trigger {
            position: relative;
            display: inline-flex;
            margin-left: 5px;
            cursor: help;
        }

        .tooltip-trigger .info-icon {
            width: 16px;
            height: 16px;
        }

        .tooltip-trigger:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 100%;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            width: 250px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            font-weight: normal;
            line-height: 1.4;
        }

        .tooltip-trigger:hover::before {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 100%;
            border: 8px solid transparent;
            border-top-color: #333;
            pointer-events: none;
        }

        /* addition code SH */
        /* Add these new styles before .grid line */
    #correlation-chart {
        min-height: 500px;
        position: relative;
    }

    .loading {
        text-align: center;
        padding: 20px;
        color: #666;
    }

    .error {
        color: #721c24;
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        padding: 1rem;
        margin: 1rem 0;
        border-radius: 0.25rem;
    }

    .grid line {
        stroke: #e0e0e0;
        stroke-opacity: 0.7;
        shape-rendering: crispEdges;
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>High Risk Short-Term Investment Dashboard</h1>
            <h5>Comprehensive Portfolio Analysis</h5>
        </div>
        
        <div id="api-error" class="api-error">
            <strong>Error connecting to API:</strong> <span id="error-message"></span>
        </div>
        
        <div class="dashboard">
            <div class="controls">
                <h3>Investment Parameters</h3>
                
                <!-- HTML for time period buttons -->
                <div class="control-group">
                    <label>Investment Period:</label>
                    <div class="time-period-buttons">
                        <button class="time-btn" data-period="1M">1M</button>
                        <button class="time-btn" data-period="6M">6M</button>
                        <button class="time-btn" data-period="1Y">1Y</button>
                        <button class="time-btn" data-period="3Y">3Y</button>
                        <button class="time-btn" data-period="5Y">5Y</button>
                        <button class="time-btn active" data-period="MAX">Max</button>
                    </div>
                    <div id="date-range-display" style="text-align: center; margin-top: 10px; display: none;">Loading date range...</div>
                </div>
                
                <div class="control-group">
                    <label>Initial Investment (USD):</label>
                    <input type="number" id="initial-investment" min="1000" max="1000000" step="1000" value="10000">
                    <small style="color: #7f8c8d;">Min: $1,000 - Max: $1,000,000</small>
                </div>
                
                <div class="control-group">
                    <label>Portfolio Allocation:</label>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>UPRO</span>
                            <span id="upro-value">25%</span>
                        </div>
                        <input type="range" id="upro-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>QQQ</span>
                            <span id="qqq-value">25%</span>
                        </div>
                        <input type="range" id="qqq-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>IWF</span>
                            <span id="iwf-value">25%</span>
                        </div>
                        <input type="range" id="iwf-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>ARKK</span>
                            <span id="arkk-value">25%</span>
                        </div>
                        <input type="range" id="arkk-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div id="allocation-warning" class="warning"></div>
                </div>
                
                <button id="calculate-button">Calculate Returns</button>
            </div>
            
            <div class="content">
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Final Portfolio Value</h4>
                        <h3 id="final-value">$0.00</h3>
                        <p id="initial-value">Initial: $0.00</p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>Total Return
                            <span class="tooltip-trigger" data-tooltip="The total growth rate of your investment">
                                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="total-return">0.0%</h3>
                        <p id="annualized-return">
                            Annualized: 0.0% per year
                        </p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>
                            Maximum Drawdown
                            <span class="tooltip-trigger" data-tooltip="The percentage drop from your investment's highest value to its lowest point during a specific period. Shows potential losses you might face before recovery.">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="max-drawdown">0.0%</h3>
                        <p>Largest decline from peak</p>
                    </div>
                    
                    <div class="metric-card" id="risk-card">
                        <h4>
                            Risk Level
                            <span class="tooltip-trigger" data-tooltip="Measures how dramatically an investment's price changes over time. Higher volatility means bigger price swings both up and down.">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="volatility">Low (0.0%)</h3>
                        <p>Portfolio volatility</p>
                    </div>   
                </div>
                
                <div class="tab-container">
                    <ul class="tabs">
                        <li class="tab active" data-tab="candlestick">Candlestick</li>
                        <li class="tab" data-tab="company-weightage">Company Weightage</li>
                        <li class="tab" data-tab="industry-weightage">Industry Weightage</li>
                        <li class="tab" data-tab="volume">Volume Analysis</li>
                        <li class="tab" data-tab="correlation">Correlation</li>
                        <li class="tab" data-tab="drawdown">Drawdown Analysis</li>
                    </ul>
                </div>
                
                <div class="charts">
                    <div id="candlestick" class="tab-content active">
                        <div class="chart-container">
                            <h3>Candlestick Chart</h3>
                            <div id="candlestick-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="candlestick-legend"></div>
                        </div>
                    </div>
                    
                    <div id="company-weightage" class="tab-content">
                        <div class="chart-container">
                            <h3>ETF Company Weightage</h3>
                            <div id="company-weightage-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="company-weightage-legend"></div>
                        </div>
                    </div>
                    
                    <div id="industry-weightage" class="tab-content">
                        <div class="chart-container">
                            <h3>ETF Industry Weightage</h3>
                            <div id="industry-weightage-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="industry-weightage-legend"></div>
                        </div>
                    </div>
                    
                    <div id="volume" class="tab-content">
                        <div class="chart-container">
                            <h3>Volume Analysis</h3>
                            <div id="volume-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- <div id="correlation" class="tab-content">
                        <div class="chart-container">
                            <h3>Correlation Matrix</h3>
                            <div id="correlation-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="correlation-legend"></div>
                        </div>
                    </div> -->
                    <div id="correlation" class="tab-content">
                        <div class="chart-container">
                            <h3>Correlation Matrix</h3>
                            <div id="correlation-chart"></div>
                        </div>
                    </div>
                    
                    <div id="drawdown" class="tab-content">
                        <div class="chart-container">
                            <h3>Portfolio Drawdown Analysis</h3>
                            <div id="drawdown-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add a tooltip div -->
    <div id="tooltip" class="tooltip"></div>

    <script>
        // API URLs
        const API_BASE_URL = 'http://localhost:5001';
        const API_DATE_RANGE = `${API_BASE_URL}/api/date-range`;
        const API_PORTFOLIO_VALUE = `${API_BASE_URL}/api/portfolio-value`;
        const API_TOTAL_RETURN = `${API_BASE_URL}/api/total-return`;
        const API_MAX_DRAWDOWN = `${API_BASE_URL}/api/max-drawdown`;
        const API_RISK_LEVEL = `${API_BASE_URL}/api/risk-level`;
        const API_PORTFOLIO_GROWTH = `${API_BASE_URL}/api/portfolio-growth`;
        const API_DRAWDOWN_ANALYSIS = `${API_BASE_URL}/api/drawdown-analysis`;
        const API_ETF_COMPARISON = `${API_BASE_URL}/api/etf-comparison`;
        const API_YEARLY_RETURNS = `${API_BASE_URL}/api/yearly-returns`;
        const API_CALCULATE_ALL = `${API_BASE_URL}/api/calculate-all`;
        
        // Add new API endpoints for the new charts
        const API_COMPANY_WEIGHTAGE = `${API_BASE_URL}/api/company-weightage`;
        const API_INDUSTRY_WEIGHTAGE = `${API_BASE_URL}/api/industry-weightage`;
        const API_VOLUME_ANALYSIS = `${API_BASE_URL}/api/volume-analysis`;
        const API_CORRELATION_MATRIX = `${API_BASE_URL}/api/correlation-matrix`;
        //const API_CANDLESTICK_DATA = `${API_BASE_URL}/api/candlestick-data`;

        // Global variables
        let minDate, maxDate;
        let selectedStartDate, selectedEndDate;
        let portfolioData = null;
        let candlestickData = null;
        let companyWeightageData = null;
        let industryWeightageData = null;
        let volumeData = null;
        //let correlationData = null;
        let drawdownData = null;
        let etfPerformance = null;
        let yearlyReturns = null;
        
        // Main application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize tooltips
            const tooltip = d3.select('#tooltip');
            
            // Initialize date range
            fetchDateRange();
            
            // Initialize allocation sliders
            initializeAllocationSliders();
            
            // Set up tabs
            initializeTabs();
            
            // Set up time period buttons
            initializeTimePeriodButtons();
            
            // Set up calculate button
            document.getElementById('calculate-button').addEventListener('click', function() {
                calculateAndFetchResults();
            });
            
            // Initial calculation will be triggered after date range is fetched
        });

        // Utility function to wait for elements to exist in the DOM
        function waitForElement(elementId, callback, checkFrequencyInMs, timeoutInMs) {
            var startTimeInMs = Date.now();
            var checkElementAndCallback = function() {
                var element = document.getElementById(elementId);
                if (element) {
                    console.log(elementId + " element found!");
                    callback(element);
                    return;
                }
                
                if (timeoutInMs && Date.now() - startTimeInMs > timeoutInMs) {
                    console.log(elementId + " element not found within timeout period");
                    return;
                }
                
                setTimeout(checkElementAndCallback, checkFrequencyInMs);
            };
            
            checkElementAndCallback();
        }

        // Helper function to find the parent metric card of an element
        function findParentCard(elementId) {
            const element = document.getElementById(elementId);
            if (!element) {
                console.log("Element with ID " + elementId + " not found");
                return null;
            }
            
            // Find parent metric card
            const parentCard = element.closest('.metric-card');
            if (parentCard) {
                console.log("Found parent card for " + elementId);
                return parentCard;
            } else {
                console.log("Could not find parent card for " + elementId);
                return null;
            }
        }

        // 1. RISK/VOLATILITY MONITORING
        function setupRiskMonitoring(volatilityElement) {
            console.log("Setting up risk/volatility monitoring");
            
            // Find the risk card element
            const riskCard = findParentCard('volatility');
            
            if (riskCard) {
                setupRiskObserver(volatilityElement, riskCard);
            } else {
                console.error("Could not find parent card for volatility");
            }
        }

        function setupRiskObserver(volatilityElement, cardElement) {
            function updateRiskCardColor() {
                const volatilityText = volatilityElement.innerText || volatilityElement.textContent;
                console.log("Volatility text:", volatilityText);
                
                if (volatilityText.includes('Very Low') || volatilityText.includes('Low')) {
                    cardElement.style.backgroundColor = 'rgba(40, 167, 69, 0.15)'; // light green
                    console.log("Set risk card to green");
                } else if (volatilityText.includes('High') || volatilityText.includes('Very High')) {
                    cardElement.style.backgroundColor = 'rgba(220, 53, 69, 0.15)'; // light red
                    console.log("Set risk card to red");
                } else {
                    cardElement.style.backgroundColor = 'rgba(255, 193, 7, 0.15)'; // light yellow for Moderate
                    console.log("Set risk card to yellow");
                }
            }
            
            // Initial update
            updateRiskCardColor();
            
            // Create a separate observer for risk
            const riskObserver = new MutationObserver(function() {
                console.log("Risk observer triggered");
                updateRiskCardColor();
            });
            
            // Start observing
            riskObserver.observe(volatilityElement, { 
                childList: true, 
                characterData: true,
                subtree: true 
            });
            
            console.log("Risk monitoring setup complete");
        }

        // 2. DRAWDOWN MONITORING
        function setupDrawdownMonitoring(drawdownElement) {
            console.log("Setting up drawdown monitoring");
            
            // Find the drawdown card element
            const drawdownCard = findParentCard('max-drawdown');
            
            if (drawdownCard) {
                setupDrawdownObserver(drawdownElement, drawdownCard);
            } else {
                console.error("Could not find parent card for drawdown");
            }
        }

        function setupDrawdownObserver(drawdownElement, cardElement) {
            function updateDrawdownCardColor() {
                const drawdownText = drawdownElement.innerText || drawdownElement.textContent;
                console.log("Drawdown text:", drawdownText);
                
                const cleanText = drawdownText.replace(/[^\d.-]/g, '');
                const drawdownValue = parseFloat(cleanText);
                
                if (isNaN(drawdownValue)) {
                    console.error("Could not parse a valid number from drawdown text");
                    return;
                }
                
                console.log("Drawdown value:", drawdownValue);
                
                if (drawdownValue <= -15) {
                    cardElement.style.backgroundColor = '#ffe6e6'; // Light red
                    console.log("Set drawdown card to red");
                } else {
                    cardElement.style.backgroundColor = '#e6f7e6'; // Light green
                    console.log("Set drawdown card to green");
                }
            }
            
            // Initial update
            updateDrawdownCardColor();
            
            // Create a separate observer for drawdown
            const drawdownObserver = new MutationObserver(function() {
                console.log("Drawdown observer triggered");
                updateDrawdownCardColor();
            });
            
            // Start observing
            drawdownObserver.observe(drawdownElement, { 
                childList: true, 
                characterData: true,
                subtree: true 
            });
            
            console.log("Drawdown monitoring setup complete");
        }

        // 3. PORTFOLIO RETURN MONITORING (FOR BOTH PORTFOLIO VALUE AND TOTAL RETURN CARDS)
        function setupReturnMonitoring(annualizedReturnElement) {
            console.log("Setting up annualized return monitoring");
            
            // Find both card elements
            const portfolioValueCard = findParentCard('final-value');
            const totalReturnCard = findParentCard('total-return');
            
            if (!portfolioValueCard) {
                console.error("Could not find portfolio value card");
            }
            
            if (!totalReturnCard) {
                console.error("Could not find total return card");
            }
            
            // Set up the monitoring if at least one card was found
            if (portfolioValueCard || totalReturnCard) {
                setupReturnObserver(annualizedReturnElement, portfolioValueCard, totalReturnCard);
            }
        }

        function setupReturnObserver(annualizedReturnElement, portfolioValueCard, totalReturnCard) {
            function updateReturnCards() {
                const returnText = annualizedReturnElement.innerText || annualizedReturnElement.textContent;
                console.log("Annualized return text:", returnText);
                
                // Extract the percentage value (looking for a number followed by % per year)
                const matches = returnText.match(/(-?\d+\.?\d*)%/);
                if (!matches || matches.length < 2) {
                    console.error("Could not parse annualized return percentage");
                    return;
                }
                
                const annualizedReturnValue = parseFloat(matches[1]);
                console.log("Parsed annualized return value:", annualizedReturnValue);
                
                // Apply the appropriate background color based on the threshold
                if (annualizedReturnValue >= 6) {
                    console.log("Setting cards to green (>= 6%)");
                    if (portfolioValueCard) portfolioValueCard.style.backgroundColor = '#e6f7e6'; // Light green
                    if (totalReturnCard) totalReturnCard.style.backgroundColor = '#e6f7e6'; // Light green
                } else {
                    console.log("Setting cards to red (< 6%)");
                    if (portfolioValueCard) portfolioValueCard.style.backgroundColor = '#ffe6e6'; // Light red
                    if (totalReturnCard) totalReturnCard.style.backgroundColor = '#ffe6e6'; // Light red
                }
            }
            
            // Initial update
            updateReturnCards();
            
            // Create an observer for the annualized return
            const returnObserver = new MutationObserver(function() {
                console.log("Annualized return observer triggered");
                updateReturnCards();
            });
            
            // Start observing
            returnObserver.observe(annualizedReturnElement, { 
                childList: true, 
                characterData: true,
                subtree: true 
            });
            
            console.log("Annualized return monitoring setup complete");
        }

        // Initialize all monitors when the page loads
        window.addEventListener('load', function() {
            console.log("Window loaded, setting up all monitors");
            
            // 1. Set up risk/volatility monitoring
            waitForElement('volatility', setupRiskMonitoring, 100, 10000);
            
            // 2. Set up maximum drawdown monitoring
            waitForElement('max-drawdown', setupDrawdownMonitoring, 100, 10000);
            
            // 3. Set up return monitoring (for both portfolio value and total return cards)
            waitForElement('annualized-return', setupReturnMonitoring, 100, 10000);
        });
        
        // Function to update the risk card background color
        function updateRiskCardColor() {
            const riskCard = document.getElementById('risk-card');
            const volatilityText = document.getElementById('volatility').innerText;
            
            if (volatilityText.includes('Very Low') || volatilityText.includes('Low')) {
                riskCard.style.backgroundColor = 'rgba(40, 167, 69, 0.15)'; // light green
            } else if (volatilityText.includes('High') || volatilityText.includes('Very High')) {
                riskCard.style.backgroundColor = 'rgba(220, 53, 69, 0.15)'; // light red
            } else {
                riskCard.style.backgroundColor = 'rgba(255, 193, 7, 0.15)'; // light yellow for Moderate
            }
        }

        // Call the function initially
        updateRiskCardColor();

        // Set up a MutationObserver to watch for changes to the volatility text
        const observer = new MutationObserver(updateRiskCardColor);
        observer.observe(document.getElementById('volatility'), { 
            childList: true, 
            characterData: true,
            subtree: true
        });
        
        // Function to fetch date range from API
        function fetchDateRange() {
            fetch(API_DATE_RANGE)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    minDate = new Date(data.min_date);
                    maxDate = new Date(data.max_date);
                    
                    // Set default selected dates to max range
                    selectedStartDate = minDate;
                    selectedEndDate = maxDate;
                    
                    // Display date range text initially
                    updateDateRangeDisplay();
                    
                    // Display ETF returns if needed
                    const etfReturns = data.etf_returns;
                    for (const etf in etfReturns) {
                        const returnEl = document.getElementById(`${etf.toLowerCase()}-return`);
                        if (returnEl) {
                            returnEl.textContent = `${etfReturns[etf].toFixed(2)}%`;
                        }
                    }
                    
                    // Now that we have the date range, trigger the initial calculation
                    calculateAndFetchResults();
                })
                .catch(error => {
                    showApiError(`Failed to fetch date range: ${error.message}`);
                });
        }

        // Function to initialize time period buttons
        function initializeTimePeriodButtons() {
            const buttons = document.querySelectorAll('.time-btn');
            
            buttons.forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all buttons
                    buttons.forEach(btn => btn.classList.remove('active'));
                    
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Get the selected period
                    const period = this.getAttribute('data-period');
                    
                    // Calculate start and end dates based on the period
                    if (period === 'MAX') {
                        selectedStartDate = minDate;
                        selectedEndDate = maxDate;
                    } else {
                        selectedEndDate = new Date(maxDate); // Use a copy of maxDate
                        selectedStartDate = calculateStartDate(period);
                    }
                    
                    // Update the date range display
                    updateDateRangeDisplay();
                    
                    // If allocations are valid, trigger calculation
                    if (checkAllocation()) {
                        calculateAndFetchResults();
                    }
                });
            });
        }

        // Function to calculate start date based on period
        function calculateStartDate(period) {
            const endDate = new Date(selectedEndDate);
            const startDate = new Date(endDate);
            
            switch (period) {
                case '1M':
                    startDate.setMonth(endDate.getMonth() - 1);
                    break;
                case '6M':
                    startDate.setMonth(endDate.getMonth() - 6);
                    break;
                case '1Y':
                    startDate.setFullYear(endDate.getFullYear() - 1);
                    break;
                case '3Y':
                    startDate.setFullYear(endDate.getFullYear() - 3);
                    break;
                case '5Y':
                    startDate.setFullYear(endDate.getFullYear() - 5);
                    break;
                default:
                    startDate = new Date(minDate);
            }
            
            // Ensure the start date is not earlier than the minimum available date
            if (startDate < minDate) {
                startDate = new Date(minDate);
            }
            
            return startDate;
        }

        // Function to update the date range display
        function updateDateRangeDisplay() {
            const dateDisplay = document.getElementById('date-range-display');
            dateDisplay.textContent = `From ${formatDate(selectedStartDate)} to ${formatDate(selectedEndDate)}`;
            dateDisplay.style.display = 'none';
        }

        // Function to initialize allocation sliders [SPY, BND, VTIP, VXUS] [UPRO, QQQ, IWF, ARKK]
        function initializeAllocationSliders() {
            const uproSlider = document.getElementById('upro-allocation');
            const qqqSlider = document.getElementById('qqq-allocation');
            const iwfSlider = document.getElementById('iwf-allocation');
            const arkkSlider = document.getElementById('arkk-allocation');
            
            const uproValue = document.getElementById('upro-value');
            const qqqValue = document.getElementById('qqq-value');
            const iwfValue = document.getElementById('iwf-value');
            const arkkValue = document.getElementById('arkk-value');
            
            uproSlider.addEventListener('input', function() {
                uproValue.textContent = `${uproSlider.value}%`;
                checkAllocation();
            });
            
            qqqSlider.addEventListener('input', function() {
                qqqValue.textContent = `${qqqSlider.value}%`;
                checkAllocation();
            });
            
            iwfSlider.addEventListener('input', function() {
                iwfValue.textContent = `${iwfSlider.value}%`;
                checkAllocation();
            });
            
            arkkSlider.addEventListener('input', function() {
                arkkValue.textContent = `${arkkSlider.value}%`;
                checkAllocation();
            });
        }
        
        // Function to check if allocations sum to 100%
        function checkAllocation() {
            const uproValue = parseInt(document.getElementById('upro-allocation').value);
            const qqqValue = parseInt(document.getElementById('qqq-allocation').value);
            const iwfValue = parseInt(document.getElementById('iwf-allocation').value);
            const arkkValue = parseInt(document.getElementById('arkk-allocation').value);
            
            const total = uproValue + qqqValue + iwfValue + arkkValue;
            const warningEl = document.getElementById('allocation-warning');
            
            if (total !== 100) {
                warningEl.textContent = `Total allocation: ${total}% (should be 100%)`;
                return false;
            } else {
                warningEl.textContent = '';
                return true;
            }
        }
        
        // Function to initialize tabs
        function initializeTabs() {
            const tabs = document.querySelectorAll('.tab');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    
                    // Remove active class from all tabs and tab content
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    this.classList.add('active');
                    document.getElementById(tabId).classList.add('active');
                    
                    // Re-render charts when tab becomes visible to fix layout issues
                    setTimeout(() => {
                        if (tabId === 'candlestick' && candlestickData) {
                            createCandlestickChart(candlestickData);
                        } else if (tabId === 'company-weightage' && companyWeightageData) {
                            createCompanyWeightageChart(companyWeightageData);
                        } else if (tabId === 'industry-weightage' && industryWeightageData) {
                            createIndustryWeightageChart(industryWeightageData);
                        } else if (tabId === 'volume' && volumeData) {
                            createVolumeChart(volumeData);
                        //} else if (tabId === 'correlation' && correlationData) {
                        //    createCorrelationMatrix(correlationData);
                        } else if (tabId === 'correlation') {
                        createCorrelationMatrix(); // Remove correlationData parameter
                        } else if (tabId === 'drawdown' && drawdownData) {
                            createDrawdownChart(drawdownData);
                        }
                    }, 50);
                });
            });
        }

        // Helper function to get current allocations
        function getCurrentAllocations() {
            return {
                'UPRO': parseInt(document.getElementById('upro-allocation').value),
                'QQQ': parseInt(document.getElementById('qqq-allocation').value),
                'IWF': parseInt(document.getElementById('iwf-allocation').value),
                'ARKK': parseInt(document.getElementById('arkk-allocation').value)
            };
        }
        
        // Function to calculate and fetch results from API
        function calculateAndFetchResults() {
            // Check if allocations are valid
            if (!checkAllocation()) {
                alert('Total allocation must be 100%. Please adjust your allocations.');
                return;
            }
            
            // Get input values
            const initialInvestment = parseFloat(document.getElementById('initial-investment').value);
            const uproAllocation = parseInt(document.getElementById('upro-allocation').value);
            const qqqAllocation = parseInt(document.getElementById('qqq-allocation').value);
            const iwfAllocation = parseInt(document.getElementById('iwf-allocation').value);
            const arkkAllocation = parseInt(document.getElementById('arkk-allocation').value);
            
            // Use the selected date range
            const startDate = formatDateForAPI(selectedStartDate);
            const endDate = formatDateForAPI(selectedEndDate);
            
            // Prepare API request payload
            const payload = {
                initial_investment: initialInvestment,
                allocations: {
                    'UPRO': uproAllocation,
                    'QQQ': qqqAllocation,
                    'IWF': iwfAllocation,
                    'ARKK': arkkAllocation
                },
                start_date: startDate,
                end_date: endDate
            };
            
            // Show loading state
            document.querySelectorAll('.loading').forEach(el => {
                el.style.display = 'block';
            });
            
            // Clear any previous error messages
            hideApiError();
            
            // Fetch all data at once
            fetchAllData(payload);
        }

        // Helper function to format dates for API (YYYY-MM-DD)
        function formatDateForAPI(date) {
            if (!date) return null;
            
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            
            return `${year}-${month}-${day}`;
        }
        
        // Function to fetch all data from the API
        function fetchAllData(payload) {
            // Use the calculate-all endpoint
            fetch(API_CALCULATE_ALL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        try {
                            const err = JSON.parse(text);
                            throw new Error(err.error || `HTTP error! Status: ${response.status}`);
                        } catch(e) {
                            throw new Error(`HTTP error! Status: ${response.status}, Body: ${text.substring(0, 100)}...`);
                        }
                    });
                }
                return response.text().then(text => {
                    // Replace NaN with null in the response to handle JSON parsing issues
                    const cleanedText = text.replace(/NaN/g, 'null');
                    return JSON.parse(cleanedText);
                });
            })
            .then(data => {
                // Store the data
                const metrics = data.metrics;
                portfolioData = data.portfolio_data;
                etfPerformance = data.etf_performance;
                yearlyReturns = data.yearly_returns;
                candlestickData = data.candlestick_data || [];
                companyWeightageData = data.company_weightage || [];
                industryWeightageData = data.industry_weightage || [];
                volumeData = data.volume_data || [];
                //correlationData = data.correlation_data || [];
                drawdownData = data.drawdown_data || portfolioData; // Use portfolio data if no specific drawdown data
                
                console.log("Data received:", {
                    portfolioDataPoints: portfolioData?.length || 0,
                    etfPerformanceEntries: Object.keys(etfPerformance || {}).length,
                    yearlyReturnsPoints: yearlyReturns?.length || 0,
                    candlestickDataPoints: candlestickData?.length || 0,
                    companyWeightage: Object.keys(companyWeightageData || {}).length,
                    industryWeightage: Object.keys(industryWeightageData || {}).length
                });
                
                // Update metrics display
                updateMetricsDisplay(metrics, payload.initial_investment);
                
                // Create charts
                createCandlestickChart(candlestickData);
                createCompanyWeightageChart(companyWeightageData);
                createIndustryWeightageChart(industryWeightageData);
                createVolumeChart(volumeData);
                //createCorrelationMatrix(correlationData);
                createCorrelationMatrix();
                createDrawdownChart(drawdownData);
                
                // Hide loading indicators
                document.querySelectorAll('.loading').forEach(el => {
                    el.style.display = 'none';
                });
            })
            .catch(error => {
                showApiError(`Failed to fetch portfolio data: ${error.message}`);
                
                // Hide loading indicators
                document.querySelectorAll('.loading').forEach(el => {
                    el.style.display = 'none';
                });
            });
        }

        // Function to update metrics display
        function updateMetricsDisplay(metrics, initialInvestment) {
            document.getElementById('final-value').textContent = formatCurrency(metrics.final_value);
            document.getElementById('initial-value').textContent = `Initial: ${formatCurrency(initialInvestment)}`;
            document.getElementById('total-return').textContent = formatPercentage(metrics.total_return);
            document.getElementById('annualized-return').textContent = `Annualized: ${formatPercentage(metrics.annualized_return)} per year`;
            document.getElementById('max-drawdown').textContent = formatPercentage(metrics.max_drawdown);
            document.getElementById('volatility').textContent = `${metrics.risk_level} (${formatPercentage(metrics.volatility)})`;
        }

// Function to create candlestick chart using portfolio allocation data
//Logics needed:
//- if if else (1 month, 6 months, 1 yr), for 1 yr and 6 months split into each month
// and extract the relevant data dates based on the time period defined
// logic to check if open is higher than close the open will the line higher than close, if close price is higher than open vice versa when plotting candlestick

//function createCandlestickChart(stockData) 
function createCandlestickChart(stockData, startDate, endDate) {
    const chartContainer = document.getElementById('candlestick-chart');
    chartContainer.innerHTML = '';

    // Check if we have data
    if (!stockData || stockData.length === 0) {
        chartContainer.innerHTML = '<div class="error">No data available for candlestick analysis</div>';
        return;
    }

    // Check container width first
    const containerWidth = chartContainer.clientWidth;

    if (containerWidth <= 0) {
        // Wait for the layout to stabilize (e.g., tab becoming visible)
        setTimeout(() => createCandlestickChart(stockData, startDate, endDate), 100);
        return;
    }

    // Filter data by date range
    const filteredData = stockData.filter(d => {
        const date = new Date(d.Date);
        return date >= startDate && date <= endDate;
    });

    if (filteredData.length === 0) {
        chartContainer.innerHTML = '<div class="error">No data available for the selected date range</div>';
        return;
    }

    // Group data into monthly periods
    const groupedData = [];
    let currentDate = new Date(endDate);

    while (currentDate >= startDate) {
        const nextDate = new Date(currentDate);
        nextDate.setMonth(currentDate.getMonth() - 1);

        const monthlyData = filteredData.filter(d => {
            const date = new Date(d.Date);
            return date >= nextDate && date < currentDate;
        });

        if (monthlyData.length > 0) {
            const avgOpen = d3.mean(monthlyData, d => parseFloat(d.Open));
            const avgHigh = d3.mean(monthlyData, d => parseFloat(d.High));
            const avgLow = d3.mean(monthlyData, d => parseFloat(d.Low));
            const avgClose = d3.mean(monthlyData, d => parseFloat(d.Close));

            groupedData.push({
                Date: new Date(nextDate),
                Open: avgOpen,
                High: avgHigh,
                Low: avgLow,
                Close: avgClose
            });
        }

        currentDate = nextDate;
    }

    // Sort grouped data by date
    groupedData.sort((a, b) => a.Date - b.Date);

    // Continue with the original candlestick chart code
    const margin = containerWidth < 400
        ? { top: 20, right: 30, bottom: 50, left: 40 }
        : { top: 20, right: 80, bottom: 50, left: 80 };

    const width = Math.max(containerWidth - margin.left - margin.right, 100);
    const height = 500 - margin.top - margin.bottom;

    const svg = d3.select(chartContainer)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // X scale
    const x = d3.scaleBand()
        .domain(groupedData.map(d => d.Date))
        .range([0, width])
        .padding(0.2);

    // Y scale
    const y = d3.scaleLinear()
        .domain([
            d3.min(groupedData, d => d.Low),
            d3.max(groupedData, d => d.High)
        ])
        .range([height, 0]);

    // X axis
    svg.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).tickFormat(d3.timeFormat('%b %Y')))
        .selectAll('text')
        .attr('transform', 'rotate(-45)')
        .style('text-anchor', 'end');

    // Y axis
    svg.append('g')
        .call(d3.axisLeft(y));

    // Draw candlesticks
    svg.selectAll('.candlestick')
        .data(groupedData)
        .enter()
        .append('line')
        .attr('class', 'candlestick')
        .attr('x1', d => x(d.Date) + x.bandwidth() / 2)
        .attr('x2', d => x(d.Date) + x.bandwidth() / 2)
        .attr('y1', d => y(d.High))
        .attr('y2', d => y(d.Low))
        .attr('stroke', 'black');

    svg.selectAll('.candlestick-rect')
        .data(groupedData)
        .enter()
        .append('rect')
        .attr('class', 'candlestick-rect')
        .attr('x', d => x(d.Date))
        .attr('y', d => y(Math.max(d.Open, d.Close)))
        .attr('width', x.bandwidth())
        .attr('height', d => Math.abs(y(d.Open) - y(d.Close)))
        .attr('fill', d => d.Open > d.Close ? 'red' : 'green');
}
//{
//     const chartContainer = document.getElementById('candlestick-chart');
//     chartContainer.innerHTML = '';
    
//     // Check if we have data
//     if (!stockData || stockData.length === 0) {
//         chartContainer.innerHTML = '<div class="error">No data available for candlestick analysis</div>';
//         return;
//     }
    
//     // Check container width first
//     const containerWidth = chartContainer.clientWidth;
    
//     if (containerWidth <= 0) {
//         // Wait for the layout to stabilize (e.g., tab becoming visible)
//         setTimeout(() => createCandlestickChart(stockData), 100);
//         return;
//     }
    
// // First, let's fetch and process the allocation data
// Promise.all([
//     d3.csv("../angela_datasets/arkk_share_allocation.csv"),
//     d3.csv("../angela_datasets/IWF_share_allocation.csv"),
//     d3.csv("../angela_datasets/qqq_share_allocation.csv"),
//     d3.csv("../angela_datasets/upro_share_allocation.csv")
// ]).then(function(files) {
//     const [arkkData, iwfData, qqqData, uproData] = files;
    
//     // Log to verify files are loaded
//     console.log("Files loaded successfully!");
//     console.log("ARKK data length:", arkkData.length);
//     console.log("ARKK first record:", arkkData[0]);
    
//     console.log("IWF data length:", iwfData.length);
//     console.log("IWF first record:", iwfData[0]);
    
//     console.log("QQQ data length:", qqqData.length);
//     console.log("QQQ first record:", qqqData[0]);
    
//     console.log("UPRO data length:", uproData.length);
//     console.log("UPRO first record:", uproData[0]);
    
//     // Continue with your code...
// }).catch(function(error) {
//     // Log any errors in loading the files
//     console.error("Error loading files:", error);

        
//         // Get the current allocations
//         const allocations = getCurrentAllocations();
        
//         // Process data for candlestick chart based on allocations
//         // For this example, we'll use the stockData passed to the function,
//         // but apply weightings based on the allocation data
        
//         // Continue with the original candlestick chart code
//         const margin = containerWidth < 400 
//             ? {top: 20, right: 30, bottom: 50, left: 40}
//             : {top: 20, right: 80, bottom: 50, left: 80};
        
//         const width = Math.max(containerWidth - margin.left - margin.right, 100);
//         const height = 500 - margin.top - margin.bottom;
        
//         const svg = d3.select(chartContainer)
//             .append('svg')
//             .attr('width', width + margin.left + margin.right)
//             .attr('height', height + margin.top + margin.bottom)
//             .append('g')
//             .attr('transform', `translate(${margin.left},${margin.top})`);
        
//         // Process date and numeric values
//         const processedData = stockData
//             .map(d => ({
//                 ...d,
//                 Date: d.Date instanceof Date ? d.Date : new Date(d.Date),
//                 Open: typeof d.Open === 'number' ? d.Open : parseFloat(d.Open),
//                 High: typeof d.High === 'number' ? d.High : parseFloat(d.High),
//                 Low: typeof d.Low === 'number' ? d.Low : parseFloat(d.Low),
//                 Close: typeof d.Close === 'number' ? d.Close : parseFloat(d.Close)
//             }))
//             .filter(d => !isNaN(d.Open) && !isNaN(d.High) && !isNaN(d.Low) && !isNaN(d.Close))
//             .sort((a, b) => a.Date - b.Date);
        
//         // Rest of your existing candlestick chart code...
//         // Implement X and Y scales, axes, candlesticks, etc.
        
//         // Add information from allocation data to the chart
//         // For example, add a legend showing top holdings from each ETF
//         addAllocationInfo(svg, width, arkkData, iwfData, qqqData, uproData, allocations);
        
//     }).catch(error => {
//         chartContainer.innerHTML = `<div class="error">Error loading allocation data: ${error.message}</div>`;
//     });
// }

// Helper function to add allocation information to the chart
function addAllocationInfo(svg, width, arkkData, iwfData, qqqData, uproData, allocations) {
    // Get top 3 holdings from each ETF
    const topHoldings = {
        ARKK: arkkData.slice(0, 3).map(d => d.Name || d.company_name),
        IWF: iwfData.slice(0, 3).map(d => d.Name || d.company_name),
        QQQ: qqqData.slice(0, 3).map(d => d.Name || d.company_name),
        UPRO: uproData.slice(0, 3).map(d => d.Name || d.company_name)
    };
    
    // Create a legend with allocation percentages and top holdings
    const legend = svg.append('g')
        .attr('class', 'allocation-legend')
        .attr('transform', `translate(${width - 180}, 10)`);
    
    // Add background for better readability
    legend.append('rect')
        .attr('width', 170)
        .attr('height', 135)
        .attr('fill', 'rgba(255, 255, 255, 0.85)')
        .attr('rx', 5);
    
    // Add title
    legend.append('text')
        .attr('x', 10)
        .attr('y', 20)
        .text('Portfolio Allocation')
        .style('font-weight', 'bold');
    
    // Add ETF allocations
    const etfs = ['ARKK', 'IWF', 'QQQ', 'UPRO'];
    const colors = ['#7b3ff3', '#2ca02c', '#1f77b4', '#ff7f0e'];
    
    etfs.forEach((etf, i) => {
        // Add ETF name and allocation
        legend.append('rect')
            .attr('x', 10)
            .attr('y', 30 + i * 25)
            .attr('width', 12)
            .attr('height', 12)
            .attr('fill', colors[i]);
        
        legend.append('text')
            .attr('x', 30)
            .attr('y', 30 + i * 25 + 10)
            .text(`${etf}: ${allocations[etf]}%`)
            .style('font-size', '12px');
    });
}

        // Function to create company weightage chart
        function createCompanyWeightageChart() {
            // Ensure the chart container is cleared
            const chartContainer = document.getElementById('company-weightage-chart');
            chartContainer.innerHTML = ''; // Clear previous chart

            // Get current allocations
            const allocations = {
                'UPRO': parseInt(document.getElementById('upro-allocation').value) / 100,
                'QQQ': parseInt(document.getElementById('qqq-allocation').value) / 100,
                'IWF': parseInt(document.getElementById('iwf-allocation').value) / 100,
                'ARKK': parseInt(document.getElementById('arkk-allocation').value) / 100
            };
        
            // Fetch company weightage data from dedicated microservice
            fetch('http://localhost:5004/portfolio-company-weightage', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    tickers: {
                        'UPRO': allocations['UPRO'] * 100,
                        'QQQ': allocations['QQQ'] * 100,
                        'IWF': allocations['IWF'] * 100,
                        'ARKK': allocations['ARKK'] * 100
                    }
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to fetch company weightage data');
                }
                return response.json();
            })
            .then(data => {
                const companyData = data.portfolio_company_allocation || [];
            
                // Merge duplicate companies by summing their weights
                const mergedData = [];
                const companyMap = new Map();
            
                companyData.forEach(d => {
                    const companyName = d.Company;

                    // Check if the company name contains "U.S. Treasury" and merge them
                    if (companyName.includes('U.S. Treasury')) {
                        if (companyMap.has('U.S. Treasury Note')) {
                            companyMap.set('U.S. Treasury Note', companyMap.get('U.S. Treasury Note') + d.Weight);
                        } else {
                            companyMap.set('U.S. Treasury Note', d.Weight);
                        }
                    } else {
                        if (companyMap.has(companyName)) {
                            companyMap.set(companyName, companyMap.get(companyName) + d.Weight);
                        } else {
                            companyMap.set(companyName, d.Weight);
                        }
                    }
                });
            
                // Convert map to an array for D3 processing
                companyMap.forEach((weight, company) => {
                    mergedData.push({ Company: company, Weight: weight });
                });
            
                // Sort by weight in descending order
                mergedData.sort((a, b) => b.Weight - a.Weight);
            
                // Dimensions
                const width = chartContainer.clientWidth;
                const height = 500;
            
                // Create SVG
                const svg = d3.select(chartContainer)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);
            
                // Set a minimum light shade for the least significant value
                const minColor = "#b5d4e9"; // Light blue (can adjust to your desired light shade)
            
                // Color scale: Invert the color scale so the highest weight is the darkest
                const color = d3.scaleSequential(d3.interpolateBlues)
                    .domain([mergedData.length, 0]); // Inverted color scale (largest value is darkest)
            
                // Treemap layout
                const treemap = d3.treemap()
                    .size([width, height])
                    .padding(1)
                    .round(true);
            
                // Prepare hierarchical data
                const root = d3.hierarchy({
                    name: 'Portfolio',
                    children: mergedData.map(d => ({
                        name: d.Company,
                        value: d.Weight
                    }))
                }).sum(d => d.value);
            
                // Generate treemap
                treemap(root);
            
                // Create rectangles for each company
                const cell = svg.selectAll('g')
                    .data(root.leaves())
                    .enter().append('g')
                    .attr('transform', d => `translate(${d.x0},${d.y0})`);
            
                cell.append('rect')
                    .attr('width', d => d.x1 - d.x0)
                    .attr('height', d => d.y1 - d.y0)
                    .attr('fill', (d, i) => {
                        // Apply the minimum light shade for companies with weight below a threshold
                        return d.data.value < 0.001 ? minColor : color(i); // Use minColor for values below 1%
                    })
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
                
                // Add text labels for company names (truncate if too long)
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 15)
                    .text(d => {
                        const maxLength = 20;
                        const name = d.data.name;
                        return name.length > maxLength
                            ? name.substring(0, maxLength) + '...'
                            : name;
                    })
                    .attr('font-size', '12px')
                    .attr('fill', 'white')
                    .attr('font-weight', 'bold');
                
                // Add percentage labels for weight
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 30)
                    .text(d => `${d.data.value.toFixed(1)}%`)
                    .attr('font-size', '10px')
                    .attr('fill', 'white');
                
                // Create a tooltip for hover interactions
                const tooltip = d3.select('#tooltip');
                cell.on('mouseover', function(event, d) {
                    tooltip.style('opacity', 1)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <strong>${d.data.name}</strong><br>
                            Weight: ${d.data.value.toFixed(2)}%
                        `);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
            })
            .catch(error => {
                console.error('Error fetching company weightage:', error);
                chartContainer.innerHTML = `<p>Error loading company weightage: ${error.message}</p>`;
            });
        }

        // Function to create industry weightage chart
        function createIndustryWeightageChart(data) {
            const chartContainer = document.getElementById('industry-weightage-chart');
            chartContainer.innerHTML = '';
            
            // YOUR CODE HERE: Implement industry weightage chart (e.g., treemap or pie chart) using D3.js
            // Use data parameter which should contain industry weightage information
            
            console.log("Creating industry weightage chart with data:", Object.keys(data || {}).length, "industries");
        }

        // Function to create volume chart
        function createVolumeChart(data) {
            const chartContainer = document.getElementById('volume-chart');
            chartContainer.innerHTML = '';
            
            // YOUR CODE HERE: Implement volume chart using D3.js
            // Use data parameter which should contain volume data over time
            
            console.log("Creating volume chart with data:", data?.length || 0, "data points");
        }


                // Function to create correlation matrix
        //function createCorrelationMatrix(data) {
         //   const chartContainer = document.getElementById('correlation-chart');
          //  chartContainer.innerHTML = '';
            
            
            // YOUR CODE HERE: Implement correlation matrix heatmap using D3.js
            // Use data parameter which should contain correlation coefficients between different assets
            
         //   console.log("Creating correlation matrix with data:", data?.length || 0, "correlations");
        //}
        function createCorrelationMatrix() {
    console.log("Starting correlation matrix creation...");
    const chartContainer = document.getElementById('correlation-chart');
    if (!chartContainer) {
        console.error("Correlation chart container not found");
        return;
    }
    chartContainer.innerHTML = '<div class="loading">Loading correlation data...</div>';

    // Log the paths being accessed
    console.log("Attempting to load CSV files from:", [
        "./angela_datasets/arkk.csv",
        "./angela_datasets/iwf.csv",
        "./angela_datasets/qqq.csv",
        "./angela_datasets/upro.csv"
    ]);

    // Load ETF data from CSV files with error handling
    Promise.all([
        d3.csv("./angela_datasets/arkk.csv").catch(error => {
            console.error("Error loading ARKK data:", error);
            return [];
        }),
        d3.csv("./angela_datasets/iwf.csv").catch(error => {
            console.error("Error loading IWF data:", error);
            return [];
        }),
        d3.csv("./angela_datasets/qqq.csv").catch(error => {
            console.error("Error loading QQQ data:", error);
            return [];
        }),
        d3.csv("./angela_datasets/upro.csv").catch(error => {
            console.error("Error loading UPRO data:", error);
            return [];
        })
    ]).then(function(files) {
        const [arkkData, iwfData, qqqData, uproData] = files;
        
        console.log("Data loaded:", {
            ARKK: arkkData.length,
            IWF: iwfData.length,
            QQQ: qqqData.length,
            UPRO: uproData.length
        });

        // Process and filter data
        const processData = (data) => {
            return data
                .map(d => ({
                    date: new Date(d.Date),
                    close: parseFloat(d.Close || d.Price) // Try both Close and Price columns
                }))
                .filter(d => !isNaN(d.close) && d.date instanceof Date && !isNaN(d.date))
                .sort((a, b) => a.date - b.date);
        };

        const filteredData = {
            ARKK: processData(arkkData),
            IWF: processData(iwfData),
            QQQ: processData(qqqData),
            UPRO: processData(uproData)
        };

        console.log("Processed data points:", {
            ARKK: filteredData.ARKK.length,
            IWF: filteredData.IWF.length,
            QQQ: filteredData.QQQ.length,
            UPRO: filteredData.UPRO.length
        });

        // Calculate correlations
        const etfs = ['ARKK', 'IWF', 'QQQ', 'UPRO'];
        const matrix = calculateCorrelationMatrix(filteredData, etfs);

        // Create visualization
        createVisualization(matrix, etfs, chartContainer);
    }).catch(error => {
        console.error("Error loading CSV files:", error);
        chartContainer.innerHTML = `<div class="error">Error loading data: ${error.message}</div>`;
    });
}

function calculateCorrelationMatrix(data, etfs) {
    return etfs.map(etf1 => 
        etfs.map(etf2 => {
            try {
                const correlation = calculatePearsonCorrelation(
                    data[etf1].map(d => d.close),
                    data[etf2].map(d => d.close)
                );
                return {
                    source: etf1,
                    target: etf2,
                    correlation: isNaN(correlation) ? 0 : correlation
                };
            } catch (error) {
                console.error(`Error calculating correlation between ${etf1} and ${etf2}:`, error);
                return {
                    source: etf1,
                    target: etf2,
                    correlation: 0
                };
            }
        })
    );
}

function calculatePearsonCorrelation(x, y) {
    if (!Array.isArray(x) || !Array.isArray(y) || x.length === 0 || y.length === 0) {
        console.warn("Invalid input arrays");
        return 0;
    }

    const n = Math.min(x.length, y.length);
    const sum_x = x.reduce((a, b) => a + (isNaN(b) ? 0 : b), 0);
    const sum_y = y.reduce((a, b) => a + (isNaN(b) ? 0 : b), 0);
    
    const mean_x = sum_x / n;
    const mean_y = sum_y / n;
    
    let numerator = 0;
    let denominator_x = 0;
    let denominator_y = 0;
    
    for (let i = 0; i < n; i++) {
        if (isNaN(x[i]) || isNaN(y[i])) continue;
        const dx = x[i] - mean_x;
        const dy = y[i] - mean_y;
        numerator += dx * dy;
        denominator_x += dx * dx;
        denominator_y += dy * dy;
    }
    
    if (denominator_x === 0 || denominator_y === 0) return 0;
    return numerator / Math.sqrt(denominator_x * denominator_y);
}

function createVisualization(matrix, etfs, container) {
    // Clear container
    container.innerHTML = '';

    const margin = { top: 50, right: 50, bottom: 50, left: 50 };
    const width = Math.min(500, container.clientWidth - margin.left - margin.right);
    const height = width;
    const cellSize = Math.floor(width / etfs.length);

    // Create SVG
    const svg = d3.select(container)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // Color scale
    const color = d3.scaleLinear()
        .domain([-1, 0, 1])
        .range(['#ff4444', '#ffffff', '#4444ff']);

    // Create cells
    svg.selectAll('rect')
        .data(matrix.flat())
        .enter()
        .append('rect')
        .attr('x', d => etfs.indexOf(d.target) * cellSize)
        .attr('y', d => etfs.indexOf(d.source) * cellSize)
        .attr('width', cellSize)
        .attr('height', cellSize)
        .attr('fill', d => color(d.correlation))
        .attr('stroke', '#fff');

    // Add correlation values
    svg.selectAll('text.value')
        .data(matrix.flat())
        .enter()
        .append('text')
        .attr('class', 'value')
        .attr('x', d => etfs.indexOf(d.target) * cellSize + cellSize/2)
        .attr('y', d => etfs.indexOf(d.source) * cellSize + cellSize/2)
        .attr('dy', '.35em')
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .style('fill', d => Math.abs(d.correlation) > 0.5 ? '#fff' : '#000')
        .text(d => d.correlation.toFixed(2));

    // Add labels
    etfs.forEach((etf, i) => {
        // X axis labels
        svg.append('text')
            .attr('x', i * cellSize + cellSize/2)
            .attr('y', -10)
            .attr('text-anchor', 'middle')
            .text(etf);

        // Y axis labels
        svg.append('text')
            .attr('x', -10)
            .attr('y', i * cellSize + cellSize/2)
            .attr('text-anchor', 'end')
            .attr('alignment-baseline', 'middle')
            .text(etf);
    });
}
      // Function to create drawdown chart
        function createDrawdownChart(portfolioData) {
            const chartContainer = document.getElementById('drawdown-chart');
            chartContainer.innerHTML = '';
            
            // Check if we have data
            if (!portfolioData || portfolioData.length === 0) {
                chartContainer.innerHTML = '<div class="error">No data available for drawdown analysis</div>';
                return;
            }
            
            // Check container width first
            const containerWidth = chartContainer.clientWidth;
            
            if (containerWidth <= 0) {
                // Wait for the layout to stabilize (e.g., tab becoming visible)
                setTimeout(() => createDrawdownChart(portfolioData), 100);
                return;
            }
            
            // Use smaller margins if container is narrow
            const margin = containerWidth < 400 
                ? {top: 20, right: 30, bottom: 50, left: 40}
                : {top: 20, right: 80, bottom: 50, left: 80};
            
            const width = Math.max(containerWidth - margin.left - margin.right, 100); // Ensure minimum width
            const height = 400 - margin.top - margin.bottom;
            
            const svg = d3.select(chartContainer)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Make sure dates are Date objects and sort data chronologically
            portfolioData = portfolioData
                .map(d => ({
                    ...d,
                    Date: d.Date instanceof Date ? d.Date : new Date(d.Date),
                    // Ensure drawdown is numeric and within reasonable bounds
                    drawdown: typeof d.drawdown === 'number' && !isNaN(d.drawdown) ? 
                            Math.max(Math.min(d.drawdown, 0), -1) : 0,
                    total_value: typeof d.total_value === 'number' && !isNaN(d.total_value) ?
                                d.total_value : 0,
                    peak_value: typeof d.peak_value === 'number' && !isNaN(d.peak_value) ?
                                d.peak_value : 0
                }))
                .sort((a, b) => a.Date - b.Date);
            
            // If we have fewer than 2 data points after filtering, show error
            if (portfolioData.length < 2) {
                chartContainer.innerHTML = '<div class="error">Not enough valid data points for drawdown analysis</div>';
                return;
            }
            
            // Calculate domain for drawdown
            const minDrawdown = d3.min(portfolioData, d => d.drawdown);
            
            // X scale
            const x = d3.scaleTime()
                .domain(d3.extent(portfolioData, d => d.Date))
                .range([0, width]);
            
            // Y scale for drawdown (negative values)
            // Set a reasonable minimum (e.g., -0.1 for -10% if no drawdown)
            const yMin = Math.min(minDrawdown * 1.1 || -0.1, -0.1);
            
            const y = d3.scaleLinear()
                .domain([yMin, 0]) 
                .range([height, 0]);
            
            // X axis
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(width > 500 ? 10 : 5)
                    .tickFormat(d3.timeFormat('%b %Y')))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            // Y axis
            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y)
                    .tickFormat(d => `${d3.format('.0%')(d)}`));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -margin.left + 20) // Adjust based on margin
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Drawdown (%)')
                .style('fill', '#666');
            
            // Create the area generator for drawdown visualization
            const area = d3.area()
                .x(d => x(d.Date))
                .y0(d => y(d.drawdown))  // Bottom of the area is at the drawdown value
                .y1(y(0))                // Top of the area is at zero
                .defined(d => !isNaN(d.drawdown))
                .curve(d3.curveMonotoneX); // Add smooth curve
            
            // Draw the area in red (representing drawdown)
            svg.append('path')
                .datum(portfolioData)
                .attr('fill', 'rgba(255, 0, 0, 0.3)')
                .attr('d', area);
            
            // Draw the drawdown line
            const line = d3.line()
                .x(d => x(d.Date))
                .y(d => y(d.drawdown))
                .defined(d => !isNaN(d.drawdown))
                .curve(d3.curveMonotoneX); // Add smooth curve
            
            svg.append('path')
                .datum(portfolioData)
                .attr('fill', 'none')
                .attr('stroke', 'rgb(255, 0, 0)')
                .attr('stroke-width', 2)
                .attr('d', line);
            
            // Add a zero line
            svg.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', y(0))
                .attr('y2', y(0))
                .attr('stroke', '#888')
                .attr('stroke-dasharray', '3,3');
            
            // Add grid lines for better readability
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y)
                    .tickValues([-0.1, -0.2, -0.3, -0.4, -0.5]) // 10%, 20%, 30%, 40%, 50% drawdown lines
                    .tickSize(-width)
                    .tickFormat(''))
                .style('stroke', '#e0e0e0')
                .style('stroke-opacity', 0.7)
                .style('shape-rendering', 'crispEdges');
            
            // Add vertical grid lines
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(10)
                    .tickSize(-height)
                    .tickFormat(''))
                .style('stroke', '#e0e0e0')
                .style('stroke-opacity', 0.5)
                .style('shape-rendering', 'crispEdges');
            
            // Add tooltip elements
            const tooltip = d3.select('#tooltip');
            const bisect = d3.bisector(d => d.Date).left;
            
            // Add tooltip vertical line and dot
            const tooltipLine = svg.append("line")
                .attr("stroke", "#666")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3")
                .attr("y1", 0)
                .attr("y2", height)
                .style("opacity", 0);
                
            const tooltipDot = svg.append("circle")
                .attr("r", 5)
                .attr("fill", "rgb(255, 0, 0)")
                .attr("stroke", "white")
                .attr("stroke-width", 2)
                .style("opacity", 0);
            
            // Add transparent overlay for mouse interaction
            svg.append('rect')
                .attr('width', width > 0 ? width : 0) // Ensure width is not negative
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mouseover', function() {
                    tooltip.style('opacity', 1);
                    tooltipLine.style('opacity', 1);
                    tooltipDot.style('opacity', 1);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                    tooltipLine.style('opacity', 0);
                    tooltipDot.style('opacity', 0);
                })
                .on('mousemove', function(event) {
                    const mouseX = d3.pointer(event)[0];
                    const x0 = x.invert(mouseX);
                    const i = bisect(portfolioData, x0, 1);
                    
                    if (i >= portfolioData.length) return;
                    
                    const d0 = portfolioData[i - 1];
                    const d1 = portfolioData[i];
                    if (!d0 || !d1) return;
                    
                    const d = x0 - d0.Date > d1.Date - x0 ? d1 : d0;
                    
                    // Update tooltip line position
                    tooltipLine
                        .attr("x1", x(d.Date))
                        .attr("x2", x(d.Date));
                        
                    // Update tooltip dot position
                    tooltipDot
                        .attr("cx", x(d.Date))
                        .attr("cy", y(d.drawdown));
                    
                    // Format tooltip content
                    tooltip.style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <div style="font-weight: bold; margin-bottom: 5px;">${formatDate(d.Date)}</div>
                            <div style="color: ${d.drawdown < -0.1 ? '#dc3545' : '#6c757d'}">
                                <strong>Drawdown:</strong> ${d3.format('.2%')(d.drawdown)}
                            </div>
                            <div style="margin-top: 5px;">
                                <strong>Peak Value:</strong> ${formatCurrency(d.peak_value)}
                            </div>
                            <div>
                                <strong>Current Value:</strong> ${formatCurrency(d.total_value)}
                            </div>
                            <div>
                                <strong>Decline Amount:</strong> ${formatCurrency(d.total_value - d.peak_value)}
                            </div>
                        `);
                });
            
            // Add annotations for major drawdown events
            // Find significant drawdowns (below -20%)
            const significantDrawdowns = portfolioData.filter(d => d.drawdown < -0.2);
            
            if (significantDrawdowns.length > 0) {
                // Find local minimums in drawdowns by comparing neighbors
                const drawdownEvents = [];
                
                for (let i = 1; i < portfolioData.length - 1; i++) {
                    const prev = portfolioData[i-1];
                    const curr = portfolioData[i];
                    const next = portfolioData[i+1];
                    
                    // If current point is a local minimum and below -15%
                    if (curr.drawdown < -0.15 && 
                        curr.drawdown <= prev.drawdown && 
                        curr.drawdown <= next.drawdown) {
                        
                        // Check if we already have a similar drawdown event nearby
                        const isUnique = !drawdownEvents.some(event => 
                            Math.abs(event.Date - curr.Date) < 30 * 24 * 60 * 60 * 1000 && // Within 30 days
                            Math.abs(event.drawdown - curr.drawdown) < 0.05 // Within 5% drawdown difference
                        );
                        
                        if (isUnique) {
                            drawdownEvents.push(curr);
                        }
                    }
                }
                
                // Sort by severity and take top 3
                drawdownEvents.sort((a, b) => a.drawdown - b.drawdown);
                const topDrawdowns = drawdownEvents.slice(0, 3);
                
                // Add annotations
                topDrawdowns.forEach(event => {
                    // Create annotation
                    svg.append("line")
                        .attr("x1", x(event.Date))
                        .attr("x2", x(event.Date))
                        .attr("y1", y(event.drawdown))
                        .attr("y2", y(event.drawdown) - 40)
                        .attr("stroke", "#ff0000")
                        .attr("stroke-width", 1)
                        .attr("stroke-dasharray", "3,3");
                        
                    svg.append("circle")
                        .attr("cx", x(event.Date))
                        .attr("cy", y(event.drawdown))
                        .attr("r", 4)
                        .attr("fill", "#ff0000");
                        
                    svg.append("text")
                        .attr("x", x(event.Date))
                        .attr("y", y(event.drawdown) - 45)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "10px")
                        .text(`${d3.format('.1%')(event.drawdown)}`)
                        .style("fill", "#ff0000");
                });
            }
        }

        // Helper function to show API error
        function showApiError(message) {
            const errorEl = document.getElementById('api-error');
            const messageEl = document.getElementById('error-message');
            messageEl.textContent = message;
            errorEl.style.display = 'block';
        }

        // Helper function to hide API error
        function hideApiError() {
            const errorEl = document.getElementById('api-error');
            errorEl.style.display = 'none';
        }

        // Helper function to format currency
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value);
        }

        // Helper function to format percentage
        function formatPercentage(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'percent',
                minimumFractionDigits: 1,
                maximumFractionDigits: 1
            }).format(value);
        }

        // Helper function to format date
        function formatDate(date) {
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }
    </script>
</body>