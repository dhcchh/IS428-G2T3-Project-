<!-- CHANGES
1. function initializeTimePeriodButtons() - call createVolumeChart();
2. function initializeTabs() -  else if (tabId === 'volume') {createVolumeChart();
3. function createVolumeChart() - added code to create volume chart
4. document.getElementById('calculate-button') - updateVolumeChart(); added code to call update volume chart
5. function updateVolumeChart() - added code to update volume chart
6. function fetchAllData(payload) - removed createVolumeChart();
7. <div class="time-period-buttons"> - removed 3Y, 5Y and MAX buttons
8. function calculateStartDate(period) - removed CASE 3Y and 5Y

9. function fetchAllData(payload) - removed createIndustryWeightageChart(industryWeightageData); 
10. function initializeTabs() -  else if (tabId === 'industry-weightage') createIndustryWeightageChart();

-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Risk Short-Term Investment Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js" charset="utf-8"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .header h5 {
            margin-top: 0;
            color: #7f8c8d;
        }
        .dashboard {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .controls h3 {
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric-card {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
        }
        .metric-card h3 {
            margin: 10px 0;
            font-size: 1.8rem;
        }
        .metric-card p {
            margin: 0;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        .charts {
            display: grid;
            grid-template-rows: auto;
            gap: 20px;
        }
        .chart-container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .chart-container h3 {
            margin-top: 0;
            margin-bottom: 20px;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        input[type="range"] {
            width: 100%;
        }
        .allocation-display {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
        }
        button {
            width: 100%;
            padding: 10px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 20px;
        }
        button:hover {
            background-color: #2980b9;
        }
        .tab-container {
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .tab.active {
            border-bottom-color: #3498db;
            font-weight: 500;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .warning {
            color: #e74c3c;
            margin-top: 5px;
            font-size: 0.9rem;
        }
        .axis line, .axis path {
            stroke: #ddd;
        }
        .axis text {
            fill: #666;
            font-size: 0.8rem;
        }
        .notes {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        .notes h5 {
            margin-top: 0;
        }
        .notes ul {
            padding-left: 20px;
        }
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 2px;
        }
        .api-error {
            background-color: #fee;
            color: #e74c3c;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        /* CSS for the time period buttons */
        .time-period-buttons {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
        }

        .time-btn {
            flex: 1;
            padding: 8px 0;
            margin: 0 4px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            color: black;
        }

        .time-btn:first-child {
            margin-left: 0;
        }

        .time-btn:last-child {
            margin-right: 0;
        }

        .time-btn:hover {
            background-color: #e9ecef;
        }

        .time-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        /* Additional CSS for Portfolio vs upro comparison */
        .portfolio-line {
            stroke-width: 3px;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .upro-line {
            stroke-width: 2px;
            stroke-dasharray: 5, 5;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .outperformance-positive {
            color: #28a745;
            font-weight: bold;
        }

        .outperformance-negative {
            color: #dc3545;
            font-weight: bold;
        }

        .grid line {
            stroke: #e0e0e0;
            stroke-opacity: 0.7;
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }
        .loading:after {
            content: '...';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        .tooltip-trigger {
            position: relative;
            display: inline-flex;
            margin-left: 5px;
            cursor: help;
        }

        .tooltip-trigger .info-icon {
            width: 16px;
            height: 16px;
        }

        .tooltip-trigger:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 100%;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            width: 250px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            font-weight: normal;
            line-height: 1.4;
        }

        .tooltip-trigger:hover::before {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 100%;
            border: 8px solid transparent;
            border-top-color: #333;
            pointer-events: none;
        }

        /* addition code SH */
        /* Add these new styles before .grid line */
    #correlation-chart {
        min-height: 500px;
        position: relative;
    }

    .loading {
        text-align: center;
        padding: 20px;
        color: #666;
    }

    .error {
        color: #721c24;
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        padding: 1rem;
        margin: 1rem 0;
        border-radius: 0.25rem;
    }

    .grid line {
        stroke: #e0e0e0;
        stroke-opacity: 0.7;
        shape-rendering: crispEdges;
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>High Risk Short-Term Investment Dashboard</h1>
            <h5>Comprehensive Portfolio Analysis</h5>
        </div>
        
        <div id="api-error" class="api-error">
            <strong>Error connecting to API:</strong> <span id="error-message"></span>
        </div>
        
        <div class="dashboard">
            <div class="controls">
                <h3>Investment Parameters</h3>
                
                <!-- HTML for time period buttons -->
                <div class="control-group">
                    <label>Investment Period:</label>
                    <div class="time-period-buttons">
                        <button class="time-btn" data-period="1M">1M</button>
                        <button class="time-btn" data-period="6M">6M</button>
                        <button class="time-btn" data-period="1Y">1Y</button>
                    </div>
                    <div id="date-range-display" style="text-align: center; margin-top: 10px; display: none;">Loading date range...</div>
                </div>
                
                <div class="control-group">
                    <label>Initial Investment (SGD):</label>
                    <input type="number" id="initial-investment" min="1000" max="1000000" step="1000" value="10000">
                    <small style="color: #7f8c8d;">Min: $1,000 - Max: $1,000,000</small>
                </div>
                
                <div class="control-group">
                    <label>Portfolio Allocation:</label>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>UPRO</span>
                            <span id="upro-value">25%</span>
                        </div>
                        <input type="range" id="upro-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>QQQ</span>
                            <span id="qqq-value">25%</span>
                        </div>
                        <input type="range" id="qqq-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>IWF</span>
                            <span id="iwf-value">25%</span>
                        </div>
                        <input type="range" id="iwf-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>ARKK</span>
                            <span id="arkk-value">25%</span>
                        </div>
                        <input type="range" id="arkk-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div id="allocation-warning" class="warning"></div>
                </div>
                
                <button id="calculate-button">Calculate Returns</button>
            </div>
            
            <div class="content">
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Final Portfolio Value</h4>
                        <h3 id="final-value">$0.00</h3>
                        <p id="initial-value">Initial: $0.00</p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>Total Return
                            <span class="tooltip-trigger" data-tooltip="The total growth rate of your investment">
                                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="total-return">0.0%</h3>
                        <p id="annualized-return">
                            Annualized: 0.0% per year
                        </p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>
                            Maximum Drawdown
                            <span class="tooltip-trigger" data-tooltip="The percentage drop from your investment's highest value to its lowest point during a specific period. Shows potential losses you might face before recovery.">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="max-drawdown">0.0%</h3>
                        <p>Largest decline from peak</p>
                    </div>
                    
                    <div class="metric-card" id="risk-card">
                        <h4>
                            Risk Level
                            <span class="tooltip-trigger" data-tooltip="Measures how dramatically an investment's price changes over time. Higher volatility means bigger price swings both up and down.">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="volatility">Low (0.0%)</h3>
                        <p>Portfolio volatility</p>
                    </div>   
                </div>
                
                <div class="tab-container">
                    <ul class="tabs">
                        <li class="tab active" data-tab="candlestick">Candlestick</li>
                        <li class="tab" data-tab="company-weightage">Company Weightage</li>
                        <li class="tab" data-tab="industry-weightage">Industry Weightage</li>
                        <li class="tab" data-tab="volume">Volume Analysis</li>
                        <li class="tab" data-tab="correlation">Correlation</li>
                        <li class="tab" data-tab="drawdown">Drawdown Analysis</li>
                    </ul>
                </div>
                
                <div class="charts">
                    <div id="candlestick" class="tab-content active">
                        <div class="chart-container">
                            <h3>Candlestick Chart</h3>
                            <div id="candlestick-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="candlestick-legend"></div>
                        </div>
                    </div>
                    
                    <div id="company-weightage" class="tab-content">
                        <div class="chart-container">
                            <h3>ETF Company Weightage</h3>
                            <div id="company-weightage-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="company-weightage-legend"></div>
                        </div>
                    </div>
                    
                    <div id="industry-weightage" class="tab-content">
                        <div class="chart-container">
                            <h3>ETF Industry Weightage</h3>
                            <div id="industry-weightage-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="industry-weightage-legend"></div>
                        </div>
                    </div>
                    
                    <div id="volume" class="tab-content">
                        <div class="chart-container">
                            <h3>Volume Analysis</h3>
                            <div id="volume-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- <div id="correlation" class="tab-content">
                        <div class="chart-container">
                            <h3>Correlation Matrix</h3>
                            <div id="correlation-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="correlation-legend"></div>
                        </div>
                    </div> -->
                    <div id="correlation" class="tab-content">
                        <div class="chart-container">
                            <h3>Correlation Matrix</h3>
                            <div id="correlation-chart"></div>
                        </div>
                    </div>
                    
                    <div id="drawdown" class="tab-content">
                        <div class="chart-container">
                            <h3>Portfolio Drawdown Analysis</h3>
                            <div id="drawdown-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add a tooltip div -->
    <div id="tooltip" class="tooltip"></div>

    <script>
        // API URLs
        const API_BASE_URL = 'http://localhost:5001';
        const API_DATE_RANGE = `${API_BASE_URL}/api/date-range`;
        const API_PORTFOLIO_VALUE = `${API_BASE_URL}/api/portfolio-value`;
        const API_TOTAL_RETURN = `${API_BASE_URL}/api/total-return`;
        const API_MAX_DRAWDOWN = `${API_BASE_URL}/api/max-drawdown`;
        const API_RISK_LEVEL = `${API_BASE_URL}/api/risk-level`;
        const API_PORTFOLIO_GROWTH = `${API_BASE_URL}/api/portfolio-growth`;
        const API_DRAWDOWN_ANALYSIS = `${API_BASE_URL}/api/drawdown-analysis`;
        const API_ETF_COMPARISON = `${API_BASE_URL}/api/etf-comparison`;
        const API_YEARLY_RETURNS = `${API_BASE_URL}/api/yearly-returns`;
        const API_CALCULATE_ALL = `${API_BASE_URL}/api/calculate-all`;
        
        // Add new API endpoints for the new charts
        const API_COMPANY_WEIGHTAGE = `${API_BASE_URL}/api/company-weightage`;
        // const API_INDUSTRY_WEIGHTAGE = `${API_BASE_URL}/api/industry-weightage`;
        // const API_VOLUME_ANALYSIS = `${API_BASE_URL}/api/volume-analysis`;
        const API_CORRELATION_MATRIX = `${API_BASE_URL}/api/correlation-matrix`;
        //const API_CANDLESTICK_DATA = `${API_BASE_URL}/api/candlestick-data`;

        // Global variables
        let minDate, maxDate;
        let selectedStartDate, selectedEndDate;
        let portfolioData = null;
        let candlestickData = null;
        let companyWeightageData = null;
        let industryWeightageData = null;
        let volumeData = null;
        //let correlationData = null;
        let drawdownData = null;
        let etfPerformance = null;
        let yearlyReturns = null;
        
        // Main application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize tooltips
            const tooltip = d3.select('#tooltip');
            
            // Initialize date range
            fetchDateRange();
            
            // Initialize allocation sliders
            initializeAllocationSliders();
            
            // Set up tabs
            initializeTabs();
            
            // Set up time period buttons
            initializeTimePeriodButtons();
            
            // Set up calculate button
            document.getElementById('calculate-button').addEventListener('click', function() {
                calculateAndFetchResults();
                updateVolumeChart(); 
            });
            
            // Initial calculation will be triggered after date range is fetched
        });

        // Utility function to wait for elements to exist in the DOM
        function waitForElement(elementId, callback, checkFrequencyInMs, timeoutInMs) {
            var startTimeInMs = Date.now();
            var checkElementAndCallback = function() {
                var element = document.getElementById(elementId);
                if (element) {
                    console.log(elementId + " element found!");
                    callback(element);
                    return;
                }
                
                if (timeoutInMs && Date.now() - startTimeInMs > timeoutInMs) {
                    console.log(elementId + " element not found within timeout period");
                    return;
                }
                
                setTimeout(checkElementAndCallback, checkFrequencyInMs);
            };
            
            checkElementAndCallback();
        }

        // Helper function to find the parent metric card of an element
        function findParentCard(elementId) {
            const element = document.getElementById(elementId);
            if (!element) {
                console.log("Element with ID " + elementId + " not found");
                return null;
            }
            
            // Find parent metric card
            const parentCard = element.closest('.metric-card');
            if (parentCard) {
                console.log("Found parent card for " + elementId);
                return parentCard;
            } else {
                console.log("Could not find parent card for " + elementId);
                return null;
            }
        }

        // 1. RISK/VOLATILITY MONITORING
        function setupRiskMonitoring(volatilityElement) {
            console.log("Setting up risk/volatility monitoring");
            
            // Find the risk card element
            const riskCard = findParentCard('volatility');
            
            if (riskCard) {
                setupRiskObserver(volatilityElement, riskCard);
            } else {
                console.error("Could not find parent card for volatility");
            }
        }

        function setupRiskObserver(volatilityElement, cardElement) {
            function updateRiskCardColor() {
                const volatilityText = volatilityElement.innerText || volatilityElement.textContent;
                console.log("Volatility text:", volatilityText);
                
                if (volatilityText.includes('Very Low') || volatilityText.includes('Low')) {
                    cardElement.style.backgroundColor = 'rgba(40, 167, 69, 0.15)'; // light green
                    console.log("Set risk card to green");
                } else if (volatilityText.includes('High') || volatilityText.includes('Very High')) {
                    cardElement.style.backgroundColor = 'rgba(220, 53, 69, 0.15)'; // light red
                    console.log("Set risk card to red");
                } else {
                    cardElement.style.backgroundColor = 'rgba(255, 193, 7, 0.15)'; // light yellow for Moderate
                    console.log("Set risk card to yellow");
                }
            }
            
            // Initial update
            updateRiskCardColor();
            
            // Create a separate observer for risk
            const riskObserver = new MutationObserver(function() {
                console.log("Risk observer triggered");
                updateRiskCardColor();
            });
            
            // Start observing
            riskObserver.observe(volatilityElement, { 
                childList: true, 
                characterData: true,
                subtree: true 
            });
            
            console.log("Risk monitoring setup complete");
        }

        // 2. DRAWDOWN MONITORING
        function setupDrawdownMonitoring(drawdownElement) {
            console.log("Setting up drawdown monitoring");
            
            // Find the drawdown card element
            const drawdownCard = findParentCard('max-drawdown');
            
            if (drawdownCard) {
                setupDrawdownObserver(drawdownElement, drawdownCard);
            } else {
                console.error("Could not find parent card for drawdown");
            }
        }

        function setupDrawdownObserver(drawdownElement, cardElement) {
            function updateDrawdownCardColor() {
                const drawdownText = drawdownElement.innerText || drawdownElement.textContent;
                console.log("Drawdown text:", drawdownText);
                
                const cleanText = drawdownText.replace(/[^\d.-]/g, '');
                const drawdownValue = parseFloat(cleanText);
                
                if (isNaN(drawdownValue)) {
                    console.error("Could not parse a valid number from drawdown text");
                    return;
                }
                
                console.log("Drawdown value:", drawdownValue);
                
                if (drawdownValue <= -15) {
                    cardElement.style.backgroundColor = '#ffe6e6'; // Light red
                    console.log("Set drawdown card to red");
                } else {
                    cardElement.style.backgroundColor = '#e6f7e6'; // Light green
                    console.log("Set drawdown card to green");
                }
            }
            
            // Initial update
            updateDrawdownCardColor();
            
            // Create a separate observer for drawdown
            const drawdownObserver = new MutationObserver(function() {
                console.log("Drawdown observer triggered");
                updateDrawdownCardColor();
            });
            
            // Start observing
            drawdownObserver.observe(drawdownElement, { 
                childList: true, 
                characterData: true,
                subtree: true 
            });
            
            console.log("Drawdown monitoring setup complete");
        }

        // 3. PORTFOLIO RETURN MONITORING (FOR BOTH PORTFOLIO VALUE AND TOTAL RETURN CARDS)
        function setupReturnMonitoring(annualizedReturnElement) {
            console.log("Setting up annualized return monitoring");
            
            // Find both card elements
            const portfolioValueCard = findParentCard('final-value');
            const totalReturnCard = findParentCard('total-return');
            
            if (!portfolioValueCard) {
                console.error("Could not find portfolio value card");
            }
            
            if (!totalReturnCard) {
                console.error("Could not find total return card");
            }
            
            // Set up the monitoring if at least one card was found
            if (portfolioValueCard || totalReturnCard) {
                setupReturnObserver(annualizedReturnElement, portfolioValueCard, totalReturnCard);
            }
        }

        function setupReturnObserver(annualizedReturnElement, portfolioValueCard, totalReturnCard) {
            function updateReturnCards() {
                const returnText = annualizedReturnElement.innerText || annualizedReturnElement.textContent;
                console.log("Annualized return text:", returnText);
                
                // Extract the percentage value (looking for a number followed by % per year)
                const matches = returnText.match(/(-?\d+\.?\d*)%/);
                if (!matches || matches.length < 2) {
                    console.error("Could not parse annualized return percentage");
                    return;
                }
                
                const annualizedReturnValue = parseFloat(matches[1]);
                console.log("Parsed annualized return value:", annualizedReturnValue);
                
                // Apply the appropriate background color based on the threshold
                if (annualizedReturnValue >= 6) {
                    console.log("Setting cards to green (>= 6%)");
                    if (portfolioValueCard) portfolioValueCard.style.backgroundColor = '#e6f7e6'; // Light green
                    if (totalReturnCard) totalReturnCard.style.backgroundColor = '#e6f7e6'; // Light green
                } else {
                    console.log("Setting cards to red (< 6%)");
                    if (portfolioValueCard) portfolioValueCard.style.backgroundColor = '#ffe6e6'; // Light red
                    if (totalReturnCard) totalReturnCard.style.backgroundColor = '#ffe6e6'; // Light red
                }
            }
            
            // Initial update
            updateReturnCards();
            
            // Create an observer for the annualized return
            const returnObserver = new MutationObserver(function() {
                console.log("Annualized return observer triggered");
                updateReturnCards();
            });
            
            // Start observing
            returnObserver.observe(annualizedReturnElement, { 
                childList: true, 
                characterData: true,
                subtree: true 
            });
            
            console.log("Annualized return monitoring setup complete");
        }

        // Initialize all monitors when the page loads
        window.addEventListener('load', function() {
            console.log("Window loaded, setting up all monitors");
            
            // 1. Set up risk/volatility monitoring
            waitForElement('volatility', setupRiskMonitoring, 100, 10000);
            
            // 2. Set up maximum drawdown monitoring
            waitForElement('max-drawdown', setupDrawdownMonitoring, 100, 10000);
            
            // 3. Set up return monitoring (for both portfolio value and total return cards)
            waitForElement('annualized-return', setupReturnMonitoring, 100, 10000);
        });
        
        // Function to update the risk card background color
        function updateRiskCardColor() {
            const riskCard = document.getElementById('risk-card');
            const volatilityText = document.getElementById('volatility').innerText;
            
            if (volatilityText.includes('Very Low') || volatilityText.includes('Low')) {
                riskCard.style.backgroundColor = 'rgba(40, 167, 69, 0.15)'; // light green
            } else if (volatilityText.includes('High') || volatilityText.includes('Very High')) {
                riskCard.style.backgroundColor = 'rgba(220, 53, 69, 0.15)'; // light red
            } else {
                riskCard.style.backgroundColor = 'rgba(255, 193, 7, 0.15)'; // light yellow for Moderate
            }
        }

        // Call the function initially
        updateRiskCardColor();

        // Set up a MutationObserver to watch for changes to the volatility text
        const observer = new MutationObserver(updateRiskCardColor);
        observer.observe(document.getElementById('volatility'), { 
            childList: true, 
            characterData: true,
            subtree: true
        });
        
        // Function to fetch date range from API
        function fetchDateRange() {
            fetch(API_DATE_RANGE)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    minDate = new Date(data.min_date);
                    maxDate = new Date(data.max_date);
                    
                    // Set default selected dates to max range
                    selectedStartDate = minDate;
                    selectedEndDate = maxDate;
                    
                    // Display date range text initially
                    updateDateRangeDisplay();
                    
                    // Display ETF returns if needed
                    const etfReturns = data.etf_returns;
                    for (const etf in etfReturns) {
                        const returnEl = document.getElementById(`${etf.toLowerCase()}-return`);
                        if (returnEl) {
                            returnEl.textContent = `${etfReturns[etf].toFixed(2)}%`;
                        }
                    }
                    
                    // Now that we have the date range, trigger the initial calculation
                    calculateAndFetchResults();
                })
                .catch(error => {
                    showApiError(`Failed to fetch date range: ${error.message}`);
                });
        }

        // Function to initialize time period buttons
        function initializeTimePeriodButtons() {
            const buttons = document.querySelectorAll('.time-btn');
            
            buttons.forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all buttons
                    buttons.forEach(btn => btn.classList.remove('active'));
                    
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Get the selected period
                    const period = this.getAttribute('data-period');
                    
                    // Calculate start and end dates based on the period
                    if (period === 'MAX') {
                        selectedStartDate = minDate;
                        selectedEndDate = maxDate;
                    } else {
                        selectedEndDate = new Date(maxDate); // Use a copy of maxDate
                        selectedStartDate = calculateStartDate(period);
                    }
                    
                    // Update the date range display
                    updateDateRangeDisplay();
                    
                    // If allocations are valid, trigger calculation
                    // if (checkAllocation()) {
                    //     calculateAndFetchResults();
                    // }

                    if (checkAllocation()) {
                        calculateAndFetchResults();
                        createVolumeChart();
                        // Update correlation matrix if correlation tab is active
                        if (document.querySelector('#correlation').classList.contains('active')) {
                            createCorrelationMatrix();
                        }
                    }
                });
            });
        }

        // Function to calculate start date based on period
        function calculateStartDate(period) {
            const endDate = new Date(selectedEndDate);
            const startDate = new Date(endDate);
            
            switch (period) {
                case '1M':
                    startDate.setMonth(endDate.getMonth() - 1);
                    break;
                case '6M':
                    startDate.setMonth(endDate.getMonth() - 6);
                    break;
                case '1Y':
                    startDate.setFullYear(endDate.getFullYear() - 1);
                    break;
                default:
                    startDate = new Date(minDate);
            }
            
            // Ensure the start date is not earlier than the minimum available date
            if (startDate < minDate) {
                startDate = new Date(minDate);
            }
            
            return startDate;
        }

        // Function to update the date range display
        function updateDateRangeDisplay() {
            const dateDisplay = document.getElementById('date-range-display');
            dateDisplay.textContent = `From ${formatDate(selectedStartDate)} to ${formatDate(selectedEndDate)}`;
            dateDisplay.style.display = 'none';
        }

        // Function to initialize allocation sliders [SPY, BND, VTIP, VXUS] [UPRO, QQQ, IWF, ARKK]
        function initializeAllocationSliders() {
            const uproSlider = document.getElementById('upro-allocation');
            const qqqSlider = document.getElementById('qqq-allocation');
            const iwfSlider = document.getElementById('iwf-allocation');
            const arkkSlider = document.getElementById('arkk-allocation');
            
            const uproValue = document.getElementById('upro-value');
            const qqqValue = document.getElementById('qqq-value');
            const iwfValue = document.getElementById('iwf-value');
            const arkkValue = document.getElementById('arkk-value');
            
            uproSlider.addEventListener('input', function() {
                uproValue.textContent = `${uproSlider.value}%`;
                checkAllocation();
            });
            
            qqqSlider.addEventListener('input', function() {
                qqqValue.textContent = `${qqqSlider.value}%`;
                checkAllocation();
            });
            
            iwfSlider.addEventListener('input', function() {
                iwfValue.textContent = `${iwfSlider.value}%`;
                checkAllocation();
            });
            
            arkkSlider.addEventListener('input', function() {
                arkkValue.textContent = `${arkkSlider.value}%`;
                checkAllocation();
            });
        }
        
        // Function to check if allocations sum to 100%
        function checkAllocation() {
            const uproValue = parseInt(document.getElementById('upro-allocation').value);
            const qqqValue = parseInt(document.getElementById('qqq-allocation').value);
            const iwfValue = parseInt(document.getElementById('iwf-allocation').value);
            const arkkValue = parseInt(document.getElementById('arkk-allocation').value);
            
            const total = uproValue + qqqValue + iwfValue + arkkValue;
            const warningEl = document.getElementById('allocation-warning');
            
            if (total !== 100) {
                warningEl.textContent = `Total allocation: ${total}% (should be 100%)`;
                return false;
            } else {
                warningEl.textContent = '';
                return true;
            }
        }
        
        // Function to initialize tabs
        function initializeTabs() {
            const tabs = document.querySelectorAll('.tab');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    
                    // Remove active class from all tabs and tab content
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    this.classList.add('active');
                    document.getElementById(tabId).classList.add('active');
                    
                    // Re-render charts when tab becomes visible to fix layout issues
                    setTimeout(() => {
                        if (tabId === 'candlestick' && candlestickData) {
                            createCandlestickChart();
                        } else if (tabId === 'company-weightage' && companyWeightageData) {
                            createCompanyWeightageChart(companyWeightageData);
                        } else if (tabId === 'industry-weightage') {
                            createIndustryWeightageChart();
                        } else if (tabId === 'volume') {
                            createVolumeChart();
                        //} else if (tabId === 'correlation' && correlationData) {
                        //    createCorrelationMatrix(correlationData);
                        } else if (tabId === 'correlation') {
                        createCorrelationMatrix(); // Remove correlationData parameter
                        } else if (tabId === 'drawdown' && drawdownData) {
                            createDrawdownChart(drawdownData);
                        }
                    }, 50);
                });
            });
        }

        // Helper function to get current allocations
        function getCurrentAllocations() {
            return {
                'UPRO': parseInt(document.getElementById('upro-allocation').value),
                'QQQ': parseInt(document.getElementById('qqq-allocation').value),
                'IWF': parseInt(document.getElementById('iwf-allocation').value),
                'ARKK': parseInt(document.getElementById('arkk-allocation').value)
            };
        }
        
        // Function to calculate and fetch results from API
        function calculateAndFetchResults() {
            // Check if allocations are valid
            if (!checkAllocation()) {
                alert('Total allocation must be 100%. Please adjust your allocations.');
                return;
            }
            
            // Get input values
            const initialInvestment = parseFloat(document.getElementById('initial-investment').value * 0.75);
            const uproAllocation = parseInt(document.getElementById('upro-allocation').value);
            const qqqAllocation = parseInt(document.getElementById('qqq-allocation').value);
            const iwfAllocation = parseInt(document.getElementById('iwf-allocation').value);
            const arkkAllocation = parseInt(document.getElementById('arkk-allocation').value);
            
            // Use the selected date range
            const startDate = formatDateForAPI(selectedStartDate);
            const endDate = formatDateForAPI(selectedEndDate);
            
            // Prepare API request payload
            const payload = {
                initial_investment: initialInvestment,
                allocations: {
                    'UPRO': uproAllocation,
                    'QQQ': qqqAllocation,
                    'IWF': iwfAllocation,
                    'ARKK': arkkAllocation
                },
                start_date: startDate,
                end_date: endDate
            };
            
            // Show loading state
            document.querySelectorAll('.loading').forEach(el => {
                el.style.display = 'block';
            });
            
            // Clear any previous error messages
            hideApiError();
            
            // Fetch all data at once
            fetchAllData(payload);
        }

        // Helper function to format dates for API (YYYY-MM-DD)
        function formatDateForAPI(date) {
            if (!date) return null;
            
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            
            return `${year}-${month}-${day}`;
        }
        
        // Function to fetch all data from the API
        function fetchAllData(payload) {
            // Use the calculate-all endpoint
            fetch(API_CALCULATE_ALL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        try {
                            const err = JSON.parse(text);
                            throw new Error(err.error || `HTTP error! Status: ${response.status}`);
                        } catch(e) {
                            throw new Error(`HTTP error! Status: ${response.status}, Body: ${text.substring(0, 100)}...`);
                        }
                    });
                }
                return response.text().then(text => {
                    // Replace NaN with null in the response to handle JSON parsing issues
                    const cleanedText = text.replace(/NaN/g, 'null');
                    return JSON.parse(cleanedText);
                });
            })
            .then(data => {
                // Store the data
                const metrics = data.metrics;
                portfolioData = data.portfolio_data;
                etfPerformance = data.etf_performance;
                yearlyReturns = data.yearly_returns;
                candlestickData = data.candlestick_data || [];
                companyWeightageData = data.company_weightage || [];
                industryWeightageData = data.industry_weightage || [];
                volumeData = data.volume_data || [];
                //correlationData = data.correlation_data || [];
                drawdownData = data.drawdown_data || portfolioData; // Use portfolio data if no specific drawdown data
                
                console.log("Data received:", {
                    portfolioDataPoints: portfolioData?.length || 0,
                    etfPerformanceEntries: Object.keys(etfPerformance || {}).length,
                    yearlyReturnsPoints: yearlyReturns?.length || 0,
                    candlestickDataPoints: candlestickData?.length || 0,
                    companyWeightage: Object.keys(companyWeightageData || {}).length,
                    industryWeightage: Object.keys(industryWeightageData || {}).length
                });
                
                // Update metrics display
                updateMetricsDisplay(metrics, payload.initial_investment);
                
                // Create charts
                createCandlestickChart();
                createCompanyWeightageChart();
                createIndustryWeightageChart();
                createVolumeChart(volumeData);
                createCorrelationMatrix(portfolioData);
                createCorrelationMatrix();
                createDrawdownChart(drawdownData);
                
                // Hide loading indicators
                document.querySelectorAll('.loading').forEach(el => {
                    el.style.display = 'none';
                });
            })
            .catch(error => {
                showApiError(`Failed to fetch portfolio data: ${error.message}`);
                
                // Hide loading indicators
                document.querySelectorAll('.loading').forEach(el => {
                    el.style.display = 'none';
                });
            });
        }

        // Function to update metrics display
        function updateMetricsDisplay(metrics, initialInvestment) {
            document.getElementById('final-value').textContent = formatCurrency(metrics.final_value);
            document.getElementById('initial-value').textContent = `Initial: ${formatCurrency(initialInvestment)}`;
            document.getElementById('total-return').textContent = formatPercentage(metrics.total_return);
            document.getElementById('annualized-return').textContent = `Annualized: ${formatPercentage(metrics.annualized_return)} per year`;
            document.getElementById('max-drawdown').textContent = formatPercentage(metrics.max_drawdown);
            document.getElementById('volatility').textContent = `${metrics.risk_level} (${formatPercentage(metrics.volatility)})`;
        }

        // Xy

        //Logics needed:
        //- if if else (1 month, 6 months, 1 yr), for 1 yr and 6 months split into each month
        // and extract the relevant data dates based on the time period defined
        // logic to check if open is higher than close the open will the line higher than close, if close price is higher than open vice versa when plotting candlestick
// Function to create candlestick chart
function createCandlestickChart() {
    const chartContainer = document.getElementById('candlestick-chart');
    if (!chartContainer) {
        console.error('Candlestick chart container not found');
        return;
    }
    
    // Show loading message
    chartContainer.innerHTML = '<div class="loading">Loading candlestick data...</div>';
    
    // Get the allocation weights
    const allocations = {
        'UPRO': parseInt(document.getElementById('upro-allocation').value) / 100,
        'QQQ': parseInt(document.getElementById('qqq-allocation').value) / 100,
        'IWF': parseInt(document.getElementById('iwf-allocation').value) / 100,
        'ARKK': parseInt(document.getElementById('arkk-allocation').value) / 100
    };
    
    // Get initial investment
    const initialInvestment = parseFloat(document.getElementById('initial-investment').value);
    
    // Format dates for API
    const startDate = formatDateForAPI(selectedStartDate);
    const endDate = formatDateForAPI(selectedEndDate);
    
    console.log(`Creating portfolio candlestick chart from ${startDate} to ${endDate}`);
    console.log(`Portfolio allocations:`, allocations);
    console.log(`Initial investment: $${initialInvestment}`);
    
    // Request portfolio data directly from the candlestick-data endpoint
    fetch('http://localhost:5007/candlestick-data', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            ticker: 'portfolio',
            tickers: allocations,
            initial_investment: initialInvestment,
            start_date: startDate,
            end_date: endDate
        })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                console.log("API Error Response:", err);
                throw new Error(err.error || `Server responded with status ${response.status}`);
            }).catch(e => {
                if (e.message && e.message.includes('JSON')) {
                    throw new Error(`Server responded with status ${response.status}`);
                }
                throw e;
            });
        }
        return response.json();
    })
    .then(data => {
        console.log(`Received portfolio data with ${data.candlestick_data?.length || 0} data points`);
        
        if (!data.candlestick_data || data.candlestick_data.length === 0) {
            chartContainer.innerHTML = '<div class="error">No portfolio data available for the selected date range</div>';
            return;
        }
        
        // Process portfolio data for candlestick chart
        const candlestickData = data.candlestick_data;
        
        // Clear container
        chartContainer.innerHTML = '';
        
        // Check container width
        const containerWidth = chartContainer.clientWidth;
        if (containerWidth <= 0) {
            setTimeout(() => createCandlestickChart(), 100);
            return;
        }
        
        // Convert string dates to Date objects for D3
        const processedData = candlestickData.map(d => ({
            Date: new Date(d.date),
            Open: d.open,
            High: d.high,
            Low: d.low,
            Close: d.close
        }));
        
        // Sort data by date
        processedData.sort((a, b) => a.Date - b.Date);
        
        console.log(`Processed ${processedData.length} portfolio data points for candlestick chart`);
        
        // Set up chart dimensions
        const margin = containerWidth < 400
            ? { top: 30, right: 30, bottom: 70, left: 50 }
            : { top: 30, right: 50, bottom: 70, left: 80 };
        
        const width = Math.max(containerWidth - margin.left - margin.right, 100);
        const height = 500 - margin.top - margin.bottom;
        
        const svg = d3.select(chartContainer)
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // Add title
        svg.append('text')
            .attr('x', width / 2)
            .attr('y', -margin.top / 2)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .style('font-weight', 'bold');
        
        // Create x-scale - use scaleBand for candlesticks
        const x = d3.scaleBand()
            .domain(processedData.map(d => d.Date))
            .range([0, width])
            .padding(0.2);
        
        // Calculate y-domain with some padding
        const minPrice = d3.min(processedData, d => d.Low);
        const maxPrice = d3.max(processedData, d => d.High);
        const yDomainPadding = (maxPrice - minPrice) * 0.05;
        
        // Y scale
        const y = d3.scaleLinear()
            .domain([minPrice - yDomainPadding, maxPrice + yDomainPadding])
            .range([height, 0]);
        
        // Create date formatter based on range
        const firstDate = processedData[0].Date;
        const lastDate = processedData[processedData.length - 1].Date;
        const daysInRange = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
        let tickFormat;
        
        if (daysInRange > 365) {
            tickFormat = d3.timeFormat('%b %Y'); // Month Year for ranges > 1 year
        } else if (daysInRange > 60) {
            tickFormat = d3.timeFormat('%b %d'); // Month Day for ranges > 60 days
        } else {
            tickFormat = d3.timeFormat('%b %d'); // Month Day for smaller ranges
        }
        
        // X axis - adjust tick count based on number of data points
        // For 1 month we want to show more ticks
        const tickValues = x.domain().filter((d, i, arr) => {
            // For 1-month view (less than 30 days and more than 10 data points)
            if (daysInRange <= 32 && arr.length <= 30) {
                // Show every 2-3 days depending on how many data points we have
                const step = arr.length <= 15 ? 1 : (arr.length <= 22 ? 2 : 3);
                return i % step === 0;
            } else {
                // For longer periods use more sparse ticks
                const step = Math.ceil(arr.length / (containerWidth < 600 ? 6 : 12));
                return i % step === 0;
            }
        });
        
        svg.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x)
                .tickFormat(tickFormat)
                .tickValues(tickValues)
            )
            .selectAll('text')
            .attr('transform', 'rotate(-45)')
            .style('text-anchor', 'end');
        
        // Y axis
        svg.append('g')
            .call(d3.axisLeft(y).tickFormat(d => '$' + d.toFixed(2)));
        
        // Draw candlesticks
        // 1. Vertical lines (High to Low)
        svg.selectAll('.candlestick-line')
            .data(processedData)
            .enter()
            .append('line')
            .attr('class', 'candlestick-line')
            .attr('x1', d => x(d.Date) + x.bandwidth() / 2)
            .attr('x2', d => x(d.Date) + x.bandwidth() / 2)
            .attr('y1', d => y(d.High))
            .attr('y2', d => y(d.Low))
            .attr('stroke', 'black')
            .attr('stroke-width', 1);
        
        // 2. Candlestick bodies - ensure positive width/height
        svg.selectAll('.candlestick-body')
            .data(processedData)
            .enter()
            .append('rect')
            .attr('class', 'candlestick-body')
            .attr('x', d => x(d.Date))
            .attr('width', () => Math.max(x.bandwidth(), 1)) // Ensure positive width
            .attr('y', d => y(Math.max(d.Open, d.Close)))
            .attr('height', d => {
                return Math.max(Math.abs(y(d.Open) - y(d.Close)), 1);
            })
            .attr('fill', d => d.Open > d.Close ? '#ff3333' : '#33cc33') // Red for bearish, green for bullish
            .attr('stroke', 'black')
            .attr('stroke-width', 1);
        
        // Add tooltip
        const tooltip = d3.select('#tooltip');
        
        // Add hover effects
        svg.selectAll('.candlestick-body')
            .on('mouseover', function(event, d) {
                d3.select(this).attr('stroke-width', 2);
                tooltip.transition()
                    .duration(200)
                    .style('opacity', .9);
                
                // Format date with day of week
                const formattedDate = d.Date.toLocaleDateString(undefined, { 
                    weekday: 'short', 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric' 
                });
                
                // Calculate daily change
                const changePercent = ((d.Close - d.Open) / d.Open * 100).toFixed(2);
                const changeColor = d.Close >= d.Open ? 'green' : 'red';
                
                tooltip.html(`
                    <strong>Date:</strong> ${formattedDate}<br>
                    <strong>Open:</strong> $${d.Open.toFixed(2)}<br>
                    <strong>Close:</strong> $${d.Close.toFixed(2)}<br>
                    <strong>High:</strong> $${d.High.toFixed(2)}<br>
                    <strong>Low:</strong> $${d.Low.toFixed(2)}<br>
                    <strong>Change:</strong> <span style="color:${changeColor}">${changePercent}%</span>
                `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
            })
            .on('mouseout', function() {
                d3.select(this).attr('stroke-width', 1);
                tooltip.transition()
                    .duration(500)
                    .style('opacity', 0);
            });
    })
    .catch(error => {
        chartContainer.innerHTML = `<div class="error">Error: ${error.message}</div>`;
        console.error('Error fetching portfolio data:', error);
    });
}

        // Xy

        // Function to create company weightage chart
        function createCompanyWeightageChart() {
            // Ensure the chart container is cleared
            const chartContainer = document.getElementById('company-weightage-chart');
            chartContainer.innerHTML = ''; // Clear previous chart

            // Get current allocations
            const allocations = {
                'UPRO': parseInt(document.getElementById('upro-allocation').value) / 100,
                'QQQ': parseInt(document.getElementById('qqq-allocation').value) / 100,
                'IWF': parseInt(document.getElementById('iwf-allocation').value) / 100,
                'ARKK': parseInt(document.getElementById('arkk-allocation').value) / 100
            };
        
            // Fetch company weightage data from dedicated microservice
            fetch('http://localhost:5004/portfolio-company-weightage', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    tickers: {
                        'UPRO': allocations['UPRO'] * 100,
                        'QQQ': allocations['QQQ'] * 100,
                        'IWF': allocations['IWF'] * 100,
                        'ARKK': allocations['ARKK'] * 100
                    }
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to fetch company weightage data');
                }
                return response.json();
            })
            .then(data => {
                const companyData = data.portfolio_company_allocation || [];
            
                // Merge duplicate companies by summing their weights
                const mergedData = [];
                const companyMap = new Map();
            
                companyData.forEach(d => {
                    const companyName = d.Company;

                    // Check if the company name contains "U.S. Treasury" and merge them
                    if (companyName.includes('U.S. Treasury')) {
                        if (companyMap.has('U.S. Treasury Note')) {
                            companyMap.set('U.S. Treasury Note', companyMap.get('U.S. Treasury Note') + d.Weight);
                        } else {
                            companyMap.set('U.S. Treasury Note', d.Weight);
                        }
                    } else {
                        if (companyMap.has(companyName)) {
                            companyMap.set(companyName, companyMap.get(companyName) + d.Weight);
                        } else {
                            companyMap.set(companyName, d.Weight);
                        }
                    }
                });
            
                // Convert map to an array for D3 processing
                companyMap.forEach((weight, company) => {
                    mergedData.push({ Company: company, Weight: weight });
                });
            
                // Sort by weight in descending order
                mergedData.sort((a, b) => b.Weight - a.Weight);
            
                // Dimensions
                const width = chartContainer.clientWidth;
                const height = 500;
            
                // Create SVG
                const svg = d3.select(chartContainer)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);
            
                // Set a minimum light shade for the least significant value
                const minColor = "#b5d4e9"; // Light blue (can adjust to your desired light shade)
            
                // Color scale: Invert the color scale so the highest weight is the darkest
                const color = d3.scaleSequential(d3.interpolateBlues)
                    .domain([mergedData.length, 0]); // Inverted color scale (largest value is darkest)
            
                // Treemap layout
                const treemap = d3.treemap()
                    .size([width, height])
                    .padding(1)
                    .round(true);
            
                // Prepare hierarchical data
                const root = d3.hierarchy({
                    name: 'Portfolio',
                    children: mergedData.map(d => ({
                        name: d.Company,
                        value: d.Weight
                    }))
                }).sum(d => d.value);
            
                // Generate treemap
                treemap(root);
            
                // Create rectangles for each company
                const cell = svg.selectAll('g')
                    .data(root.leaves())
                    .enter().append('g')
                    .attr('transform', d => `translate(${d.x0},${d.y0})`);
            
                cell.append('rect')
                    .attr('width', d => d.x1 - d.x0)
                    .attr('height', d => d.y1 - d.y0)
                    .attr('fill', (d, i) => {
                        // Apply the minimum light shade for companies with weight below a threshold
                        return d.data.value < 0.001 ? minColor : color(i); // Use minColor for values below 1%
                    })
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
                
                // Add text labels for company names (truncate if too long)
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 15)
                    .text(d => {
                        const maxLength = 20;
                        const name = d.data.name;
                        return name.length > maxLength
                            ? name.substring(0, maxLength) + '...'
                            : name;
                    })
                    .attr('font-size', '12px')
                    .attr('fill', 'white')
                    .attr('font-weight', 'bold');
                
                // Add percentage labels for weight
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 30)
                    .text(d => `${d.data.value.toFixed(1)}%`)
                    .attr('font-size', '10px')
                    .attr('fill', 'white');
                
                // Create a tooltip for hover interactions
                const tooltip = d3.select('#tooltip');
                cell.on('mouseover', function(event, d) {
                    tooltip.style('opacity', 1)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <strong>${d.data.name}</strong><br>
                            Weight: ${d.data.value.toFixed(2)}%
                        `);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
            })
            .catch(error => {
                console.error('Error fetching company weightage:', error);
                chartContainer.innerHTML = `<p>Error loading company weightage: ${error.message}</p>`;
            });
        }

        // // Function to create industry weightage chart
        // function createIndustryWeightageChart(data) {
        //     const chartContainer = document.getElementById('industry-weightage-chart');
        //     chartContainer.innerHTML = '';
            
        //     // YOUR CODE HERE: Implement industry weightage chart (e.g., treemap or pie chart) using D3.js
        //     // Use data parameter which should contain industry weightage information
            
        //     console.log("Creating industry weightage chart with data:", Object.keys(data || {}).length, "industries");
        // }

        function createIndustryWeightageChart() {
            // Check if allocations are valid
            if (!checkAllocation()) {
                const chartContainer = document.getElementById('industry-weightage');
                chartContainer.innerHTML = '<div class="error">Please ensure allocations sum to 100%</div>';
                return;
            }
        
            const chartContainer = document.getElementById('industry-weightage');
            chartContainer.innerHTML = ''; // Clear previous chart
        
            // Get current allocations
            const allocations = {
                'UPRO': parseInt(document.getElementById('upro-allocation').value) / 100,
                'QQQ': parseInt(document.getElementById('qqq-allocation').value) / 100,
                'IWF': parseInt(document.getElementById('iwf-allocation').value) / 100,
                'ARKK': parseInt(document.getElementById('arkk-allocation').value) / 100
            };

            // Fetch industry weightage data
            fetch('http://localhost:5006/portfolio-industry-weightage', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    tickers: {
                        'UPRO': allocations['UPRO'] * 100,  // Convert to percentage
                        'QQQ': allocations['QQQ'] * 100,
                        'IWF': allocations['IWF'] * 100,
                        'ARKK': allocations['ARKK'] * 100
                    }
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to fetch industry weightage data');
                }
                return response.json();
            })
            .then(data => {
                const industryData = data.portfolio_industry_allocation || [];
                
                // Sort the data by weight in descending order
                industryData.sort((a, b) => b.Weight - a.Weight);
            
                // Dimensions for the tree map
                const width = chartContainer.clientWidth;
                const height = 500;
                
                // Create SVG
                const svg = d3.select(chartContainer)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .append('g');
            
                // Set color scale for the tree map
                const color = d3.scaleSequential(d3.interpolateBlues)
                    .domain([industryData.length, 0]);
            
                // Create treemap layout
                const treemap = d3.treemap()
                    .size([width, height])
                    .padding(1)
                    .round(true);
            
                // Prepare hierarchical data for D3 processing
                const root = d3.hierarchy({
                    name: 'Portfolio',
                    children: industryData.map(d => ({
                        name: d.Industry,
                        value: d.Weight
                    }))
                }).sum(d => d.value);
            
                // Generate treemap layout
                treemap(root);
            
                // Create rectangles for each industry in the treemap
                const cell = svg.selectAll('g')
                    .data(root.leaves())
                    .enter().append('g')
                    .attr('transform', d => `translate(${d.x0},${d.y0})`);
            
                cell.append('rect')
                    .attr('width', d => d.x1 - d.x0)
                    .attr('height', d => d.y1 - d.y0)
                    .attr('fill', (d, i) => color(i)) // Color by index
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
            
                // Add text labels for industry names (truncate if too long)
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 15)
                    .text(d => {
                        const maxLength = 20;
                        const name = d.data.name;
                        return name.length > maxLength
                            ? name.substring(0, maxLength) + '...'
                            : name;
                    })
                    .attr('font-size', '12px')
                    .attr('fill', 'white')
                    .attr('font-weight', 'bold');
                
                // Add percentage labels for weight
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 30)
                    .text(d => `${d.data.value.toFixed(1)}%`)
                    .attr('font-size', '10px')
                    .attr('fill', 'white');
                
                // Create a tooltip for hover interactions
                const tooltip = d3.select('#tooltip');
                cell.on('mouseover', function (event, d) {
                    tooltip.style('opacity', 1)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <strong>${d.data.name}</strong><br>
                            Weight: ${d.data.value.toFixed(2)}%
                        `);
                })
                .on('mouseout', function () {
                    tooltip.style('opacity', 0);
                });
            })
            .catch(error => {
                console.error('Error fetching industry weightage:', error);
                chartContainer.innerHTML = `<p>Error loading industry weightage: ${error.message}</p>`;
            });
        }

        // Function to update volume chart based on allocations - alled when "Calculate Returns" button is clicked
        function updateVolumeChart() {
            // Check if allocations are valid
            if (!checkAllocation()) {
                alert('Total allocation must be 100%. Please adjust your allocations.');
                return;
            }

            // Get input values
            const initialInvestment = parseFloat(document.getElementById('initial-investment').value * 0.75);
            const uproAllocation = parseInt(document.getElementById('upro-allocation').value);
            const qqqAllocation = parseInt(document.getElementById('qqq-allocation').value);
            const iwfAllocation = parseInt(document.getElementById('iwf-allocation').value);
            const arkkAllocation = parseInt(document.getElementById('arkk-allocation').value);
            
            createVolumeChart();
        }

        // Function to create volume chart
        function createVolumeChart() {
            const chartContainer = document.getElementById('volume-chart');
            chartContainer.innerHTML = ''; // Clear previous chart

            // Get current allocations
            const allocations = {
                'UPRO': parseInt(document.getElementById('upro-allocation').value) / 100,
                'QQQ': parseInt(document.getElementById('qqq-allocation').value) / 100,
                'IWF': parseInt(document.getElementById('iwf-allocation').value) / 100,
                'ARKK': parseInt(document.getElementById('arkk-allocation').value) / 100
            };

            console.log(allocations);
            
            // Get the selected date range
            const startDate = formatDateForAPI(selectedStartDate);
            const endDate = formatDateForAPI(selectedEndDate);

            // Fetch volume data from dedicated microservice
            fetch('http://localhost:5008/api/volume-analysis', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    start_date: startDate,
                    end_date: endDate,
                    allocations: {
                        'UPRO': allocations['UPRO'],
                        'QQQ': allocations['QQQ'],
                        'IWF': allocations['IWF'],
                        'ARKK': allocations['ARKK']
                    },
                    tickers: ['ARKK', 'IWF', 'QQQ', 'UPRO']
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to fetch volume data');
                }
                return response.json();
            })
            .then(data => {
                const etfVolume = data.volume; // {dates: [date1, date2], volumes: [combinedvol1, combinedvol2]}
                const allocations = data.allocations || {};
                console.log("Volume data received::", etfVolume);
                console.log("Etf allocations received:", allocations);
                console.log("Volume data received:", etfVolume);

                // Set up chart dimensions
                const width = chartContainer.clientWidth;
                const height = 400;
                const margin = { top: 20, right: 30, bottom: 50, left: 60 };

                // Create SVG
                const svg = d3.select(chartContainer)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                // Convert dates to Date objects
                const volumeData = etfVolume.dates.map((date, i) => ({
                    date: new Date(date),
                    volume: etfVolume.volumes[i]
                }));

                // Calculate time difference in months
                const timeSpan = (selectedEndDate - selectedStartDate) / (1000 * 60 * 60 * 24 * 30);

                // Create x-axis scale and format based on time period
                const x = d3.scaleTime()
                    .domain(d3.extent(volumeData, d => d.date))
                    .range([margin.left, width - margin.right]);

                let xAxis;
                if (timeSpan <= 1) {
                    // For 1 month, show dates
                    xAxis = d3.axisBottom(x)
                        .ticks(d3.timeDay.every(2))
                        .tickFormat(d3.timeFormat("%d %b"));
                } else {
                    // For 6 months or 1 year, show months
                    xAxis = d3.axisBottom(x)
                        .ticks(d3.timeMonth.every(1))
                        .tickFormat(d3.timeFormat("%b %Y"));
                }

                // Create y scale
                const y = d3.scaleLinear()
                    .domain([0, d3.max(volumeData, d => d.volume)])
                    .range([height - margin.bottom, margin.top]);

                // Create line generator
                const line = d3.line()
                    .x(d => x(d.date))
                    .y(d => y(d.volume));

                // Add line path
                svg.append('path')
                    .datum(volumeData)
                    .attr('fill', 'none')
                    .attr('stroke', 'steelblue')
                    .attr('stroke-width', 1.5)
                    .attr('d', line);

                // Add X axis
                svg.append('g')
                    .attr('transform', `translate(0,${height - margin.bottom})`)
                    .call(xAxis)
                    .selectAll('text')
                    .style('text-anchor', 'end')
                    .attr('dx', '-.8em')
                    .attr('dy', '.15em')
                    .attr('transform', 'rotate(-45)');

                // Add Y axis
                svg.append('g')
                    .attr('transform', `translate(${margin.left},0)`)
                    .call(d3.axisLeft(y)
                        .tickFormat(d3.format(".2s"))); // Use SI prefix format for large numbers

                // Add labels
                svg.append('text')
                    .attr('x', width / 2)
                    .attr('y', height - 10)
                    .attr('text-anchor', 'middle')
                    .text('Date');

                svg.append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', margin.left - 40)
                    .attr('x', -(height / 2))
                    .attr('text-anchor', 'middle')
                    .text('Volume');

                const area = d3.area()
                    .x(d => x(d.date))
                    .y0(height - margin.bottom) 
                    .y1(d => y(d.volume)); 

                svg.append('path')
                    .datum(volumeData)
                    .attr('fill', 'lightblue')
                    .attr('opacity', 0.5)
                    .attr('d', area);

                // Add tooltip
                const tooltip = d3.select('#tooltip');
                const bisect = d3.bisector(d => d.date).left;

                // Add tooltip vertical line and dot
                const tooltipLine = svg.append("line")
                    .attr("stroke", "#666")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "3,3")
                    .attr("y1", 0)
                    .attr("y2", height - margin.bottom)
                    .style("opacity", 0);

                const tooltipDot = svg.append("circle")
                    .attr("r", 5)
                    .attr("fill", "steelblue")
                    .attr("stroke", "white")
                    .attr("stroke-width", 2)
                    .style("opacity", 0);

                // Add transparent overlay for mouse interaction
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height - margin.bottom)
                    .style('fill', 'none')
                    .style('pointer-events', 'all')
                    .on('mouseover', function() {
                        tooltip.style('opacity', 1);
                        tooltipLine.style('opacity', 1);
                        tooltipDot.style('opacity', 1);
                    })
                    .on('mouseout', function() {
                        tooltip.style('opacity', 0);
                        tooltipLine.style('opacity', 0);
                        tooltipDot.style('opacity', 0);
                    })
                    .on('mousemove', function(event) {
                        const mouseX = d3.pointer(event)[0];
                        const x0 = x.invert(mouseX);
                        const i = bisect(volumeData, x0, 1);
                        
                        if (i >= volumeData.length) return;
                        
                        const d = volumeData[i];
                        const prevDay = i > 0 ? volumeData[i - 1] : volumeData[i];  // Get previous day's data
                        
                        // Update tooltip line position
                        tooltipLine
                            .attr("x1", x(d.date))
                            .attr("x2", x(d.date));
                            
                        // Update tooltip dot position
                        tooltipDot
                            .attr("cx", x(d.date))
                            .attr("cy", y(d.volume));
                        
                        // Calculate volume change from previous day
                        const volumeChange = d.volume - prevDay.volume;
                        const percentChange = (volumeChange / prevDay.volume);
                        
                        
                        // Format tooltip content
                        tooltip.style('left', (event.pageX + 15) + 'px')
                            .style('top', (event.pageY - 28) + 'px')
                            .html(`
                                <div style="font-weight: bold; margin-bottom: 5px;">
                                    ${formatDate(d.date)}
                                </div>
                                <div>
                                    <strong>Current Volume:</strong> ${d3.format(",")(Math.round(d.volume))}
                                </div>
                                <div style="color: ${volumeChange >= 0 ? '#28a745' : '#dc3545'}">
                                    <strong>Volume Change:</strong> ${d3.format(",")(Math.round(volumeChange))}
                                    (${volumeChange >= 0 ? '' : ''})
                                </div>
                                <div>
                                    <strong>% Change:</strong> 
                                    ${d3.format('.2%')(percentChange)}
                                </div>
                            `);
                    });
            })
        }


        function createCorrelationMatrix() {
            console.log("Starting correlation matrix creation...");
            const chartContainer = document.getElementById('correlation-chart');
            if (!chartContainer) {
                console.error("Correlation chart container not found");
                return;
            }
        
            // Show loading state
            chartContainer.innerHTML = '<div class="loading">Loading correlation data...</div>';
        
            // Check if we have valid selected dates from time period buttons
            if (!selectedStartDate || !selectedEndDate) {
                console.error("No date range selected");
                chartContainer.innerHTML = '<div class="error">Please select a date range first</div>';
                return;
            }
        
            // Log the selected date range for debugging
            console.log("Selected date range for correlation:", {
                start: formatDate(selectedStartDate),
                end: formatDate(selectedEndDate)
            });
        
            // Fetch data from API
            fetch('http://localhost:5009/api/get-close-price', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    start_date: formatDateForAPI(selectedStartDate),
                    end_date: formatDateForAPI(selectedEndDate),
                    tickers: ['ARKK', 'IWF', 'QQQ', 'UPRO']
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("API response:", data);

                // Check if the response contains the correlation matrix
                if (data.correlation_matrix) {
                    // Use the server-calculated correlation matrix
                    const etfs = ['ARKK', 'IWF', 'QQQ', 'UPRO'];
                    createCorrelationVisualization(data.correlation_matrix, etfs, chartContainer);
                } else {
                    throw new Error("API response doesn't contain correlation matrix");
                }
            })
            .catch(error => {
                console.error("Error fetching correlation data:", error);
                chartContainer.innerHTML = `<div class="error">Error loading correlation data: ${error.message}</div>`;
            });
        }

        function createCorrelationVisualization(matrix, etfs, container) {
            // Clear container
            container.innerHTML = '';

            // Set up dimensions
            const margin = { top: 50, right: 50, bottom: 50, left: 50 };
            const width = Math.min(500, container.clientWidth - margin.left - margin.right);
            const height = width; // Square aspect ratio
            const cellSize = Math.floor(width / etfs.length);

            // Create SVG container
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Color scale for correlation values
            const color = d3.scaleLinear()
                .domain([-1, 0, 1])
                .range(['#e74c3c', '#f5f5f5', '#3498db']);

            // Create a group for each cell
            const cells = svg.selectAll('.cell-group')
                .data(matrix.flat())
                .enter()
                .append('g')
                .attr('class', 'cell-group')
                .attr('transform', d => `translate(${etfs.indexOf(d.target) * cellSize},${etfs.indexOf(d.source) * cellSize})`);

            // Add background rectangle for each cell
            cells.append('rect')
                .attr('class', 'correlation-cell')
                .attr('width', cellSize)
                .attr('height', cellSize)
                .attr('fill', d => {
                    // Use different color for diagonal cells (self-correlation)
                    if (d.source === d.target) {
                        return '#f0f0f0'; // Light gray for diagonal
                    }
                    return color(d.correlation);
                })
                .attr('stroke', 'white')
                .attr('stroke-width', 1);
            
            // Add text for correlation values
            cells.append('text')
                .attr('class', 'correlation-text')
                .attr('x', cellSize / 2)
                .attr('y', cellSize / 2)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .style('font-size', '12px')
                .style('font-weight', d => {
                    // Use normal weight for diagonal, bold for strong correlations
                    return d.source === d.target ? 'normal' : 
                          (Math.abs(d.correlation) > 0.7 ? 'bold' : 'normal');
                })
                .style('fill', d => {
                    // Gray for diagonal, white for dark backgrounds, black for light backgrounds
                    if (d.source === d.target) {
                        return '#999'; // Gray text for diagonal
                    }
                    return Math.abs(d.correlation) > 0.5 ? 'white' : 'black';
                })
                .text(d => d.correlation.toFixed(2));
            
            // Add invisible overlay rectangle for better hover interaction
            cells.append('rect')
                .attr('width', cellSize)
                .attr('height', cellSize)
                .attr('fill', 'transparent')
                .attr('class', 'cell-overlay')
                .on('mouseover', function(event, d) {
                    // Highlight cell on hover with uniform border
                    d3.select(this.parentNode)
                        .select('.correlation-cell')
                        .attr('stroke-width', 2);

                    // Show tooltip
                    d3.select('#tooltip')
                        .style('opacity', 1)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 20) + 'px')
                        .html(`
                            <strong>Correlation:</strong> ${d.correlation.toFixed(3)}<br>
                            <strong>ETFs:</strong> ${d.source} vs ${d.target}
                        `);
                })
                .on('mouseout', function() {
                    // Remove highlight
                    d3.select(this.parentNode)
                        .select('.correlation-cell')
                        .attr('stroke', 'white')
                        .attr('stroke-width', 1);

                    // Hide tooltip
                    d3.select('#tooltip').style('opacity', 0);
                });
            
            // Add ETF labels (x-axis)
            svg.selectAll('.x-label')
                .data(etfs)
                .enter()
                .append('text')
                .attr('class', 'x-label')
                .attr('x', (d, i) => i * cellSize + cellSize/2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text(d => d);
            
            // Add ETF labels (y-axis)
            svg.selectAll('.y-label')
                .data(etfs)
                .enter()
                .append('text')
                .attr('class', 'y-label')
                .attr('x', -10)
                .attr('y', (d, i) => i * cellSize + cellSize/2)
                .attr('text-anchor', 'end')
                .attr('dominant-baseline', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text(d => d);
            
            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', -30)
                .attr('text-anchor', 'middle')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .text('ETF Correlation Matrix');
        }

        // Function to create drawdown chart
        function createDrawdownChart(portfolioData) {
            const chartContainer = document.getElementById('drawdown-chart');
            chartContainer.innerHTML = '';
            
            // Check if we have data
            if (!portfolioData || portfolioData.length === 0) {
                chartContainer.innerHTML = '<div class="error">No data available for drawdown analysis</div>';
                return;
            }
            
            // Check container width first
            const containerWidth = chartContainer.clientWidth;
            
            if (containerWidth <= 0) {
                // Wait for the layout to stabilize (e.g., tab becoming visible)
                setTimeout(() => createDrawdownChart(portfolioData), 100);
                return;
            }
            
            // Use smaller margins if container is narrow
            const margin = containerWidth < 400 
                ? {top: 20, right: 30, bottom: 50, left: 40}
                : {top: 20, right: 80, bottom: 50, left: 80};
            
            const width = Math.max(containerWidth - margin.left - margin.right, 100); // Ensure minimum width
            const height = 400 - margin.top - margin.bottom;
            
            const svg = d3.select(chartContainer)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Make sure dates are Date objects and sort data chronologically
            portfolioData = portfolioData
                .map(d => ({
                    ...d,
                    Date: d.Date instanceof Date ? d.Date : new Date(d.Date),
                    // Ensure drawdown is numeric and within reasonable bounds
                    drawdown: typeof d.drawdown === 'number' && !isNaN(d.drawdown) ? 
                            Math.max(Math.min(d.drawdown, 0), -1) : 0,
                    total_value: typeof d.total_value === 'number' && !isNaN(d.total_value) ?
                                d.total_value : 0,
                    peak_value: typeof d.peak_value === 'number' && !isNaN(d.peak_value) ?
                                d.peak_value : 0
                }))
                .sort((a, b) => a.Date - b.Date);
            
            // If we have fewer than 2 data points after filtering, show error
            if (portfolioData.length < 2) {
                chartContainer.innerHTML = '<div class="error">Not enough valid data points for drawdown analysis</div>';
                return;
            }
            
            // Calculate domain for drawdown
            const minDrawdown = d3.min(portfolioData, d => d.drawdown);
            
            // X scale
            const x = d3.scaleTime()
                .domain(d3.extent(portfolioData, d => d.Date))
                .range([0, width]);
            
            // Y scale for drawdown (negative values)
            // Set a reasonable minimum (e.g., -0.1 for -10% if no drawdown)
            const yMin = Math.min(minDrawdown * 1.1 || -0.1, -0.1);
            
            const y = d3.scaleLinear()
                .domain([yMin, 0]) 
                .range([height, 0]);
            
            // X axis
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(width > 500 ? 10 : 5)
                    .tickFormat(d3.timeFormat('%b %Y')))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            // Y axis
            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y)
                    .tickFormat(d => `${d3.format('.0%')(d)}`));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -margin.left + 20) // Adjust based on margin
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Drawdown (%)')
                .style('fill', '#666');
            
            // Create the area generator for drawdown visualization
            const area = d3.area()
                .x(d => x(d.Date))
                .y0(d => y(d.drawdown))  // Bottom of the area is at the drawdown value
                .y1(y(0))                // Top of the area is at zero
                .defined(d => !isNaN(d.drawdown))
                .curve(d3.curveMonotoneX); // Add smooth curve
            
            // Draw the area in red (representing drawdown)
            svg.append('path')
                .datum(portfolioData)
                .attr('fill', 'rgba(255, 0, 0, 0.3)')
                .attr('d', area);
            
            // Draw the drawdown line
            const line = d3.line()
                .x(d => x(d.Date))
                .y(d => y(d.drawdown))
                .defined(d => !isNaN(d.drawdown))
                .curve(d3.curveMonotoneX); // Add smooth curve
            
            svg.append('path')
                .datum(portfolioData)
                .attr('fill', 'none')
                .attr('stroke', 'rgb(255, 0, 0)')
                .attr('stroke-width', 2)
                .attr('d', line);
            
            // Add a zero line
            svg.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', y(0))
                .attr('y2', y(0))
                .attr('stroke', '#888')
                .attr('stroke-dasharray', '3,3');
            
            // Add grid lines for better readability
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y)
                    .tickValues([-0.1, -0.2, -0.3, -0.4, -0.5]) // 10%, 20%, 30%, 40%, 50% drawdown lines
                    .tickSize(-width)
                    .tickFormat(''))
                .style('stroke', '#e0e0e0')
                .style('stroke-opacity', 0.7)
                .style('shape-rendering', 'crispEdges');
            
            // Add vertical grid lines
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(10)
                    .tickSize(-height)
                    .tickFormat(''))
                .style('stroke', '#e0e0e0')
                .style('stroke-opacity', 0.5)
                .style('shape-rendering', 'crispEdges');
            
            // Add tooltip elements
            const tooltip = d3.select('#tooltip');
            const bisect = d3.bisector(d => d.Date).left;
            
            // Add tooltip vertical line and dot
            const tooltipLine = svg.append("line")
                .attr("stroke", "#666")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3")
                .attr("y1", 0)
                .attr("y2", height)
                .style("opacity", 0);
                
            const tooltipDot = svg.append("circle")
                .attr("r", 5)
                .attr("fill", "rgb(255, 0, 0)")
                .attr("stroke", "white")
                .attr("stroke-width", 2)
                .style("opacity", 0);
            
            // Add transparent overlay for mouse interaction
            svg.append('rect')
                .attr('width', width > 0 ? width : 0) // Ensure width is not negative
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mouseover', function() {
                    tooltip.style('opacity', 1);
                    tooltipLine.style('opacity', 1);
                    tooltipDot.style('opacity', 1);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                    tooltipLine.style('opacity', 0);
                    tooltipDot.style('opacity', 0);
                })
                .on('mousemove', function(event) {
                    const mouseX = d3.pointer(event)[0];
                    const x0 = x.invert(mouseX);
                    const i = bisect(portfolioData, x0, 1);
                    
                    if (i >= portfolioData.length) return;
                    
                    const d0 = portfolioData[i - 1];
                    const d1 = portfolioData[i];
                    if (!d0 || !d1) return;
                    
                    const d = x0 - d0.Date > d1.Date - x0 ? d1 : d0;
                    
                    // Update tooltip line position
                    tooltipLine
                        .attr("x1", x(d.Date))
                        .attr("x2", x(d.Date));
                        
                    // Update tooltip dot position
                    tooltipDot
                        .attr("cx", x(d.Date))
                        .attr("cy", y(d.drawdown));
                    
                    // Format tooltip content
                    tooltip.style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <div style="font-weight: bold; margin-bottom: 5px;">${formatDate(d.Date)}</div>
                            <div style="color: ${d.drawdown < -0.1 ? '#dc3545' : '#6c757d'}">
                                <strong>Drawdown:</strong> ${d3.format('.2%')(d.drawdown)}
                            </div>
                            <div style="margin-top: 5px;">
                                <strong>Peak Value:</strong> ${formatCurrency(d.peak_value)}
                            </div>
                            <div>
                                <strong>Current Value:</strong> ${formatCurrency(d.total_value)}
                            </div>
                            <div>
                                <strong>Decline Amount:</strong> ${formatCurrency(d.total_value - d.peak_value)}
                            </div>
                        `);
                });
        }

        // Helper function to show API error
        function showApiError(message) {
            const errorEl = document.getElementById('api-error');
            const messageEl = document.getElementById('error-message');
            messageEl.textContent = message;
            errorEl.style.display = 'block';
        }

        // Helper function to hide API error
        function hideApiError() {
            const errorEl = document.getElementById('api-error');
            errorEl.style.display = 'none';
        }

        // Helper function to format currency
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value);
        }

        // Helper function to format percentage
        function formatPercentage(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'percent',
                minimumFractionDigits: 1,
                maximumFractionDigits: 1
            }).format(value);
        }

        // Helper function to format date
        function formatDate(date) {
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }
    </script>
</body>