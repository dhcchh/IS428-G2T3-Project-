<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Low Risk Short-Term Investment Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js" charset="utf-8"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .header h5 {
            margin-top: 0;
            color: #7f8c8d;
        }
        .dashboard {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .controls h3 {
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric-card {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
        }
        .metric-card h3 {
            margin: 10px 0;
            font-size: 1.8rem;
        }
        .metric-card p {
            margin: 0;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        .charts {
            display: grid;
            grid-template-rows: auto;
            gap: 20px;
        }
        .chart-container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .chart-container h3 {
            margin-top: 0;
            margin-bottom: 20px;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        input[type="range"] {
            width: 100%;
        }
        .allocation-display {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
        }
        button {
            width: 100%;
            padding: 10px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 20px;
        }
        button:hover {
            background-color: #2980b9;
        }
        .tab-container {
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .tab.active {
            border-bottom-color: #3498db;
            font-weight: 500;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .warning {
            color: #e74c3c;
            margin-top: 5px;
            font-size: 0.9rem;
        }
        .axis line, .axis path {
            stroke: #ddd;
        }
        .axis text {
            fill: #666;
            font-size: 0.8rem;
        }
        .notes {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        .notes h5 {
            margin-top: 0;
        }
        .notes ul {
            padding-left: 20px;
        }
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 2px;
        }
        .api-error {
            background-color: #fee;
            color: #e74c3c;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        /* CSS for the time period buttons */
        .time-period-buttons {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
        }

        .time-btn {
            flex: 1;
            padding: 8px 0;
            margin: 0 4px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            color: black;
        }

        .time-btn:first-child {
            margin-left: 0;
        }

        .time-btn:last-child {
            margin-right: 0;
        }

        .time-btn:hover {
            background-color: #e9ecef;
        }

        .time-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        .portfolio-line {
            stroke-width: 3px;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .spy-line {
            stroke-width: 2px;
            stroke-dasharray: 5, 5;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .outperformance-positive {
            color: #28a745;
            font-weight: bold;
        }

        .outperformance-negative {
            color: #dc3545;
            font-weight: bold;
        }

        .grid line {
            stroke: #e0e0e0;
            stroke-opacity: 0.7;
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }
        .loading:after {
            content: '...';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        .tooltip-trigger {
            position: relative;
            display: inline-flex;
            margin-left: 5px;
            cursor: help;
        }

        .tooltip-trigger .info-icon {
            width: 16px;
            height: 16px;
        }

        .tooltip-trigger:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 100%;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            width: 250px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            font-weight: normal;
            line-height: 1.4;
        }

        .tooltip-trigger:hover::before {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 100%;
            border: 8px solid transparent;
            border-top-color: #333;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Low Risk Short-Term Investment Dashboard</h1>
            <h5>Time in the Market Beats Timing the Market</h5>
        </div>
        
        <div id="api-error" class="api-error">
            <strong>Error connecting to API:</strong> <span id="error-message"></span>
        </div>
        
        <div class="dashboard">
            <div class="controls">
                <h3>Investment Parameters</h3>
                
        <!-- HTML for time period buttons -->
        <div class="control-group">
            <label>Investment Period:</label>
            <div class="time-period-buttons">
                <button class="time-btn" data-period="1M">1M</button>
                <button class="time-btn" data-period="6M">6M</button>
                <button class="time-btn" data-period="1Y">1Y</button>
            </div>
            <div id="date-range-display" style="text-align: center; margin-top: 10px; display: none;">Loading date range...</div>
        </div>
                
                <div class="control-group">
                    <label>Initial Investment (SGD):</label>
                    <input type="number" id="initial-investment" min="1000" max="1000000" step="1000" value="10000">
                    <small style="color: #7f8c8d;">Min: $1,000 - Max: $1,000,000</small>
                </div>
                
                <div class="control-group">
                    <label>Portfolio Allocation:</label>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>USMV</span>
                            <span id="usmv-value">25%</span>
                        </div>
                        <input type="range" id="usmv-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>VYM</span>
                            <span id="vym-value">25%</span>
                        </div>
                        <input type="range" id="vym-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>SPLV</span>
                            <span id="splv-value">25%</span>
                        </div>
                        <input type="range" id="splv-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>AGG</span>
                            <span id="agg-value">25%</span>
                        </div>
                        <input type="range" id="agg-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div id="allocation-warning" class="warning"></div>
                </div>
                
                <button id="calculate-button">Calculate Returns</button>
            </div>
            
            <div class="content">
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Final Portfolio Value</h4>
                        <h3 id="final-value">$0.00</h3>
                        <p id="initial-value">Initial: $0.00</p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>Total Return
                            <span class="tooltip-trigger" data-tooltip="The total growth rate of your investment">
                                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="total-return">0.0%</h3>
                        <p id="annualized-return">
                            Annualized: 0.0% per year
                        </p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>
                            Maximum Drawdown
                            <span class="tooltip-trigger" data-tooltip="The percentage drop from your investment's highest value to its lowest point during a specific period. Shows potential losses you might face before recovery.">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="max-drawdown">0.0%</h3>
                        <p>Largest decline from peak</p>
                    </div>
                    
                    <div class="metric-card" id="risk-card">
                        <h4>
                            Risk Level
                            <span class="tooltip-trigger" data-tooltip="Measures how dramatically an investment's price changes over time. Higher volatility means bigger price swings both up and down.">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="volatility">Low (0.0%)</h3>
                        <p>Portfolio volatility</p>
                    </div>   
                </div>
                
                <div class="tab-container">
                    <ul class="tabs">
                        <li class="tab active" data-tab="candlestick">Candlestick</li>
                        <li class="tab" data-tab="company">Company Weightage</li>
                        <li class="tab" data-tab="industry">Industry Weightage</li>
                        <li class="tab" data-tab="correlation">Correlation Matrix</li>
                        <li class="tab" data-tab="drawdown">Drawdown Analysis</li>
                    </ul>
                </div>
                
                <div class="charts">
                    <div id="candlestick" class="tab-content active">
                        <div class="chart-container">
                            <h3>Candlestick Chart</h3>
                            <div id="candlestick-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="growth-legend"></div>
                        </div>
                    </div>

                    <div id="company" class="tab-content">
                        <div class="chart-container">
                            <h3>Company Weightage</h3>
                            <div id="company-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>

                    <div id="industry" class="tab-content">
                        <div class="chart-container">
                            <h3>Industry Weightage</h3>
                            <div id="industry-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>

                    <div id="correlation" class="tab-content">
                        <div class="chart-container">
                            <h3>Correlation Matrix</h3>
                            <div id="correlation-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="drawdown" class="tab-content">
                        <div class="chart-container">
                            <h3>Portfolio Drawdown Analysis</h3>
                            <div id="drawdown-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <!-- Add a tooltip div -->
    <div id="tooltip" class="tooltip"></div>

    <script>
        // API URLs
        const API_BASE_URL = 'http://localhost:5003';
        const API_DATE_RANGE = `${API_BASE_URL}/api/date-range`;
        const API_PORTFOLIO_VALUE = `${API_BASE_URL}/api/portfolio-value`;
        const API_TOTAL_RETURN = `${API_BASE_URL}/api/total-return`;
        const API_MAX_DRAWDOWN = `${API_BASE_URL}/api/max-drawdown`;
        const API_RISK_LEVEL = `${API_BASE_URL}/api/risk-level`;
        const API_PORTFOLIO_GROWTH = `${API_BASE_URL}/api/portfolio-growth`;
        const API_DRAWDOWN_ANALYSIS = `${API_BASE_URL}/api/drawdown-analysis`;
        const API_ETF_COMPARISON = `${API_BASE_URL}/api/etf-comparison`;
        const API_YEARLY_RETURNS = `${API_BASE_URL}/api/yearly-returns`;
        const API_CALCULATE_ALL = `${API_BASE_URL}/api/calculate-all`;
        

        // Global variables
        let minDate, maxDate;
        let selectedStartDate, selectedEndDate;
        let candlestickData = null;
        let portfolioData = null;
        let drawdownData = null;
        let etfPerformance = null;
        let yearlyReturns = null;
        
        // Main application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize tooltips
            const tooltip = d3.select('#tooltip');
            
            // Initialize date range
            fetchDateRange();
            
            // Initialize allocation sliders
            initializeAllocationSliders();
            
            // Set up tabs
            initializeTabs();
            
            // Set up time period buttons
            initializeTimePeriodButtons();
            
            // Set up calculate button
            document.getElementById('calculate-button').addEventListener('click', function() {
                calculateAndFetchResults();
            });
            
            // Initial calculation will be triggered after date range is fetched
        });

        /////


        // Utility function to wait for elements to exist in the DOM
        function waitForElement(elementId, callback, checkFrequencyInMs, timeoutInMs) {
            var startTimeInMs = Date.now();
            var checkElementAndCallback = function() {
                var element = document.getElementById(elementId);
                if (element) {
                    console.log(elementId + " element found!");
                    callback(element);
                    return;
                }
                
                if (timeoutInMs && Date.now() - startTimeInMs > timeoutInMs) {
                    console.log(elementId + " element not found within timeout period");
                    return;
                }
                
                setTimeout(checkElementAndCallback, checkFrequencyInMs);
            };
            
            checkElementAndCallback();
        }

        // Helper function to find the parent metric card of an element
        function findParentCard(elementId) {
            const element = document.getElementById(elementId);
            if (!element) {
                console.log("Element with ID " + elementId + " not found");
                return null;
            }
            
            // Find parent metric card
            const parentCard = element.closest('.metric-card');
            if (parentCard) {
                console.log("Found parent card for " + elementId);
                return parentCard;
            } else {
                console.log("Could not find parent card for " + elementId);
                return null;
            }
        }

        // 1. RISK/VOLATILITY MONITORING
        function setupRiskMonitoring(volatilityElement) {
            console.log("Setting up risk/volatility monitoring");
            
            // Find the risk card element
            const riskCard = findParentCard('volatility');
            
            if (riskCard) {
                setupRiskObserver(volatilityElement, riskCard);
            } else {
                console.error("Could not find parent card for volatility");
            }
        }

        function setupRiskObserver(volatilityElement, cardElement) {
            function updateRiskCardColor() {
                const volatilityText = volatilityElement.innerText || volatilityElement.textContent;
                console.log("Volatility text:", volatilityText);
                
                if (volatilityText.includes('Very Low') || volatilityText.includes('Low')) {
                    cardElement.style.backgroundColor = 'rgba(40, 167, 69, 0.15)'; // light green
                    console.log("Set risk card to green");
                } else if (volatilityText.includes('High') || volatilityText.includes('Very High')) {
                    cardElement.style.backgroundColor = 'rgba(220, 53, 69, 0.15)'; // light red
                    console.log("Set risk card to red");
                } else {
                    cardElement.style.backgroundColor = 'rgba(255, 193, 7, 0.15)'; // light yellow for Moderate
                    console.log("Set risk card to yellow");
                }
            }
            
            // Initial update
            updateRiskCardColor();
            
            // Create a separate observer for risk
            const riskObserver = new MutationObserver(function() {
                console.log("Risk observer triggered");
                updateRiskCardColor();
            });
            
            // Start observing
            riskObserver.observe(volatilityElement, { 
                childList: true, 
                characterData: true,
                subtree: true 
            });
            
            console.log("Risk monitoring setup complete");
        }

        // 2. DRAWDOWN MONITORING
        function setupDrawdownMonitoring(drawdownElement) {
            console.log("Setting up drawdown monitoring");
            
            // Find the drawdown card element
            const drawdownCard = findParentCard('max-drawdown');
            
            if (drawdownCard) {
                setupDrawdownObserver(drawdownElement, drawdownCard);
            } else {
                console.error("Could not find parent card for drawdown");
            }
        }

        function setupDrawdownObserver(drawdownElement, cardElement) {
            function updateDrawdownCardColor() {
                const drawdownText = drawdownElement.innerText || drawdownElement.textContent;
                console.log("Drawdown text:", drawdownText);
                
                const cleanText = drawdownText.replace(/[^\d.-]/g, '');
                const drawdownValue = parseFloat(cleanText);
                
                if (isNaN(drawdownValue)) {
                    console.error("Could not parse a valid number from drawdown text");
                    return;
                }
                
                console.log("Drawdown value:", drawdownValue);
                
                if (drawdownValue <= -15) {
                    cardElement.style.backgroundColor = '#ffe6e6'; // Light red
                    console.log("Set drawdown card to red");
                } else {
                    cardElement.style.backgroundColor = '#e6f7e6'; // Light green
                    console.log("Set drawdown card to green");
                }
            }
            
            // Initial update
            updateDrawdownCardColor();
            
            // Create a separate observer for drawdown
            const drawdownObserver = new MutationObserver(function() {
                console.log("Drawdown observer triggered");
                updateDrawdownCardColor();
            });
            
            // Start observing
            drawdownObserver.observe(drawdownElement, { 
                childList: true, 
                characterData: true,
                subtree: true 
            });
            
            console.log("Drawdown monitoring setup complete");
        }

        // 3. PORTFOLIO RETURN MONITORING (FOR BOTH PORTFOLIO VALUE AND TOTAL RETURN CARDS)
        function setupReturnMonitoring(annualizedReturnElement) {
            console.log("Setting up annualized return monitoring");
            
            // Find both card elements
            const portfolioValueCard = findParentCard('final-value');
            const totalReturnCard = findParentCard('total-return');
            
            if (!portfolioValueCard) {
                console.error("Could not find portfolio value card");
            }
            
            if (!totalReturnCard) {
                console.error("Could not find total return card");
            }
            
            // Set up the monitoring if at least one card was found
            if (portfolioValueCard || totalReturnCard) {
                setupReturnObserver(annualizedReturnElement, portfolioValueCard, totalReturnCard);
            }
        }

        function setupReturnObserver(annualizedReturnElement, portfolioValueCard, totalReturnCard) {
            function updateReturnCards() {
                const returnText = annualizedReturnElement.innerText || annualizedReturnElement.textContent;
                console.log("Annualized return text:", returnText);
                
                // Extract the percentage value (looking for a number followed by % per year)
                const matches = returnText.match(/(-?\d+\.?\d*)%/);
                if (!matches || matches.length < 2) {
                    console.error("Could not parse annualized return percentage");
                    return;
                }
                
                const annualizedReturnValue = parseFloat(matches[1]);
                console.log("Parsed annualized return value:", annualizedReturnValue);
                
                // Apply the appropriate background color based on the threshold
                if (annualizedReturnValue >= 6) {
                    console.log("Setting cards to green (>= 6%)");
                    if (portfolioValueCard) portfolioValueCard.style.backgroundColor = '#e6f7e6'; // Light green
                    if (totalReturnCard) totalReturnCard.style.backgroundColor = '#e6f7e6'; // Light green
                } else {
                    console.log("Setting cards to red (< 6%)");
                    if (portfolioValueCard) portfolioValueCard.style.backgroundColor = '#ffe6e6'; // Light red
                    if (totalReturnCard) totalReturnCard.style.backgroundColor = '#ffe6e6'; // Light red
                }
            }
            
            // Initial update
            updateReturnCards();
            
            // Create an observer for the annualized return
            const returnObserver = new MutationObserver(function() {
                console.log("Annualized return observer triggered");
                updateReturnCards();
            });
            
            // Start observing
            returnObserver.observe(annualizedReturnElement, { 
                childList: true, 
                characterData: true,
                subtree: true 
            });
            
            console.log("Annualized return monitoring setup complete");
        }

        // Initialize all monitors when the page loads
        window.addEventListener('load', function() {
            console.log("Window loaded, setting up all monitors");
            
            // 1. Set up risk/volatility monitoring
            waitForElement('volatility', setupRiskMonitoring, 100, 10000);
            
            // 2. Set up maximum drawdown monitoring
            waitForElement('max-drawdown', setupDrawdownMonitoring, 100, 10000);
            
            // 3. Set up return monitoring (for both portfolio value and total return cards)
            waitForElement('annualized-return', setupReturnMonitoring, 100, 10000);
        });


        /////
        
        // Function to fetch date range from API
        function fetchDateRange() {
            fetch(API_DATE_RANGE)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    minDate = new Date(data.min_date);
                    maxDate = new Date(data.max_date);
                    
                    // Set default selected dates to max range
                    selectedStartDate = minDate;
                    selectedEndDate = maxDate;
                    
                    // Display date range text initially
                    updateDateRangeDisplay();
                    
                    // Display ETF returns if needed
                    const etfReturns = data.etf_returns;
                    for (const etf in etfReturns) {
                        const returnEl = document.getElementById(`${etf.toLowerCase()}-return`);
                        if (returnEl) {
                            returnEl.textContent = `${etfReturns[etf].toFixed(2)}%`;
                        }
                    }
                    
                    // Now that we have the date range, trigger the initial calculation
                    calculateAndFetchResults();
                })
                .catch(error => {
                    showApiError(`Failed to fetch date range: ${error.message}`);
                });
        }

        // Function to initialize time period buttons
        function initializeTimePeriodButtons() {
            const buttons = document.querySelectorAll('.time-btn');
            
            buttons.forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all buttons
                    buttons.forEach(btn => btn.classList.remove('active'));
                    
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Get the selected period
                    const period = this.getAttribute('data-period');
                    
                    // Calculate start and end dates based on the period
                    if (period === 'MAX') {
                        selectedStartDate = minDate;
                        selectedEndDate = maxDate;
                    } else {
                        selectedEndDate = new Date(maxDate); // Use a copy of maxDate
                        selectedStartDate = calculateStartDate(period);
                    }
                    
                    // Update the date range display
                    updateDateRangeDisplay();
                    
                    // If allocations are valid, trigger calculation
                    // if (checkAllocation()) {
                    //     calculateAndFetchResults();
                    // }

                    if (checkAllocation()) {
                        calculateAndFetchResults();
                        createVolumeChart();
                        // Update correlation matrix if correlation tab is active
                        if (document.querySelector('#correlation').classList.contains('active')) {
                            createCorrelationMatrix();
                        }
                    }
                });
            });
        }

        // Function to calculate start date based on period
        function calculateStartDate(period) {
        const endDate = new Date(selectedEndDate);
        const startDate = new Date(endDate);
        
        switch (period) {
            case '1M':
                startDate.setMonth(endDate.getMonth() - 1);
                break;
            case '6M':
                startDate.setMonth(endDate.getMonth() - 6);
                break;
            case '1Y':
                startDate.setFullYear(endDate.getFullYear() - 1);
                break;
            default:
                startDate = new Date(minDate);
        }
        
        // Ensure the start date is not earlier than the minimum available date
        if (startDate < minDate) {
            startDate = new Date(minDate);
        }
        
        return startDate;
        }

        // Function to update the date range display
        function updateDateRangeDisplay() {
        const dateDisplay = document.getElementById('date-range-display');
        dateDisplay.textContent = `From ${formatDate(selectedStartDate)} to ${formatDate(selectedEndDate)}`;
        }

        // Function to initialize allocation sliders [SPY, BND, VTIP, VXUS] to [USMV, VYM, SPLV, AGG]
        function initializeAllocationSliders() {
            const usmvSlider = document.getElementById('usmv-allocation');
            const vymSlider = document.getElementById('vym-allocation');
            const splvSlider = document.getElementById('splv-allocation');
            const aggSlider = document.getElementById('agg-allocation');
            
            const usmvValue = document.getElementById('usmv-value');
            const vymValue = document.getElementById('vym-value');
            const splvValue = document.getElementById('splv-value');
            const aggValue = document.getElementById('agg-value');
            
            usmvSlider.addEventListener('input', function() {
                usmvValue.textContent = `${usmvSlider.value}%`;
                checkAllocation();
            });
            
            vymSlider.addEventListener('input', function() {
                vymValue.textContent = `${vymSlider.value}%`;
                checkAllocation();
            });
            
            splvSlider.addEventListener('input', function() {
                splvValue.textContent = `${splvSlider.value}%`;
                checkAllocation();
            });
            
            aggSlider.addEventListener('input', function() {
                aggValue.textContent = `${aggSlider.value}%`;
                checkAllocation();
            });
        }
        
        // Function to check if allocations sum to 100%
        function checkAllocation() {
            const usmvValue = parseInt(document.getElementById('usmv-allocation').value);
            const vymValue = parseInt(document.getElementById('vym-allocation').value);
            const splvValue = parseInt(document.getElementById('splv-allocation').value);
            const aggValue = parseInt(document.getElementById('agg-allocation').value);
            
            const total = usmvValue + vymValue + splvValue + aggValue;
            const warningEl = document.getElementById('allocation-warning');
            
            if (total !== 100) {
                warningEl.textContent = `Total allocation: ${total}% (should be 100%)`;
                return false;
            } else {
                warningEl.textContent = '';
                return true;
            }
        }
        
        // Function to initialize tabs
        function initializeTabs() {
            const tabs = document.querySelectorAll('.tab');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    
                    // Remove active class from all tabs and tab content
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    this.classList.add('active');
                    document.getElementById(tabId).classList.add('active');
                    
                    // Re-render charts when tab becomes visible to fix layout issues
                    setTimeout(() => {
                        if (tabId === 'candlestick' && candlestickData) {
                            createCandlestickChart();
                        } else if (tabId === 'company' && portfolioData) {
                            createCompanyWeightageChart();
                        } else if (tabId === 'industry' && portfolioData) {
                            createIndustryWeightageChart();
                        } else if (tabId === 'correlation' && portfolioData) {
                            createCorrelationMatrix();
                        } else if (tabId === 'drawdown' && portfolioData) {
                            createDrawdownChart(portfolioData);
                        }
                    }, 50);
                });
            });
        }

        // Helper function to get current allocations
        function getCurrentAllocations() {
            return {
                'USMV': parseInt(document.getElementById('usmv-allocation').value),
                'VYM': parseInt(document.getElementById('vym-allocation').value),
                'SPLV': parseInt(document.getElementById('splv-allocation').value),
                'AGG': parseInt(document.getElementById('agg-allocation').value)
            };
        }
        
        // Function to calculate and fetch results from API
        function calculateAndFetchResults() {
            // Check if allocations are valid
            if (!checkAllocation()) {
                alert('Total allocation must be 100%. Please adjust your allocations.');
                return;
            }
            
            // Get input values
            const initialInvestment = parseFloat(document.getElementById('initial-investment').value * 0.75);
            const usmvAllocation = parseInt(document.getElementById('usmv-allocation').value);
            const vymAllocation = parseInt(document.getElementById('vym-allocation').value);
            const splvAllocation = parseInt(document.getElementById('splv-allocation').value);
            const aggAllocation = parseInt(document.getElementById('agg-allocation').value);
            
            // Use the selected date range
            const startDate = formatDateForAPI(selectedStartDate);
            const endDate = formatDateForAPI(selectedEndDate);
            
            // Prepare API request payload
            const payload = {
                initial_investment: initialInvestment,
                allocations: {
                    'USMV': usmvAllocation,
                    'VYM': vymAllocation,
                    'SPLV': splvAllocation,
                    'AGG': aggAllocation
                },
                start_date: startDate,
                end_date: endDate
            };
            
            // Show loading state
            document.querySelectorAll('.loading').forEach(el => {
                el.style.display = 'block';
            });
            
            // Clear any previous error messages
            hideApiError();
            
            // Fetch all data at once
            fetchAllData(payload);
        }

        // Helper function to format dates for API (YYYY-MM-DD)
        function formatDateForAPI(date) {
            if (!date) return null;
            
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            
            return `${year}-${month}-${day}`;
        }
        
        // Function to fetch all data from the API
        function fetchAllData(payload) {
            // Use the calculate-all endpoint
            fetch(API_CALCULATE_ALL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        try {
                            const err = JSON.parse(text);
                            throw new Error(err.error || `HTTP error! Status: ${response.status}`);
                        } catch(e) {
                            throw new Error(`HTTP error! Status: ${response.status}, Body: ${text.substring(0, 100)}...`);
                        }
                    });
                }
                return response.text().then(text => {
                    // Replace NaN with null in the response to handle JSON parsing issues
                    const cleanedText = text.replace(/NaN/g, 'null');
                    return JSON.parse(cleanedText);
                });
            })
            .then(data => {
                // Store the data
                const metrics = data.metrics;
                portfolioData = data.portfolio_data;
                etfPerformance = data.etf_performance;
                yearlyReturns = data.yearly_returns;
                candlestickData = data.candlestick_data || [];
                
                console.log("Data received:", {
                    portfolioDataPoints: portfolioData?.length || 0,
                    etfPerformanceEntries: Object.keys(etfPerformance || {}).length,
                    yearlyReturnsPoints: yearlyReturns?.length || 0,
                    candlestickDataPoints: candlestickData?.length || 0
                });
                
                // Update metrics display
                updateMetricsDisplay(metrics, payload.initial_investment);
                
                // Create charts - using the new comparison chart instead of growth chart
                createCandlestickChart(); 
                createDrawdownChart(portfolioData);
                createCompanyWeightageChart();

                
                // Hide loading indicators
                document.querySelectorAll('.loading').forEach(el => {
                    el.style.display = 'none';
                });
            })
            .catch(error => {
                showApiError(`Failed to fetch portfolio data: ${error.message}`);
                
                // Hide loading indicators
                document.querySelectorAll('.loading').forEach(el => {
                    el.style.display = 'none';
                });
            });
        }

        // Helper function to show API error
        function showApiError(message) {
            const errorEl = document.getElementById('api-error');
            const messageEl = document.getElementById('error-message');
            messageEl.textContent = message;
            errorEl.style.display = 'block';
        }

        // Helper function to hide API error
        function hideApiError() {
            const errorEl = document.getElementById('api-error');
            errorEl.style.display = 'none';
        }

        // Helper function to format date
        function formatDate(date) {
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }
        
        // Function to update metrics display
        function updateMetricsDisplay(metrics, initialInvestment) {
            document.getElementById('final-value').textContent = formatCurrency(metrics.final_value);
            document.getElementById('initial-value').textContent = `Initial: ${formatCurrency(initialInvestment)}`;
            document.getElementById('total-return').textContent = formatPercentage(metrics.total_return);
            document.getElementById('annualized-return').textContent = `Annualized: ${formatPercentage(metrics.annualized_return)} per year`;
            document.getElementById('max-drawdown').textContent = formatPercentage(metrics.max_drawdown);
            document.getElementById('volatility').textContent = `${metrics.risk_level} (${formatPercentage(metrics.volatility)})`;
        }

        // Helper function to format currency
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value);
        }

        // Helper function to format percentage
        function formatPercentage(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'percent',
                minimumFractionDigits: 1,
                maximumFractionDigits: 1
            }).format(value);
        }


// Function to create candlestick chart
function createCandlestickChart() {
    const chartContainer = document.getElementById('candlestick-chart');
    if (!chartContainer) {
        console.error('Candlestick chart container not found');
        return;
    }
    
    // Show loading message
    chartContainer.innerHTML = '<div class="loading">Loading candlestick data...</div>';
    
    // Get the allocation weights
    const allocations = {
        'USMV': parseInt(document.getElementById('usmv-allocation').value) / 100,
        'VYM': parseInt(document.getElementById('vym-allocation').value) / 100,
        'SPLV': parseInt(document.getElementById('splv-allocation').value) / 100,
        'AGG': parseInt(document.getElementById('agg-allocation').value) / 100
    };
    
    // Get initial investment
    const initialInvestment = parseFloat(document.getElementById('initial-investment').value * 0.75);
    
    // Format dates for API
    const startDate = formatDateForAPI(selectedStartDate);
    const endDate = formatDateForAPI(selectedEndDate);
    
    console.log(`Creating portfolio candlestick chart from ${startDate} to ${endDate}`);
    console.log(`Portfolio allocations:`, allocations);
    console.log(`Initial investment: $${initialInvestment}`);
    
    // Request portfolio data directly from the candlestick-data endpoint
    fetch('http://localhost:5007/candlestick-data', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            ticker: 'portfolio',
            tickers: allocations,
            initial_investment: initialInvestment,
            start_date: startDate,
            end_date: endDate
        })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                console.log("API Error Response:", err);
                throw new Error(err.error || `Server responded with status ${response.status}`);
            }).catch(e => {
                if (e.message && e.message.includes('JSON')) {
                    throw new Error(`Server responded with status ${response.status}`);
                }
                throw e;
            });
        }
        return response.json();
    })
    .then(data => {
        console.log(`Received portfolio data with ${data.candlestick_data?.length || 0} data points`);
        
        if (!data.candlestick_data || data.candlestick_data.length === 0) {
            chartContainer.innerHTML = '<div class="error">No portfolio data available for the selected date range</div>';
            return;
        }
        
        // Process portfolio data for candlestick chart
        const candlestickData = data.candlestick_data;
        
        // Clear container
        chartContainer.innerHTML = '';
        
        // Check container width
        const containerWidth = chartContainer.clientWidth;
        if (containerWidth <= 0) {
            setTimeout(() => createCandlestickChart(), 100);
            return;
        }
        
        // Convert string dates to Date objects for D3
        const processedData = candlestickData.map(d => ({
            Date: new Date(d.date),
            Open: d.open,
            High: d.high,
            Low: d.low,
            Close: d.close
        }));
        
        // Sort data by date
        processedData.sort((a, b) => a.Date - b.Date);
        
        console.log(`Processed ${processedData.length} portfolio data points for candlestick chart`);
        
        // Set up chart dimensions
        const margin = containerWidth < 400
            ? { top: 30, right: 30, bottom: 70, left: 50 }
            : { top: 30, right: 50, bottom: 70, left: 80 };
        
        const width = Math.max(containerWidth - margin.left - margin.right, 100);
        const height = 500 - margin.top - margin.bottom;
        
        const svg = d3.select(chartContainer)
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // Add title
        svg.append('text')
            .attr('x', width / 2)
            .attr('y', -margin.top / 2)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .style('font-weight', 'bold');
        
        // Create x-scale - use scaleBand for candlesticks
        const x = d3.scaleBand()
            .domain(processedData.map(d => d.Date))
            .range([0, width])
            .padding(0.2);
        
        // Calculate y-domain with some padding
        const minPrice = d3.min(processedData, d => d.Low);
        const maxPrice = d3.max(processedData, d => d.High);
        const yDomainPadding = (maxPrice - minPrice) * 0.05;
        
        // Y scale
        const y = d3.scaleLinear()
            .domain([minPrice - yDomainPadding, maxPrice + yDomainPadding])
            .range([height, 0]);
        
        // Create date formatter based on range
        const firstDate = processedData[0].Date;
        const lastDate = processedData[processedData.length - 1].Date;
        const daysInRange = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
        let tickFormat;
        
        if (daysInRange > 365) {
            tickFormat = d3.timeFormat('%b %Y'); // Month Year for ranges > 1 year
        } else if (daysInRange > 60) {
            tickFormat = d3.timeFormat('%b %d'); // Month Day for ranges > 60 days
        } else {
            tickFormat = d3.timeFormat('%b %d'); // Month Day for smaller ranges
        }
        
        // X axis - adjust tick count based on number of data points
        // For 1 month we want to show more ticks
        const tickValues = x.domain().filter((d, i, arr) => {
            // For 1-month view (less than 30 days and more than 10 data points)
            if (daysInRange <= 32 && arr.length <= 30) {
                // Show every 2-3 days depending on how many data points we have
                const step = arr.length <= 15 ? 1 : (arr.length <= 22 ? 2 : 3);
                return i % step === 0;
            } else {
                // For longer periods use more sparse ticks
                const step = Math.ceil(arr.length / (containerWidth < 600 ? 6 : 12));
                return i % step === 0;
            }
        });
        
        svg.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x)
                .tickFormat(tickFormat)
                .tickValues(tickValues)
            )
            .selectAll('text')
            .attr('transform', 'rotate(-45)')
            .style('text-anchor', 'end');
        
        // Y axis
        svg.append('g')
            .call(d3.axisLeft(y).tickFormat(d => '$' + d.toFixed(2)));
        
        // Draw candlesticks
        // 1. Vertical lines (High to Low)
        svg.selectAll('.candlestick-line')
            .data(processedData)
            .enter()
            .append('line')
            .attr('class', 'candlestick-line')
            .attr('x1', d => x(d.Date) + x.bandwidth() / 2)
            .attr('x2', d => x(d.Date) + x.bandwidth() / 2)
            .attr('y1', d => y(d.High))
            .attr('y2', d => y(d.Low))
            .attr('stroke', 'black')
            .attr('stroke-width', 1);
        
        // 2. Candlestick bodies - ensure positive width/height
        svg.selectAll('.candlestick-body')
            .data(processedData)
            .enter()
            .append('rect')
            .attr('class', 'candlestick-body')
            .attr('x', d => x(d.Date))
            .attr('width', () => Math.max(x.bandwidth(), 1)) // Ensure positive width
            .attr('y', d => y(Math.max(d.Open, d.Close)))
            .attr('height', d => {
                return Math.max(Math.abs(y(d.Open) - y(d.Close)), 1);
            })
            .attr('fill', d => d.Open > d.Close ? '#ff3333' : '#33cc33') // Red for bearish, green for bullish
            .attr('stroke', 'black')
            .attr('stroke-width', 1);
        
        // Add tooltip
        const tooltip = d3.select('#tooltip');
        
        // Add hover effects
        svg.selectAll('.candlestick-body')
            .on('mouseover', function(event, d) {
                d3.select(this).attr('stroke-width', 2);
                tooltip.transition()
                    .duration(200)
                    .style('opacity', .9);
                
                // Format date with day of week
                const formattedDate = d.Date.toLocaleDateString(undefined, { 
                    weekday: 'short', 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric' 
                });
                
                // Calculate daily change
                const changePercent = ((d.Close - d.Open) / d.Open * 100).toFixed(2);
                const changeColor = d.Close >= d.Open ? 'green' : 'red';
                
                tooltip.html(`
                    <strong>Date:</strong> ${formattedDate}<br>
                    <strong>Open:</strong> $${d.Open.toFixed(2)}<br>
                    <strong>Close:</strong> $${d.Close.toFixed(2)}<br>
                    <strong>High:</strong> $${d.High.toFixed(2)}<br>
                    <strong>Low:</strong> $${d.Low.toFixed(2)}<br>
                    <strong>Change:</strong> <span style="color:${changeColor}">${changePercent}%</span>
                `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
            })
            .on('mouseout', function() {
                d3.select(this).attr('stroke-width', 1);
                tooltip.transition()
                    .duration(500)
                    .style('opacity', 0);
            });
    })
    .catch(error => {
        chartContainer.innerHTML = `<div class="error">Error: ${error.message}</div>`;
        console.error('Error fetching portfolio data:', error);
    });
}

        // Function to create company weightage chart
        function createCompanyWeightageChart() {
            // Ensure the chart container is cleared
            const chartContainer = document.getElementById('company-chart');
            chartContainer.innerHTML = ''; // Clear previous chart

            // Get current allocations
            const allocations = {
                'USMV': parseInt(document.getElementById('usmv-allocation').value) / 100,
                'VYM': parseInt(document.getElementById('vym-allocation').value) / 100,
                'SPLV': parseInt(document.getElementById('splv-allocation').value) / 100,
                'AGG': parseInt(document.getElementById('agg-allocation').value) / 100
            };
        
            // Fetch company weightage data from dedicated microservice
            fetch('http://localhost:5004/portfolio-company-weightage', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    tickers: {
                        'USMV': allocations['USMV'] * 100,
                        'VYM': allocations['VYM'] * 100,
                        'SPLV': allocations['SPLV'] * 100,
                        'AGG': allocations['AGG'] * 100
                    }
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to fetch company weightage data');
                }
                return response.json();
            })
            .then(data => {
                const companyData = data.portfolio_company_allocation || [];
            
                // Merge duplicate companies by summing their weights
                const mergedData = [];
                const companyMap = new Map();
            
                companyData.forEach(d => {
                    const companyName = d.Company;

                    // Check if the company name contains "U.S. Treasury" and merge them
                    if (companyName.includes('U.S. Treasury')) {
                        if (companyMap.has('U.S. Treasury Note')) {
                            companyMap.set('U.S. Treasury Note', companyMap.get('U.S. Treasury Note') + d.Weight);
                        } else {
                            companyMap.set('U.S. Treasury Note', d.Weight);
                        }
                    } else {
                        if (companyMap.has(companyName)) {
                            companyMap.set(companyName, companyMap.get(companyName) + d.Weight);
                        } else {
                            companyMap.set(companyName, d.Weight);
                        }
                    }
                });
            
                // Convert map to an array for D3 processing
                companyMap.forEach((weight, company) => {
                    mergedData.push({ Company: company, Weight: weight });
                });
            
                // Sort by weight in descending order
                mergedData.sort((a, b) => b.Weight - a.Weight);
            
                // Dimensions
                const width = chartContainer.clientWidth;
                const height = 500;
            
                // Create SVG
                const svg = d3.select(chartContainer)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);
            
                // Set a minimum light shade for the least significant value
                const minColor = "#b5d4e9"; // Light blue (can adjust to your desired light shade)
            
                // Color scale: Invert the color scale so the highest weight is the darkest
                const color = d3.scaleSequential(d3.interpolateBlues)
                    .domain([mergedData.length, 0]); // Inverted color scale (largest value is darkest)
            
                // Treemap layout
                const treemap = d3.treemap()
                    .size([width, height])
                    .padding(1)
                    .round(true);
            
                // Prepare hierarchical data
                const root = d3.hierarchy({
                    name: 'Portfolio',
                    children: mergedData.map(d => ({
                        name: d.Company,
                        value: d.Weight
                    }))
                }).sum(d => d.value);
            
                // Generate treemap
                treemap(root);
            
                // Create rectangles for each company
                const cell = svg.selectAll('g')
                    .data(root.leaves())
                    .enter().append('g')
                    .attr('transform', d => `translate(${d.x0},${d.y0})`);
            
                cell.append('rect')
                    .attr('width', d => d.x1 - d.x0)
                    .attr('height', d => d.y1 - d.y0)
                    .attr('fill', (d, i) => {
                        // Apply the minimum light shade for companies with weight below a threshold
                        return d.data.value < 0.001 ? minColor : color(i); // Use minColor for values below 1%
                    })
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
                
                // Add text labels for company names (truncate if too long)
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 15)
                    .text(d => {
                        const maxLength = 20;
                        const name = d.data.name;
                        return name.length > maxLength
                            ? name.substring(0, maxLength) + '...'
                            : name;
                    })
                    .attr('font-size', '12px')
                    .attr('fill', 'white')
                    .attr('font-weight', 'bold');
                
                // Add percentage labels for weight
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 30)
                    .text(d => `${d.data.value.toFixed(2)*100}%`)
                    .attr('font-size', '10px')
                    .attr('fill', 'white');
                
                // Create a tooltip for hover interactions
                const tooltip = d3.select('#tooltip');
                cell.on('mouseover', function(event, d) {
                    tooltip.style('opacity', 1)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <strong>${d.data.name}</strong><br>
                            Weight: ${d.data.value.toFixed(3)*100}%
                        `);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
            })
            .catch(error => {
                console.error('Error fetching company weightage:', error);
                chartContainer.innerHTML = `<p>Error loading company weightage: ${error.message}</p>`;
            });
        }

        function createIndustryWeightageChart() {
    // Ensure the chart container is cleared
    const chartContainer = document.getElementById('industry-chart');
    chartContainer.innerHTML = ''; // Clear previous chart

    // Get current allocations
    const allocations = {
        'USMV': parseInt(document.getElementById('usmv-allocation').value) / 100,
        'VYM': parseInt(document.getElementById('vym-allocation').value) / 100,
        'SPLV': parseInt(document.getElementById('splv-allocation').value) / 100,
        'AGG': parseInt(document.getElementById('agg-allocation').value) / 100
    };

    // Fetch industry weightage data from the dedicated microservice
    fetch('http://localhost:5006/portfolio-industry-weightage', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            tickers: {
                'USMV': allocations['USMV'] * 100, // Convert to percentage
                'VYM': allocations['VYM'] * 100,
                'SPLV': allocations['SPLV'] * 100,
                'AGG': allocations['AGG'] * 100
            }
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Failed to fetch industry weightage data');
        }
        return response.json();
    })
    .then(data => {
        const industryData = data.portfolio_industry_allocation || [];

        // Sort the data by weight in descending order
        industryData.sort((a, b) => b.Weight - a.Weight);

        // Dimensions for the tree map
        const width = chartContainer.clientWidth;
        const height = 500;

        // Create SVG
        const svg = d3.select(chartContainer)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .append('g');

        // Set a minimum light shade for the least significant value
        const minColor = "#b5d4e9"; // Light blue (can adjust to your desired light shade)

        // Color scale: Invert the color scale so the highest weight is the darkest
        const color = d3.scaleSequential(d3.interpolateBlues)
            .domain([industryData.length, 0]); // Inverted color scale (largest value is darkest)

        // Treemap layout
        const treemap = d3.treemap()
            .size([width, height])
            .padding(1)
            .round(true);

        // Prepare hierarchical data for D3 processing
        const root = d3.hierarchy({
            name: 'Portfolio',
            children: industryData.map(d => ({
                name: d.Industry,
                value: d.Weight
            }))
        }).sum(d => d.value);

        // Generate treemap
        treemap(root);

        // Create rectangles for each industry
        const cell = svg.selectAll('g')
            .data(root.leaves())
            .enter().append('g')
            .attr('transform', d => `translate(${d.x0},${d.y0})`);

        // Add rectangles for industries
        cell.append('rect')
            .attr('width', d => d.x1 - d.x0)
            .attr('height', d => d.y1 - d.y0)
            .attr('fill', (d, i) => {
                // Apply the minimum light shade for companies with weight below a threshold
                return d.data.value < 0.001 ? minColor : color(i); // Use minColor for values below 1%
            })
            .attr('stroke', 'white')
            .attr('stroke-width', 1);

        // Add text labels for industry names (truncate if too long)
        cell.append('text')
            .attr('x', 5)
            .attr('y', 15)
            .text(d => {
                const maxLength = 20;
                const name = d.data.name;
                return name.length > maxLength
                    ? name.substring(0, maxLength) + '...'
                    : name;
            })
            .attr('font-size', '12px')
            .attr('fill', 'white')
            .attr('font-weight', 'bold');

        // Add percentage labels for weight
        cell.append('text')
            .attr('x', 5)
            .attr('y', 30)
            .text(d => `${d.data.value.toFixed(3)}%`)
            .attr('font-size', '10px')
            .attr('fill', 'white');

        // Create a tooltip for hover interactions
        const tooltip = d3.select('#tooltip');
        cell.on('mouseover', function(event, d) {
            tooltip.style('opacity', 1)
                .style('left', (event.pageX + 15) + 'px')
                .style('top', (event.pageY - 28) + 'px')
                .html(`
                    <strong>${d.data.name}</strong><br>
                    Weight: ${d.data.value.toFixed(3)}%
                `);
        })
        .on('mouseout', function() {
            tooltip.style('opacity', 0);
        });
    })
    .catch(error => {
        console.error('Error fetching industry weightage:', error);
        chartContainer.innerHTML = `<p>Error loading industry weightage: ${error.message}</p>`;
    });
}


        // Function to create drawdown chart
        function createDrawdownChart(portfolioData) {
            const chartContainer = document.getElementById('drawdown-chart');
            chartContainer.innerHTML = '';
            
            // Check container width first
            const containerWidth = chartContainer.clientWidth;
            
            if (containerWidth <= 0) {
                // Wait for the layout to stabilize (e.g., tab becoming visible)
                setTimeout(() => createDrawdownChart(portfolioData), 100);
                return;
            }
            
            // Use smaller margins if container is narrow
            const margin = containerWidth < 400 
                ? {top: 20, right: 30, bottom: 50, left: 40}
                : {top: 20, right: 80, bottom: 50, left: 80};
            
            const width = Math.max(containerWidth - margin.left - margin.right, 100); // Ensure minimum width
            const height = 400 - margin.top - margin.bottom;
            
            const svg = d3.select(chartContainer)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Make sure dates are Date objects
            portfolioData.forEach(d => {
                if (!(d.Date instanceof Date)) {
                    d.Date = new Date(d.Date);
                }
            });
            
            // Calculate domain for drawdown
            const minDrawdown = d3.min(portfolioData, d => d.drawdown);
            
            // X scale
            const x = d3.scaleTime()
                .domain(d3.extent(portfolioData, d => d.Date))
                .range([0, width]);
            
            // Y scale for drawdown (negative values)
            const y = d3.scaleLinear()
                .domain([minDrawdown * 1.1 || -0.1, 0]) // Fallback if minDrawdown is undefined
                .range([height, 0]);
            
            // X axis
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(width > 500 ? 10 : 5)
                    .tickFormat(d3.timeFormat('%b %Y')))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            // Y axis
            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y)
                    .tickFormat(d => `${d3.format('.0%')(d)}`));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -margin.left + 20) // Adjust based on margin
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Drawdown (%)');
            
            // Create the area generator for the area ABOVE the drawdown line (between drawdown and zero)
            const area = d3.area()
                .x(d => x(d.Date))
                .y0(d => y(d.drawdown)) // Bottom of the area is at the drawdown value
                .y1(y(0));              // Top of the area is at zero
            
            // Draw the area ABOVE the drawdown line in red
            svg.append('path')
                .datum(portfolioData)
                .attr('fill', 'rgba(255, 0, 0, 0.3)')
                .attr('d', area);
            
            // Draw the drawdown line
            const line = d3.line()
                .x(d => x(d.Date))
                .y(d => y(d.drawdown));
            
            svg.append('path')
                .datum(portfolioData)
                .attr('fill', 'none')
                .attr('stroke', 'rgb(255, 0, 0)')
                .attr('stroke-width', 2)
                .attr('d', line);
            
            // Add a zero line
            svg.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', y(0))
                .attr('y2', y(0))
                .attr('stroke', '#888')
                .attr('stroke-dasharray', '3,3');
            
            // Create a tooltip for drawdown
            const tooltip = d3.select('#tooltip');
            const bisect = d3.bisector(d => d.Date).left;
            
            svg.append('rect')
                .attr('width', width > 0 ? width : 0) // Ensure width is not negative
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mousemove', function(event) {
                    const mouseX = d3.pointer(event)[0];
                    const x0 = x.invert(mouseX);
                    const i = bisect(portfolioData, x0, 1);
                    if (i >= portfolioData.length) return;
                    const d0 = portfolioData[i - 1];
                    const d1 = portfolioData[i];
                    const d = x0 - d0.Date > d1.Date - x0 ? d1 : d0;
                    
                    tooltip.style('opacity', 1)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <strong>Date:</strong> ${formatDate(d.Date)}<br>
                            <strong>Drawdown:</strong> ${d3.format('.2%')(d.drawdown)}<br>
                            <strong>Peak Value:</strong> ${formatCurrency(d.peak_value)}<br>
                            <strong>Current Value:</strong> ${formatCurrency(d.total_value)}
                        `);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
        }

        // Function to create correlation matrix
        function createCorrelationMatrix() {
            console.log("Starting correlation matrix creation...");
            const chartContainer = document.getElementById('correlation-chart');
            if (!chartContainer) {
                console.error("Correlation chart container not found");
                return;
            }
        
            // Show loading state
            chartContainer.innerHTML = '<div class="loading">Loading correlation data...</div>';
        
            // Check if we have valid selected dates from time period buttons
            if (!selectedStartDate || !selectedEndDate) {
                console.error("No date range selected");
                chartContainer.innerHTML = '<div class="error">Please select a date range first</div>';
                return;
            }
        
            // Log the selected date range for debugging
            console.log("Selected date range for correlation:", {
                start: formatDate(selectedStartDate),
                end: formatDate(selectedEndDate)
            });
        
            // Fetch data from API
            fetch('http://localhost:5009/api/get-close-price', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    start_date: formatDateForAPI(selectedStartDate),
                    end_date: formatDateForAPI(selectedEndDate),
                    tickers: ['USMV', 'VYM', 'SPLV', 'AGG']
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("API response:", data);

                // Check if the response contains the correlation matrix
                if (data.correlation_matrix) {
                    // Use the server-calculated correlation matrix
                    const etfs = ['USMV', 'VYM', 'SPLV', 'AGG'];
                    createCorrelationVisualization(data.correlation_matrix, etfs, chartContainer);
                } else {
                    throw new Error("API response doesn't contain correlation matrix");
                }
            })
            .catch(error => {
                console.error("Error fetching correlation data:", error);
                chartContainer.innerHTML = `<div class="error">Error loading correlation data: ${error.message}</div>`;
            });
        }

        function createCorrelationVisualization(matrix, etfs, container) {
            // Clear container
            container.innerHTML = '';

            // Set up dimensions
            const margin = { top: 50, right: 50, bottom: 50, left: 50 };
            const width = Math.min(500, container.clientWidth - margin.left - margin.right);
            const height = width; // Square aspect ratio
            const cellSize = Math.floor(width / etfs.length);

            // Create SVG container
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Color scale for correlation values
            const color = d3.scaleLinear()
                .domain([-1, 0, 1])
                .range(['#e74c3c', '#f5f5f5', '#3498db']);

            // Create a group for each cell
            const cells = svg.selectAll('.cell-group')
                .data(matrix.flat())
                .enter()
                .append('g')
                .attr('class', 'cell-group')
                .attr('transform', d => `translate(${etfs.indexOf(d.target) * cellSize},${etfs.indexOf(d.source) * cellSize})`);

            // Add background rectangle for each cell
            cells.append('rect')
                .attr('class', 'correlation-cell')
                .attr('width', cellSize)
                .attr('height', cellSize)
                .attr('fill', d => {
                    // Use different color for diagonal cells (self-correlation)
                    if (d.source === d.target) {
                        return '#f0f0f0'; // Light gray for diagonal
                    }
                    return color(d.correlation);
                })
                .attr('stroke', 'white')
                .attr('stroke-width', 1);
            
            // Add text for correlation values
            cells.append('text')
                .attr('class', 'correlation-text')
                .attr('x', cellSize / 2)
                .attr('y', cellSize / 2)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .style('font-size', '12px')
                .style('font-weight', d => {
                    // Use normal weight for diagonal, bold for strong correlations
                    return d.source === d.target ? 'normal' : 
                          (Math.abs(d.correlation) > 0.7 ? 'bold' : 'normal');
                })
                .style('fill', d => {
                    // Gray for diagonal, white for dark backgrounds, black for light backgrounds
                    if (d.source === d.target) {
                        return '#999'; // Gray text for diagonal
                    }
                    return Math.abs(d.correlation) > 0.5 ? 'white' : 'black';
                })
                .text(d => d.correlation.toFixed(2));
            
            // Add invisible overlay rectangle for better hover interaction
            cells.append('rect')
                .attr('width', cellSize)
                .attr('height', cellSize)
                .attr('fill', 'transparent')
                .attr('class', 'cell-overlay')
                .on('mouseover', function(event, d) {
                    // Highlight cell on hover with uniform border
                    d3.select(this.parentNode)
                        .select('.correlation-cell')
                        .attr('stroke-width', 2);

                    // Show tooltip
                    d3.select('#tooltip')
                        .style('opacity', 1)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 20) + 'px')
                        .html(`
                            <strong>Correlation:</strong> ${d.correlation.toFixed(3)}<br>
                            <strong>ETFs:</strong> ${d.source} vs ${d.target}
                        `);
                })
                .on('mouseout', function() {
                    // Remove highlight
                    d3.select(this.parentNode)
                        .select('.correlation-cell')
                        .attr('stroke', 'white')
                        .attr('stroke-width', 1);

                    // Hide tooltip
                    d3.select('#tooltip').style('opacity', 0);
                });
            
            // Add ETF labels (x-axis)
            svg.selectAll('.x-label')
                .data(etfs)
                .enter()
                .append('text')
                .attr('class', 'x-label')
                .attr('x', (d, i) => i * cellSize + cellSize/2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text(d => d);
            
            // Add ETF labels (y-axis)
            svg.selectAll('.y-label')
                .data(etfs)
                .enter()
                .append('text')
                .attr('class', 'y-label')
                .attr('x', -10)
                .attr('y', (d, i) => i * cellSize + cellSize/2)
                .attr('text-anchor', 'end')
                .attr('dominant-baseline', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text(d => d);
            
            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', -30)
                .attr('text-anchor', 'middle')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .text('ETF Correlation Matrix');
        }
        
        // Helper function to show API error
        function showApiError(message) {
            const errorEl = document.getElementById('api-error');
            const messageEl = document.getElementById('error-message');
            messageEl.textContent = message;
            errorEl.style.display = 'block';
        }
        
        // Helper function to hide API error
        function hideApiError() {
            const errorEl = document.getElementById('api-error');
            errorEl.style.display = 'none';
        }
        
        // Helper function to format currency
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value);
        }
        
        // Helper function to format percentage
        function formatPercentage(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'percent',
                minimumFractionDigits: 1,
                maximumFractionDigits: 1
            }).format(value);
        }
        
        // Helper function to format date
        function formatDate(date) {
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }
    </script>
</body>
</html>