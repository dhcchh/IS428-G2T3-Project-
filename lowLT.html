<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Low Risk Long-Term Investment Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js" charset="utf-8"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .header h5 {
            margin-top: 0;
            color: #7f8c8d;
        }
        .dashboard {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .controls h3 {
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric-card {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
        }
        .metric-card h3 {
            margin: 10px 0;
            font-size: 1.8rem;
        }
        .metric-card p {
            margin: 0;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        .charts {
            display: grid;
            grid-template-rows: auto;
            gap: 20px;
        }
        .chart-container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .chart-container h3 {
            margin-top: 0;
            margin-bottom: 20px;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        input[type="range"] {
            width: 100%;
        }
        .allocation-display {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
        }
        button {
            width: 100%;
            padding: 10px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 20px;
        }
        button:hover {
            background-color: #2980b9;
        }
        .tab-container {
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .tab.active {
            border-bottom-color: #3498db;
            font-weight: 500;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .warning {
            color: #e74c3c;
            margin-top: 5px;
            font-size: 0.9rem;
        }
        .axis line, .axis path {
            stroke: #ddd;
        }
        .axis text {
            fill: #666;
            font-size: 0.8rem;
        }
        .notes {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        .notes h5 {
            margin-top: 0;
        }
        .notes ul {
            padding-left: 20px;
        }
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 2px;
        }
        .api-error {
            background-color: #fee;
            color: #e74c3c;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        /* CSS for the time period buttons */
        .time-period-buttons {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
        }

        .time-btn {
            flex: 1;
            padding: 8px 0;
            margin: 0 4px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .time-btn:first-child {
            margin-left: 0;
        }

        .time-btn:last-child {
            margin-right: 0;
        }

        .time-btn:hover {
            background-color: #e9ecef;
        }

        .time-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        /* Additional CSS for Portfolio vs SPY comparison */
        .portfolio-line {
            stroke-width: 3px;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .spy-line {
            stroke-width: 2px;
            stroke-dasharray: 5, 5;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .outperformance-positive {
            color: #28a745;
            font-weight: bold;
        }

        .outperformance-negative {
            color: #dc3545;
            font-weight: bold;
        }

        .grid line {
            stroke: #e0e0e0;
            stroke-opacity: 0.7;
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }
        .loading:after {
            content: '...';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Low Risk Long-Term Investment Dashboard</h1>
            <h5>Time in the Market Beats Timing the Market</h5>
        </div>
        
        <div id="api-error" class="api-error">
            <strong>Error connecting to API:</strong> <span id="error-message"></span>
        </div>
        
        <div class="dashboard">
            <div class="controls">
                <h3>Investment Parameters</h3>
                
        <!-- HTML for time period buttons -->
        <div class="control-group">
            <label>Investment Period:</label>
            <div class="time-period-buttons">
                <button class="time-btn" data-period="1M">1M</button>
                <button class="time-btn" data-period="6M">6M</button>
                <button class="time-btn" data-period="1Y">1Y</button>
                <button class="time-btn" data-period="3Y">3Y</button>
                <button class="time-btn" data-period="5Y">5Y</button>
                <button class="time-btn active" data-period="MAX">Max</button>
            </div>
            <div id="date-range-display" style="text-align: center; margin-top: 10px; display: none;">Loading date range...</div>
        </div>
                
                <div class="control-group">
                    <label>Initial Investment (USD):</label>
                    <input type="number" id="initial-investment" min="1000" max="1000000" step="1000" value="10000">
                    <small style="color: #7f8c8d;">Min: $1,000 - Max: $1,000,000</small>
                </div>
                
                <div class="control-group">
                    <label>Portfolio Allocation:</label>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>SPY - S&P 500</span>
                            <span id="spy-value">25%</span>
                        </div>
                        <input type="range" id="spy-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>BND - US Bonds</span>
                            <span id="bnd-value">25%</span>
                        </div>
                        <input type="range" id="bnd-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>VTIP - Inflation-Protected</span>
                            <span id="vtip-value">25%</span>
                        </div>
                        <input type="range" id="vtip-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>VXUS - International Stocks</span>
                            <span id="vxus-value">25%</span>
                        </div>
                        <input type="range" id="vxus-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div id="allocation-warning" class="warning"></div>
                </div>
                
                <button id="calculate-button">Calculate Returns</button>
            </div>
            
            <div class="content">
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Final Portfolio Value</h4>
                        <h3 id="final-value">$0.00</h3>
                        <p id="initial-value">Initial: $0.00</p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>Total Return</h4>
                        <h3 id="total-return">0.0%</h3>
                        <p id="annualized-return">Annualized: 0.0% per year</p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>Maximum Drawdown</h4>
                        <h3 id="max-drawdown">0.0%</h3>
                        <p>Largest decline from peak</p>
                    </div>
                    
                    <div class="metric-card" id="risk-card">
                        <h4>Risk Level</h4>
                        <h3 id="volatility">Low (0.0%)</h3>
                        <p>Portfolio volatility</p>
                    </div>       
                </div>
                
                <div class="tab-container">
                    <ul class="tabs">
                        <li class="tab active" data-tab="growth">Portfolio vs S&P500</li>
                        <li class="tab" data-tab="drawdown">Drawdown Analysis</li>
                        <li class="tab" data-tab="comparison">ETF Comparison</li>
                        <li class="tab" data-tab="yearly">Yearly Returns</li>
                    </ul>
                </div>
                
                <div class="charts">
                    <div id="growth" class="tab-content active">
                        <div class="chart-container">
                            <div id="portfolio-growth-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="growth-legend"></div>
                        </div>
                    </div>
                    
                    <div id="drawdown" class="tab-content">
                        <div class="chart-container">
                            <h3>Portfolio Drawdown Analysis</h3>
                            <div id="drawdown-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="comparison" class="tab-content">
                        <div class="chart-container">
                            <h3>ETF Performance Comparison</h3>
                            <div id="etf-comparison-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="comparison-legend"></div>
                        </div>
                    </div>
                    
                    <div id="yearly" class="tab-content">
                        <div class="chart-container">
                            <h3>Yearly Portfolio Returns</h3>
                            <div id="yearly-returns-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add a tooltip div -->
    <div id="tooltip" class="tooltip"></div>

    <script>
        // API URLs
        const API_BASE_URL = 'http://localhost:5001';
        const API_DATE_RANGE = `${API_BASE_URL}/api/date-range`;
        const API_PORTFOLIO_VALUE = `${API_BASE_URL}/api/portfolio-value`;
        const API_TOTAL_RETURN = `${API_BASE_URL}/api/total-return`;
        const API_MAX_DRAWDOWN = `${API_BASE_URL}/api/max-drawdown`;
        const API_RISK_LEVEL = `${API_BASE_URL}/api/risk-level`;
        const API_PORTFOLIO_GROWTH = `${API_BASE_URL}/api/portfolio-growth`;
        const API_DRAWDOWN_ANALYSIS = `${API_BASE_URL}/api/drawdown-analysis`;
        const API_ETF_COMPARISON = `${API_BASE_URL}/api/etf-comparison`;
        const API_YEARLY_RETURNS = `${API_BASE_URL}/api/yearly-returns`;
        const API_CALCULATE_ALL = `${API_BASE_URL}/api/calculate-all`;
        

        // Global variables
        let minDate, maxDate;
        let selectedStartDate, selectedEndDate;
        let portfolioData = null;
        let drawdownData = null;
        let etfPerformance = null;
        let yearlyReturns = null;
        
        // Main application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize tooltips
            const tooltip = d3.select('#tooltip');
            
            // Initialize date range
            fetchDateRange();
            
            // Initialize allocation sliders
            initializeAllocationSliders();
            
            // Set up tabs
            initializeTabs();
            
            // Set up time period buttons
            initializeTimePeriodButtons();
            
            // Set up calculate button
            document.getElementById('calculate-button').addEventListener('click', function() {
                calculateAndFetchResults();
            });
            
            // Initial calculation will be triggered after date range is fetched
        });

        /////


        // Utility function to wait for elements to exist in the DOM
function waitForElement(elementId, callback, checkFrequencyInMs, timeoutInMs) {
    var startTimeInMs = Date.now();
    var checkElementAndCallback = function() {
        var element = document.getElementById(elementId);
        if (element) {
            console.log(elementId + " element found!");
            callback(element);
            return;
        }
        
        if (timeoutInMs && Date.now() - startTimeInMs > timeoutInMs) {
            console.log(elementId + " element not found within timeout period");
            return;
        }
        
        setTimeout(checkElementAndCallback, checkFrequencyInMs);
    };
    
    checkElementAndCallback();
}

// Helper function to find the parent metric card of an element
function findParentCard(elementId) {
    const element = document.getElementById(elementId);
    if (!element) {
        console.log("Element with ID " + elementId + " not found");
        return null;
    }
    
    // Find parent metric card
    const parentCard = element.closest('.metric-card');
    if (parentCard) {
        console.log("Found parent card for " + elementId);
        return parentCard;
    } else {
        console.log("Could not find parent card for " + elementId);
        return null;
    }
}

// 1. RISK/VOLATILITY MONITORING
function setupRiskMonitoring(volatilityElement) {
    console.log("Setting up risk/volatility monitoring");
    
    // Find the risk card element
    const riskCard = findParentCard('volatility');
    
    if (riskCard) {
        setupRiskObserver(volatilityElement, riskCard);
    } else {
        console.error("Could not find parent card for volatility");
    }
}

function setupRiskObserver(volatilityElement, cardElement) {
    function updateRiskCardColor() {
        const volatilityText = volatilityElement.innerText || volatilityElement.textContent;
        console.log("Volatility text:", volatilityText);
        
        if (volatilityText.includes('Very Low') || volatilityText.includes('Low')) {
            cardElement.style.backgroundColor = 'rgba(40, 167, 69, 0.15)'; // light green
            console.log("Set risk card to green");
        } else if (volatilityText.includes('High') || volatilityText.includes('Very High')) {
            cardElement.style.backgroundColor = 'rgba(220, 53, 69, 0.15)'; // light red
            console.log("Set risk card to red");
        } else {
            cardElement.style.backgroundColor = 'rgba(255, 193, 7, 0.15)'; // light yellow for Moderate
            console.log("Set risk card to yellow");
        }
    }
    
    // Initial update
    updateRiskCardColor();
    
    // Create a separate observer for risk
    const riskObserver = new MutationObserver(function() {
        console.log("Risk observer triggered");
        updateRiskCardColor();
    });
    
    // Start observing
    riskObserver.observe(volatilityElement, { 
        childList: true, 
        characterData: true,
        subtree: true 
    });
    
    console.log("Risk monitoring setup complete");
}

// 2. DRAWDOWN MONITORING
function setupDrawdownMonitoring(drawdownElement) {
    console.log("Setting up drawdown monitoring");
    
    // Find the drawdown card element
    const drawdownCard = findParentCard('max-drawdown');
    
    if (drawdownCard) {
        setupDrawdownObserver(drawdownElement, drawdownCard);
    } else {
        console.error("Could not find parent card for drawdown");
    }
}

function setupDrawdownObserver(drawdownElement, cardElement) {
    function updateDrawdownCardColor() {
        const drawdownText = drawdownElement.innerText || drawdownElement.textContent;
        console.log("Drawdown text:", drawdownText);
        
        const cleanText = drawdownText.replace(/[^\d.-]/g, '');
        const drawdownValue = parseFloat(cleanText);
        
        if (isNaN(drawdownValue)) {
            console.error("Could not parse a valid number from drawdown text");
            return;
        }
        
        console.log("Drawdown value:", drawdownValue);
        
        if (drawdownValue <= -15) {
            cardElement.style.backgroundColor = '#ffe6e6'; // Light red
            console.log("Set drawdown card to red");
        } else {
            cardElement.style.backgroundColor = '#e6f7e6'; // Light green
            console.log("Set drawdown card to green");
        }
    }
    
    // Initial update
    updateDrawdownCardColor();
    
    // Create a separate observer for drawdown
    const drawdownObserver = new MutationObserver(function() {
        console.log("Drawdown observer triggered");
        updateDrawdownCardColor();
    });
    
    // Start observing
    drawdownObserver.observe(drawdownElement, { 
        childList: true, 
        characterData: true,
        subtree: true 
    });
    
    console.log("Drawdown monitoring setup complete");
}

// 3. PORTFOLIO RETURN MONITORING (FOR BOTH PORTFOLIO VALUE AND TOTAL RETURN CARDS)
function setupReturnMonitoring(annualizedReturnElement) {
    console.log("Setting up annualized return monitoring");
    
    // Find both card elements
    const portfolioValueCard = findParentCard('final-value');
    const totalReturnCard = findParentCard('total-return');
    
    if (!portfolioValueCard) {
        console.error("Could not find portfolio value card");
    }
    
    if (!totalReturnCard) {
        console.error("Could not find total return card");
    }
    
    // Set up the monitoring if at least one card was found
    if (portfolioValueCard || totalReturnCard) {
        setupReturnObserver(annualizedReturnElement, portfolioValueCard, totalReturnCard);
    }
}

function setupReturnObserver(annualizedReturnElement, portfolioValueCard, totalReturnCard) {
    function updateReturnCards() {
        const returnText = annualizedReturnElement.innerText || annualizedReturnElement.textContent;
        console.log("Annualized return text:", returnText);
        
        // Extract the percentage value (looking for a number followed by % per year)
        const matches = returnText.match(/(-?\d+\.?\d*)%/);
        if (!matches || matches.length < 2) {
            console.error("Could not parse annualized return percentage");
            return;
        }
        
        const annualizedReturnValue = parseFloat(matches[1]);
        console.log("Parsed annualized return value:", annualizedReturnValue);
        
        // Apply the appropriate background color based on the threshold
        if (annualizedReturnValue >= 6) {
            console.log("Setting cards to green (>= 6%)");
            if (portfolioValueCard) portfolioValueCard.style.backgroundColor = '#e6f7e6'; // Light green
            if (totalReturnCard) totalReturnCard.style.backgroundColor = '#e6f7e6'; // Light green
        } else {
            console.log("Setting cards to red (< 6%)");
            if (portfolioValueCard) portfolioValueCard.style.backgroundColor = '#ffe6e6'; // Light red
            if (totalReturnCard) totalReturnCard.style.backgroundColor = '#ffe6e6'; // Light red
        }
    }
    
    // Initial update
    updateReturnCards();
    
    // Create an observer for the annualized return
    const returnObserver = new MutationObserver(function() {
        console.log("Annualized return observer triggered");
        updateReturnCards();
    });
    
    // Start observing
    returnObserver.observe(annualizedReturnElement, { 
        childList: true, 
        characterData: true,
        subtree: true 
    });
    
    console.log("Annualized return monitoring setup complete");
}

// Initialize all monitors when the page loads
window.addEventListener('load', function() {
    console.log("Window loaded, setting up all monitors");
    
    // 1. Set up risk/volatility monitoring
    waitForElement('volatility', setupRiskMonitoring, 100, 10000);
    
    // 2. Set up maximum drawdown monitoring
    waitForElement('max-drawdown', setupDrawdownMonitoring, 100, 10000);
    
    // 3. Set up return monitoring (for both portfolio value and total return cards)
    waitForElement('annualized-return', setupReturnMonitoring, 100, 10000);
});


        /////
        
        // Function to fetch date range from API
        function fetchDateRange() {
            fetch(API_DATE_RANGE)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    minDate = new Date(data.min_date);
                    maxDate = new Date(data.max_date);
                    
                    // Set default selected dates to max range
                    selectedStartDate = minDate;
                    selectedEndDate = maxDate;
                    
                    // Display date range text initially
                    updateDateRangeDisplay();
                    
                    // Display ETF returns if needed
                    const etfReturns = data.etf_returns;
                    for (const etf in etfReturns) {
                        const returnEl = document.getElementById(`${etf.toLowerCase()}-return`);
                        if (returnEl) {
                            returnEl.textContent = `${etfReturns[etf].toFixed(2)}%`;
                        }
                    }
                    
                    // Now that we have the date range, trigger the initial calculation
                    calculateAndFetchResults();
                })
                .catch(error => {
                    showApiError(`Failed to fetch date range: ${error.message}`);
                });
        }

        // Function to initialize time period buttons
        function initializeTimePeriodButtons() {
            const buttons = document.querySelectorAll('.time-btn');
            
            buttons.forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all buttons
                    buttons.forEach(btn => btn.classList.remove('active'));
                    
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Get the selected period
                    const period = this.getAttribute('data-period');
                    
                    // Calculate start and end dates based on the period
                    if (period === 'MAX') {
                        selectedStartDate = minDate;
                        selectedEndDate = maxDate;
                    } else {
                        selectedEndDate = new Date(maxDate); // Use a copy of maxDate
                        selectedStartDate = calculateStartDate(period);
                    }
                    
                    // Update the date range display
                    updateDateRangeDisplay();
                    
                    // If allocations are valid, trigger calculation
                    if (checkAllocation()) {
                        calculateAndFetchResults();
                    }
                });
            });
        }

        // Function to calculate start date based on period
        function calculateStartDate(period) {
        const endDate = new Date(selectedEndDate);
        const startDate = new Date(endDate);
        
        switch (period) {
            case '1M':
                startDate.setMonth(endDate.getMonth() - 1);
                break;
            case '6M':
                startDate.setMonth(endDate.getMonth() - 6);
                break;
            case '1Y':
                startDate.setFullYear(endDate.getFullYear() - 1);
                break;
            case '3Y':
                startDate.setFullYear(endDate.getFullYear() - 3);
                break;
            case '5Y':
                startDate.setFullYear(endDate.getFullYear() - 5);
                break;
            default:
                startDate = new Date(minDate);
        }
        
        // Ensure the start date is not earlier than the minimum available date
        if (startDate < minDate) {
            startDate = new Date(minDate);
        }
        
        return startDate;
        }

        // Function to update the date range display
        function updateDateRangeDisplay() {
        const dateDisplay = document.getElementById('date-range-display');
        dateDisplay.textContent = `From ${formatDate(selectedStartDate)} to ${formatDate(selectedEndDate)}`;
        }

        // Function to initialize allocation sliders
        function initializeAllocationSliders() {
            const spySlider = document.getElementById('spy-allocation');
            const bndSlider = document.getElementById('bnd-allocation');
            const vtipSlider = document.getElementById('vtip-allocation');
            const vxusSlider = document.getElementById('vxus-allocation');
            
            const spyValue = document.getElementById('spy-value');
            const bndValue = document.getElementById('bnd-value');
            const vtipValue = document.getElementById('vtip-value');
            const vxusValue = document.getElementById('vxus-value');
            
            spySlider.addEventListener('input', function() {
                spyValue.textContent = `${spySlider.value}%`;
                checkAllocation();
            });
            
            bndSlider.addEventListener('input', function() {
                bndValue.textContent = `${bndSlider.value}%`;
                checkAllocation();
            });
            
            vtipSlider.addEventListener('input', function() {
                vtipValue.textContent = `${vtipSlider.value}%`;
                checkAllocation();
            });
            
            vxusSlider.addEventListener('input', function() {
                vxusValue.textContent = `${vxusSlider.value}%`;
                checkAllocation();
            });
        }
        
        // Function to check if allocations sum to 100%
        function checkAllocation() {
            const spyValue = parseInt(document.getElementById('spy-allocation').value);
            const bndValue = parseInt(document.getElementById('bnd-allocation').value);
            const vtipValue = parseInt(document.getElementById('vtip-allocation').value);
            const vxusValue = parseInt(document.getElementById('vxus-allocation').value);
            
            const total = spyValue + bndValue + vtipValue + vxusValue;
            const warningEl = document.getElementById('allocation-warning');
            
            if (total !== 100) {
                warningEl.textContent = `Total allocation: ${total}% (should be 100%)`;
                return false;
            } else {
                warningEl.textContent = '';
                return true;
            }
        }
        
        // Function to initialize tabs
        function initializeTabs() {
            const tabs = document.querySelectorAll('.tab');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    
                    // Remove active class from all tabs and tab content
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    this.classList.add('active');
                    document.getElementById(tabId).classList.add('active');
                    
                    // Re-render charts when tab becomes visible to fix layout issues
                    setTimeout(() => {
                        if (tabId === 'growth' && portfolioData) {
                            // Use the new comparison chart instead of the old growth chart
                            createPortfolioAgainstSpyChart(portfolioData, portfolioData);
                        } else if (tabId === 'drawdown' && portfolioData) {
                            createDrawdownChart(portfolioData);
                        } else if (tabId === 'comparison' && portfolioData) {
                            createComparisonChart(portfolioData, etfPerformance);
                        } else if (tabId === 'yearly' && yearlyReturns) {
                            createYearlyReturnsChart(yearlyReturns);
                        }
                    }, 50);
                });
            });
        }

        // Helper function to get current allocations
        function getCurrentAllocations() {
            return {
                'SPY': parseInt(document.getElementById('spy-allocation').value),
                'BND': parseInt(document.getElementById('bnd-allocation').value),
                'VTIP': parseInt(document.getElementById('vtip-allocation').value),
                'VXUS': parseInt(document.getElementById('vxus-allocation').value)
            };
        }
        
        // Function to calculate and fetch results from API
        function calculateAndFetchResults() {
            // Check if allocations are valid
            if (!checkAllocation()) {
                alert('Total allocation must be 100%. Please adjust your allocations.');
                return;
            }
            
            // Get input values
            const initialInvestment = parseFloat(document.getElementById('initial-investment').value);
            const spyAllocation = parseInt(document.getElementById('spy-allocation').value);
            const bndAllocation = parseInt(document.getElementById('bnd-allocation').value);
            const vtipAllocation = parseInt(document.getElementById('vtip-allocation').value);
            const vxusAllocation = parseInt(document.getElementById('vxus-allocation').value);
            
            // Use the selected date range
            const startDate = formatDateForAPI(selectedStartDate);
            const endDate = formatDateForAPI(selectedEndDate);
            
            // Prepare API request payload
            const payload = {
                initial_investment: initialInvestment,
                allocations: {
                    'SPY': spyAllocation,
                    'BND': bndAllocation,
                    'VTIP': vtipAllocation,
                    'VXUS': vxusAllocation
                },
                start_date: startDate,
                end_date: endDate
            };
            
            // Show loading state
            document.querySelectorAll('.loading').forEach(el => {
                el.style.display = 'block';
            });
            
            // Clear any previous error messages
            hideApiError();
            
            // Fetch all data at once
            fetchAllData(payload);
        }

        // Helper function to format dates for API (YYYY-MM-DD)
        function formatDateForAPI(date) {
            if (!date) return null;
            
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            
            return `${year}-${month}-${day}`;
        }
        
        // Function to fetch all data from the API
        function fetchAllData(payload) {
            // Use the calculate-all endpoint
            fetch(API_CALCULATE_ALL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        try {
                            const err = JSON.parse(text);
                            throw new Error(err.error || `HTTP error! Status: ${response.status}`);
                        } catch(e) {
                            throw new Error(`HTTP error! Status: ${response.status}, Body: ${text.substring(0, 100)}...`);
                        }
                    });
                }
                return response.text().then(text => {
                    // Replace NaN with null in the response to handle JSON parsing issues
                    const cleanedText = text.replace(/NaN/g, 'null');
                    return JSON.parse(cleanedText);
                });
            })
            .then(data => {
                // Store the data
                const metrics = data.metrics;
                portfolioData = data.portfolio_data;
                etfPerformance = data.etf_performance;
                yearlyReturns = data.yearly_returns;
                
                console.log("Data received:", {
                    portfolioDataPoints: portfolioData?.length || 0,
                    etfPerformanceEntries: Object.keys(etfPerformance || {}).length,
                    yearlyReturnsPoints: yearlyReturns?.length || 0
                });
                
                // Update metrics display
                updateMetricsDisplay(metrics, payload.initial_investment);
                
                // We'll use SPY data for comparison - extract it from portfolio data
                // (Since we need the same date range as our portfolio data)
                
                // Create charts - using the new comparison chart instead of growth chart
                createPortfolioAgainstSpyChart(portfolioData, portfolioData); // Use same data source for both
                createDrawdownChart(portfolioData);
                createComparisonChart(portfolioData, etfPerformance);
                createYearlyReturnsChart(yearlyReturns);
                
                // Hide loading indicators
                document.querySelectorAll('.loading').forEach(el => {
                    el.style.display = 'none';
                });
            })
            .catch(error => {
                showApiError(`Failed to fetch portfolio data: ${error.message}`);
                
                // Hide loading indicators
                document.querySelectorAll('.loading').forEach(el => {
                    el.style.display = 'none';
                });
            });
        }

        // Helper function to show API error
        function showApiError(message) {
            const errorEl = document.getElementById('api-error');
            const messageEl = document.getElementById('error-message');
            messageEl.textContent = message;
            errorEl.style.display = 'block';
        }

        // Helper function to hide API error
        function hideApiError() {
            const errorEl = document.getElementById('api-error');
            errorEl.style.display = 'none';
        }

        // Helper function to format date
        function formatDate(date) {
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }
        
        // Function to update metrics display
        function updateMetricsDisplay(metrics, initialInvestment) {
            document.getElementById('final-value').textContent = formatCurrency(metrics.final_value);
            document.getElementById('initial-value').textContent = `Initial: ${formatCurrency(initialInvestment)}`;
            document.getElementById('total-return').textContent = formatPercentage(metrics.total_return);
            document.getElementById('annualized-return').textContent = `Annualized: ${formatPercentage(metrics.annualized_return)} per year`;
            document.getElementById('max-drawdown').textContent = formatPercentage(metrics.max_drawdown);
            document.getElementById('volatility').textContent = `${metrics.risk_level} (${formatPercentage(metrics.volatility)})`;
        }

        // Helper function to format currency
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value);
        }

        // Helper function to format percentage
        function formatPercentage(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'percent',
                minimumFractionDigits: 1,
                maximumFractionDigits: 1
            }).format(value);
        }


        // Function to create portfolio vs SPY comparison chart
        function createPortfolioAgainstSpyChart(portfolioData, spyData) {
            const chartContainer = document.getElementById('portfolio-growth-chart');
            chartContainer.innerHTML = '';
            
            // Check if we have data
            if (!portfolioData || portfolioData.length === 0 || !spyData || spyData.length === 0) {
                chartContainer.innerHTML = '<div class="error">No data available for comparison</div>';
                return;
            }
            
            const margin = {top: 20, right: 80, bottom: 50, left: 80};
            const width = chartContainer.clientWidth - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            const svg = d3.select(chartContainer)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Make sure dates are Date objects
            portfolioData.forEach(d => {
                if (!(d.Date instanceof Date)) {
                    d.Date = new Date(d.Date);
                }
            });
            
            spyData.forEach(d => {
                if (!(d.Date instanceof Date)) {
                    d.Date = new Date(d.Date);
                }
            });
            
            // For comparison, we need to normalize both portfolio and SPY to start at 1
            const portfolioStartValue = portfolioData[0].total_value;
            const spyStartValue = spyData[0].SPY;
            
            // Create normalized data for comparison
            const normalizedPortfolioData = portfolioData.map(d => ({
                Date: d.Date,
                value: d.total_value / portfolioStartValue
            }));
            
            const normalizedSpyData = spyData.map(d => ({
                Date: d.Date,
                value: d.SPY / spyStartValue
            }));
            
            // Get date range for x-axis (use the portfolio data range)
            const dateExtent = d3.extent(portfolioData, d => d.Date);
            
            // Find max value for y-axis scaling
            let maxPortfolioValue = d3.max(normalizedPortfolioData, d => d.value);
            let maxSpyValue = d3.max(normalizedSpyData, d => d.value);
            const maxValue = Math.max(maxPortfolioValue, maxSpyValue);
            
            // X scale
            const x = d3.scaleTime()
                .domain(dateExtent)
                .range([0, width]);
            
            // Y scale with 10% padding
            const y = d3.scaleLinear()
                .domain([0, maxValue * 1.1])
                .range([height, 0]);
            
            // X axis
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(width > 500 ? 10 : 5)
                    .tickFormat(d3.timeFormat('%b %Y')))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            // Y axis
            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y)
                    .tickFormat(d => d3.format('.1f')(d)));
            
            // Grid lines to improve readability
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y)
                    .ticks(10)
                    .tickSize(-width)
                    .tickFormat(''))
                .style('stroke', '#e0e0e0')
                .style('stroke-opacity', 0.7)
                .style('shape-rendering', 'crispEdges');
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -60)
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Value (Normalized)')
                .style('fill', '#666');
            
            // Add chart title
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', -margin.top / 2 + 10)
                .text('Portfolio vs. S&P 500 Performance')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .style('fill', '#2c3e50');
            
            // Colors for lines
            const portfolioColor = '#2c3e50';  // Portfolio in dark blue
            const spyColor = '#1f77b4';        // SPY in lighter blue
            
            // Line generator
            const line = d3.line()
                .x(d => x(d.Date))
                .y(d => y(d.value))
                .curve(d3.curveMonotoneX);
            
            // Draw portfolio line
            svg.append('path')
                .datum(normalizedPortfolioData)
                .attr('class', 'portfolio-line')
                .attr('fill', 'none')
                .attr('stroke', portfolioColor)
                .attr('stroke-width', 3)
                .attr('d', line);
            
            // Draw SPY line
            svg.append('path')
                .datum(normalizedSpyData)
                .attr('class', 'spy-line')
                .attr('fill', 'none')
                .attr('stroke', spyColor)
                .attr('stroke-width', 1.5)
                .attr('stroke-dasharray', '5,5')  // Make SPY line dashed
                .attr('d', line);
            
            // Create tooltip
            const tooltip = d3.select('#tooltip');
            
            // Create a bisector for finding closest data point
            const bisect = d3.bisector(d => d.Date).left;
            
            // Add transparent overlay for mouse interaction
            svg.append('rect')
                .attr('width', width)
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mouseover', () => tooltip.style('opacity', 1))
                .on('mouseout', () => tooltip.style('opacity', 0))
                .on('mousemove', function(event) {
                    // Get mouse x-position in data space
                    const mouseX = d3.pointer(event)[0];
                    const x0 = x.invert(mouseX);
                    
                    // Find closest portfolio data point
                    const i = bisect(normalizedPortfolioData, x0, 1);
                    if (i >= normalizedPortfolioData.length) return;
                    
                    const d0 = normalizedPortfolioData[i - 1];
                    const d1 = normalizedPortfolioData[i];
                    const d = x0 - d0.Date > d1.Date - x0 ? d1 : d0;
                    
                    // Find closest SPY data point
                    const j = bisect(normalizedSpyData, x0, 1);
                    let spyPoint = null;
                    if (j < normalizedSpyData.length) {
                        const s0 = normalizedSpyData[j - 1];
                        const s1 = normalizedSpyData[j];
                        spyPoint = x0 - s0.Date > s1.Date - x0 ? s1 : s0;
                    }
                    
                    // Format date for tooltip
                    const formattedDate = formatDate(d.Date);
                    
                    // Calculate outperformance
                    let outperformanceHTML = '';
                    if (spyPoint) {
                        const diff = d.value - spyPoint.value;
                        const percentDiff = (diff / spyPoint.value) * 100;
                        const diffColor = diff >= 0 ? '#28a745' : '#dc3545';
                        
                        outperformanceHTML = `
                            <div style="margin-top: 8px; padding-top: 5px; border-top: 1px solid #eee;">
                                <span style="color: ${diffColor}; font-weight: bold;">
                                    ${diff >= 0 ? 'Outperforming' : 'Underperforming'} by 
                                    ${Math.abs(percentDiff).toFixed(2)}%
                                </span>
                            </div>
                        `;
                    }
                    
                    // Create tooltip content
                    tooltip.html(`
                        <div style="font-weight: bold; margin-bottom: 5px;">${formattedDate}</div>
                        <div>
                            <span style="display: inline-block; width: 12px; height: 12px; background: ${portfolioColor}; margin-right: 5px;"></span>
                            Portfolio: ${d.value.toFixed(2)}x
                        </div>
                        ${spyPoint ? `
                        <div style="margin-top: 5px;">
                            <span style="display: inline-block; width: 12px; height: 12px; background: ${spyColor}; margin-right: 5px;"></span>
                            S&P 500: ${spyPoint.value.toFixed(2)}x
                        </div>` : ''}
                        ${outperformanceHTML}
                    `)
                    .style('left', (event.pageX + 15) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
                });
            
            // Create legend
            const legend = document.getElementById('growth-legend');
            legend.innerHTML = '';
            
            // Portfolio legend item
            const portfolioLegend = document.createElement('div');
            portfolioLegend.className = 'legend-item';
            
            const portfolioColor1 = document.createElement('div');
            portfolioColor1.className = 'legend-color';
            portfolioColor1.style.backgroundColor = portfolioColor;
            
            const portfolioText = document.createElement('span');
            portfolioText.textContent = 'Your Portfolio';
            
            portfolioLegend.appendChild(portfolioColor1);
            portfolioLegend.appendChild(portfolioText);
            legend.appendChild(portfolioLegend);
            
            // SPY legend item
            const spyLegend = document.createElement('div');
            spyLegend.className = 'legend-item';
            
            const spyColor1 = document.createElement('div');
            spyColor1.className = 'legend-color';
            spyColor1.style.backgroundColor = spyColor;
            
            const spyText = document.createElement('span');
            spyText.textContent = 'S&P 500 (SPY)';
            
            spyLegend.appendChild(spyColor1);
            spyLegend.appendChild(spyText);
            legend.appendChild(spyLegend);
        }


        function createDrawdownChart(portfolioData) {
            const chartContainer = document.getElementById('drawdown-chart');
            chartContainer.innerHTML = '';
            
            // Check container width first
            const containerWidth = chartContainer.clientWidth;
            
            if (containerWidth <= 0) {
                // Wait for the layout to stabilize (e.g., tab becoming visible)
                setTimeout(() => createDrawdownChart(portfolioData), 100);
                return;
            }
            
            // Use smaller margins if container is narrow
            const margin = containerWidth < 400 
                ? {top: 20, right: 30, bottom: 50, left: 40}
                : {top: 20, right: 80, bottom: 50, left: 80};
            
            const width = Math.max(containerWidth - margin.left - margin.right, 100); // Ensure minimum width
            const height = 400 - margin.top - margin.bottom;
            
            const svg = d3.select(chartContainer)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Make sure dates are Date objects
            portfolioData.forEach(d => {
                if (!(d.Date instanceof Date)) {
                    d.Date = new Date(d.Date);
                }
            });
            
            // Calculate domain for drawdown
            const minDrawdown = d3.min(portfolioData, d => d.drawdown);
            
            // X scale
            const x = d3.scaleTime()
                .domain(d3.extent(portfolioData, d => d.Date))
                .range([0, width]);
            
            // Y scale for drawdown (negative values)
            const y = d3.scaleLinear()
                .domain([minDrawdown * 1.1 || -0.1, 0]) // Fallback if minDrawdown is undefined
                .range([height, 0]);
            
            // X axis
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(width > 500 ? 10 : 5)
                    .tickFormat(d3.timeFormat('%b %Y')))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            // Y axis
            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y)
                    .tickFormat(d => `${d3.format('.0%')(d)}`));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -margin.left + 20) // Adjust based on margin
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Drawdown (%)');
            
            // Create the area generator for the area ABOVE the drawdown line (between drawdown and zero)
            const area = d3.area()
                .x(d => x(d.Date))
                .y0(d => y(d.drawdown)) // Bottom of the area is at the drawdown value
                .y1(y(0));              // Top of the area is at zero
            
            // Draw the area ABOVE the drawdown line in red
            svg.append('path')
                .datum(portfolioData)
                .attr('fill', 'rgba(255, 0, 0, 0.3)')
                .attr('d', area);
            
            // Draw the drawdown line
            const line = d3.line()
                .x(d => x(d.Date))
                .y(d => y(d.drawdown));
            
            svg.append('path')
                .datum(portfolioData)
                .attr('fill', 'none')
                .attr('stroke', 'rgb(255, 0, 0)')
                .attr('stroke-width', 2)
                .attr('d', line);
            
            // Add a zero line
            svg.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', y(0))
                .attr('y2', y(0))
                .attr('stroke', '#888')
                .attr('stroke-dasharray', '3,3');
            
            // Create a tooltip for drawdown
            const tooltip = d3.select('#tooltip');
            const bisect = d3.bisector(d => d.Date).left;
            
            svg.append('rect')
                .attr('width', width > 0 ? width : 0) // Ensure width is not negative
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mousemove', function(event) {
                    const mouseX = d3.pointer(event)[0];
                    const x0 = x.invert(mouseX);
                    const i = bisect(portfolioData, x0, 1);
                    if (i >= portfolioData.length) return;
                    const d0 = portfolioData[i - 1];
                    const d1 = portfolioData[i];
                    const d = x0 - d0.Date > d1.Date - x0 ? d1 : d0;
                    
                    tooltip.style('opacity', 1)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <strong>Date:</strong> ${formatDate(d.Date)}<br>
                            <strong>Drawdown:</strong> ${d3.format('.2%')(d.drawdown)}<br>
                            <strong>Peak Value:</strong> ${formatCurrency(d.peak_value)}<br>
                            <strong>Current Value:</strong> ${formatCurrency(d.total_value)}
                        `);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
        }

        // Function to create ETF comparison chart
        function createComparisonChart(portfolioData, etfPerformance) {
            const chartContainer = document.getElementById('etf-comparison-chart');
            chartContainer.innerHTML = '';
            
            // Debug logging
            console.log("ETF Comparison - Portfolio Data:", portfolioData);
            console.log("ETF Performance:", etfPerformance);
            
            // Check if we have the required data
            if (!portfolioData || !etfPerformance || portfolioData.length === 0) {
                chartContainer.innerHTML = '<div class="error">No ETF comparison data available</div>';
                console.error("Missing portfolio data or ETF performance data");
                return;
            }
            
            // Check container width
            const containerWidth = chartContainer.clientWidth;
            if (containerWidth <= 0) {
                setTimeout(() => createComparisonChart(portfolioData, etfPerformance), 100);
                return;
            }
            
            const margin = {top: 20, right: 80, bottom: 50, left: 80};
            const width = Math.max(containerWidth - margin.left - margin.right, 100);
            const height = 400 - margin.top - margin.bottom;
            
            const svg = d3.select(chartContainer)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Make sure dates are Date objects
            portfolioData.forEach(d => {
                if (!(d.Date instanceof Date)) {
                    d.Date = new Date(d.Date);
                }
            });
            
            // Get list of ETFs in the performance data
            const etfs = Object.keys(etfPerformance);
            console.log("ETFs:", etfs);
            
            if (etfs.length === 0) {
                chartContainer.innerHTML = '<div class="error">No ETF data found in performance data</div>';
                return;
            }
            
            // Process data to get normalized returns for each ETF
            // First, check what normalization fields are available
            const sampleEntry = portfolioData[0];
            const normFields = etfs.map(etf => `${etf}_norm`).filter(field => field in sampleEntry);
            console.log("Available normalization fields:", normFields);
            
            // If we don't have normalization fields, calculate from raw data
            let normalizedData;
            
            if (normFields.length === etfs.length) {
                console.log("Using existing normalization fields");
                // Use existing normalization data
                normalizedData = portfolioData.map(d => {
                    const result = { Date: d.Date };
                    etfs.forEach(etf => {
                        const normField = `${etf}_norm`;
                        if (normField in d && !isNaN(d[normField])) {
                            result[etf] = ((d[normField]) - 1) * 100;
                        }
                    });
                    return result;
                });
            } else {
                console.log("Calculating normalization manually");
                // Manually calculate normalization
                const firstDayValues = {};
                etfs.forEach(etf => {
                    if (etf in portfolioData[0]) {
                        firstDayValues[etf] = portfolioData[0][etf];
                    }
                });
                
                console.log("First day values:", firstDayValues);
                
                normalizedData = portfolioData.map(d => {
                    const result = { Date: d.Date };
                    etfs.forEach(etf => {
                        if (etf in d && etf in firstDayValues && !isNaN(d[etf]) && firstDayValues[etf] > 0) {
                            result[etf] = ((d[etf] / firstDayValues[etf]) - 1) * 100;
                        }
                    });
                    return result;
                });
            }
            
            console.log("Normalized data sample:", normalizedData.slice(0, 3));
            
            // Check if we have valid data after normalization
            const validEtfs = etfs.filter(etf => 
                normalizedData.some(d => etf in d && !isNaN(d[etf]))
            );
            
            console.log("Valid ETFs after normalization:", validEtfs);
            
            if (validEtfs.length === 0) {
                chartContainer.innerHTML = '<div class="error">No valid ETF data after normalization</div>';
                return;
            }
            
            // X scale
            const x = d3.scaleTime()
                .domain(d3.extent(normalizedData, d => d.Date))
                .range([0, width]);
            
            // Find min and max values across all ETFs
            const allValues = [];
            normalizedData.forEach(d => {
                validEtfs.forEach(etf => {
                    if (etf in d && !isNaN(d[etf])) {
                        allValues.push(d[etf]);
                    }
                });
            });
            
            const minValue = d3.min(allValues) || -5;
            const maxValue = d3.max(allValues) || 5;
            
            console.log("Value range:", {minValue, maxValue});
            
            // Y scale with some padding
            const y = d3.scaleLinear()
                .domain([Math.min(minValue, -5), Math.max(maxValue, 5) * 1.05])
                .range([height, 0]);
            
            // X axis
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(width > 500 ? 10 : 5)
                    .tickFormat(d3.timeFormat('%b %Y')))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            // Y axis
            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y)
                    .tickFormat(d => `${d3.format('.0f')(d)}%`));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -60)
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Return (%)');
            
            // Add a zero line
            svg.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', y(0))
                .attr('y2', y(0))
                .attr('stroke', '#888')
                .attr('stroke-dasharray', '3,3');
            
            // Colors for ETFs
            const colors = {
                'SPY': '#00897B',
                'BND': '#3F51B5',
                'VTIP': '#FF9800',
                'VXUS': '#E91E63'
            };
            
            // Create line generator
            const line = d3.line()
                .x(d => x(d.Date))
                .y(d => y(d.value))
                .defined(d => !isNaN(d.value));
            
            // Create lines for each ETF
            validEtfs.forEach(etf => {
                const etfData = normalizedData
                    .map(d => ({
                        Date: d.Date,
                        value: d[etf]
                    }))
                    .filter(d => d.value !== undefined && !isNaN(d.value));
                
                if (etfData.length > 1) {
                    svg.append('path')
                        .datum(etfData)
                        .attr('fill', 'none')
                        .attr('stroke', colors[etf] || '#999')
                        .attr('stroke-width', 2)
                        .attr('d', line);
                } else {
                    console.warn(`Not enough valid data points for ETF: ${etf}`);
                }
            });
            
            // Create a tooltip for comparison
            const tooltip = d3.select('#tooltip');
            const bisect = d3.bisector(d => d.Date).left;
            
            svg.append('rect')
                .attr('width', width > 0 ? width : 0)
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mousemove', function(event) {
                    const mouseX = d3.pointer(event)[0];
                    const x0 = x.invert(mouseX);
                    const i = bisect(normalizedData, x0, 1);
                    if (i >= normalizedData.length) return;
                    const d0 = normalizedData[i - 1];
                    const d1 = normalizedData[i];
                    const d = x0 - d0.Date > d1.Date - x0 ? d1 : d0;
                    
                    const tooltipContent = `<strong>Date:</strong> ${formatDate(d.Date)}<br>` + 
                        validEtfs.map(etf => {
                            if (etf in d && !isNaN(d[etf])) {
                                return `<strong>${etf}:</strong> ${d[etf].toFixed(2)}%`
                            }
                            return '';
                        }).filter(s => s !== '').join('<br>');
                    
                    tooltip.style('opacity', 1)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(tooltipContent);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
            
            // Create the legend
            const legend = document.getElementById('comparison-legend');
            legend.innerHTML = '';
            
            validEtfs.forEach(etf => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = colors[etf] || '#999';
                
                const text = document.createElement('span');
                text.textContent = etf;
                
                item.appendChild(colorBox);
                item.appendChild(text);
                legend.appendChild(item);
            });
            
            console.log("ETF comparison chart created successfully");
        }







        // Function to create yearly returns chart
        function createYearlyReturnsChart(yearlyReturns) {
    const chartContainer = document.getElementById('yearly-returns-chart');
    chartContainer.innerHTML = '';
    
    // Debug logging
    console.log("Yearly Returns Data:", yearlyReturns);
    
    // Check if we have the required data
    if (!yearlyReturns || yearlyReturns.length === 0) {
        chartContainer.innerHTML = '<div class="error">No yearly returns data available</div>';
        console.error("Missing yearly returns data");
        return;
    }
    
    // Check container width
    const containerWidth = chartContainer.clientWidth;
    if (containerWidth <= 0) {
        setTimeout(() => createYearlyReturnsChart(yearlyReturns), 100);
        return;
    }
    
    const margin = {top: 20, right: 80, bottom: 50, left: 80};
    const width = Math.max(containerWidth - margin.left - margin.right, 100);
    const height = 400 - margin.top - margin.bottom;
    
    const svg = d3.select(chartContainer)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
    
    // Filter out invalid data
    const validReturns = yearlyReturns.filter(d => 
        d.year !== undefined && 
        d.yearly_return !== undefined && 
        !isNaN(d.yearly_return)
    );
    
    console.log("Valid yearly returns:", validReturns);
    
    if (validReturns.length === 0) {
        chartContainer.innerHTML = '<div class="error">No valid yearly returns data</div>';
        return;
    }
    
    // Make sure years are parsed as numbers
    validReturns.forEach(d => {
        if (typeof d.year === 'string') {
            d.year = parseInt(d.year, 10);
        }
    });
    
    // Sort by year
    validReturns.sort((a, b) => a.year - b.year);
    
    // X scale
    const x = d3.scaleBand()
        .domain(validReturns.map(d => d.year))
        .range([0, width])
        .padding(0.2);
    
    // Find min and max values
    const minReturnValue = d3.min(validReturns, d => d.yearly_return) * 100;
    const maxReturnValue = d3.max(validReturns, d => d.yearly_return) * 100;
    
    console.log("Value range:", {minReturnValue, maxReturnValue});
    
    // Y scale - set minimum to at least -15%
    const yMin = Math.min(minReturnValue, -20); // Ensure y-axis goes down to at least -20%
    const yMax = Math.max(maxReturnValue, 5);   // Ensure y-axis goes up to at least 5%
    
    const y = d3.scaleLinear()
        .domain([yMin, yMax])
        .range([height, 0]);
    
    // X axis
    svg.append('g')
        .attr('class', 'axis')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x)
            .tickFormat(d => d.toString()));
    
    // Y axis with tick at -15%
    svg.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(y)
            .tickFormat(d => `${d3.format('.0f')(d)}%`)
            .tickValues([-20, -15, -10, -5, 0, 5, 10, 15, 20, 25, 30].filter(v => v >= yMin && v <= yMax))
        );
    
    // Add Y axis label
    svg.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('y', -60)
        .attr('x', -height / 2)
        .attr('text-anchor', 'middle')
        .text('Return (%)');
    
    // Add a zero line
    svg.append('line')
        .attr('x1', 0)
        .attr('x2', width)
        .attr('y1', y(0))
        .attr('y2', y(0))
        .attr('stroke', '#888')
        .attr('stroke-dasharray', '3,3');
    
    // Create bars
    svg.selectAll('.bar')
        .data(validReturns)
        .enter()
        .append('rect')
        .attr('class', 'bar')
        .attr('x', d => x(d.year))
        .attr('width', x.bandwidth())
        .attr('y', d => d.yearly_return >= 0 ? y(d.yearly_return * 100) : y(0))
        .attr('height', d => Math.abs(y(d.yearly_return * 100) - y(0)))
        .attr('fill', d => d.yearly_return >= 0 ? 'rgb(0, 153, 76)' : 'rgb(204, 0, 0)');
    
    // Add text labels to bars
    svg.selectAll('.label')
        .data(validReturns)
        .enter()
        .append('text')
        .attr('class', 'label')
        .attr('x', d => x(d.year) + x.bandwidth() / 2)
        .attr('y', d => d.yearly_return >= 0 ? y(d.yearly_return * 100) - 5 : y(d.yearly_return * 100) + 15)
        .attr('text-anchor', 'middle')
        .attr('fill', d => d.yearly_return >= 0 ? 'black' : 'black')
        .text(d => `${(d.yearly_return * 100).toFixed(1)}%`);
    
    // Create a tooltip for yearly returns
    const tooltip = d3.select('#tooltip');
    
    svg.selectAll('.bar')
        .on('mouseover', function(event, d) {
            tooltip.style('opacity', 1)
                .style('left', (event.pageX + 15) + 'px')
                .style('top', (event.pageY - 28) + 'px')
                .html(`
                    <strong>Year:</strong> ${d.year}<br>
                    <strong>Return:</strong> ${(d.yearly_return * 100).toFixed(2)}%
                `);
        })
        .on('mouseout', function() {
            tooltip.style('opacity', 0);
        });
    
    console.log("Yearly returns chart created successfully");
}





        
        // Helper function to show API error
        function showApiError(message) {
            const errorEl = document.getElementById('api-error');
            const messageEl = document.getElementById('error-message');
            messageEl.textContent = message;
            errorEl.style.display = 'block';
        }
        
        // Helper function to hide API error
        function hideApiError() {
            const errorEl = document.getElementById('api-error');
            errorEl.style.display = 'none';
        }
        
        // Helper function to format currency
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value);
        }
        
        // Helper function to format percentage
        function formatPercentage(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'percent',
                minimumFractionDigits: 1,
                maximumFractionDigits: 1
            }).format(value);
        }
        
        // Helper function to format date
        function formatDate(date) {
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }
    </script>
</body>
</html>