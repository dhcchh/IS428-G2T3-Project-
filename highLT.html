<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Risk Long-Term Investment Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js" charset="utf-8"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .header h5 {
            margin-top: 0;
            color: #7f8c8d;
        }
        .dashboard {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .controls h3 {
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric-card {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
        }
        .metric-card h3 {
            margin: 10px 0;
            font-size: 1.8rem;
        }
        .metric-card p {
            margin: 0;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        .charts {
            display: grid;
            grid-template-rows: auto;
            gap: 20px;
        }
        .chart-container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .chart-container h3 {
            margin-top: 0;
            margin-bottom: 20px;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        input[type="range"] {
            width: 100%;
        }
        .allocation-display {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
        }
        button {
            width: 100%;
            padding: 10px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 20px;
        }
        button:hover {
            background-color: #2980b9;
        }
        .tab-container {
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .tab.active {
            border-bottom-color: #3498db;
            font-weight: 500;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .warning {
            color: #e74c3c;
            margin-top: 5px;
            font-size: 0.9rem;
        }
        .axis line, .axis path {
            stroke: #ddd;
        }
        .axis text {
            fill: #666;
            font-size: 0.8rem;
        }
        .notes {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        .notes h5 {
            margin-top: 0;
        }
        .notes ul {
            padding-left: 20px;
        }
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 2px;
        }
        .api-error {
            background-color: #fee;
            color: #e74c3c;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        /* CSS for the time period buttons */
        .time-period-buttons {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
        }

        .time-btn {
            flex: 1;
            padding: 8px 0;
            margin: 0 4px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .time-btn:first-child {
            margin-left: 0;
        }

        .time-btn:last-child {
            margin-right: 0;
        }

        .time-btn:hover {
            background-color: #e9ecef;
        }

        .time-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        /* Additional CSS for Portfolio vs SPY comparison */
        .portfolio-line {
            stroke-width: 3px;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .spy-line {
            stroke-width: 2px;
            stroke-dasharray: 5, 5;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .outperformance-positive {
            color: #28a745;
            font-weight: bold;
        }

        .outperformance-negative {
            color: #dc3545;
            font-weight: bold;
        }

        .grid line {
            stroke: #e0e0e0;
            stroke-opacity: 0.7;
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }
        .loading:after {
            content: '...';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        .tooltip-trigger {
            position: relative;
            display: inline-flex;
            margin-left: 5px;
            cursor: help;
        }

        .tooltip-trigger .info-icon {
            width: 16px;
            height: 16px;
        }

        .tooltip-trigger:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 100%;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            width: 250px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            font-weight: normal;
            line-height: 1.4;
        }

        .tooltip-trigger:hover::before {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 100%;
            border: 8px solid transparent;
            border-top-color: #333;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>High Risk Long-Term Investment Dashboard</h1>
            <h5>Time in the Market Beats Timing the Market</h5>
        </div>
        
        <div id="api-error" class="api-error">
            <strong>Error connecting to API:</strong> <span id="error-message"></span>
        </div>
        
        <div class="dashboard">
            <div class="controls">
                <h3>Investment Parameters</h3>
                
        <!-- HTML for time period buttons -->
        <div class="control-group">
            <label>Investment Period:</label>
            <div class="time-period-buttons">
                <button class="time-btn" data-period="1M">1M</button>
                <button class="time-btn" data-period="6M">6M</button>
                <button class="time-btn" data-period="1Y">1Y</button>
                <button class="time-btn" data-period="3Y">3Y</button>
                <button class="time-btn" data-period="5Y">5Y</button>
                <button class="time-btn active" data-period="MAX">Max</button>
            </div>
            <div id="date-range-display" style="text-align: center; margin-top: 10px; display: none;">Loading date range...</div>
        </div>
                
                <div class="control-group">
                    <label>Initial Investment (USD):</label>
                    <input type="number" id="initial-investment" min="1000" max="1000000" step="1000" value="10000">
                    <small style="color: #7f8c8d;">Min: $1,000 - Max: $1,000,000</small>
                </div>
                
                <div class="control-group">
                    <label>Portfolio Allocation:</label>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>SPY - S&P 500</span>
                            <span id="spy-value">25%</span>
                        </div>
                        <input type="range" id="spy-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>GBTC - Bitcoin Trust</span>
                            <span id="gbtc-value">25%</span>
                        </div>
                        <input type="range" id="gbtc-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>BRK-B - Berkshire Hathaway</span>
                            <span id="brkb-value">25%</span>
                        </div>
                        <input type="range" id="brkb-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>VUG - Growth ETF</span>
                            <span id="vug-value">25%</span>
                        </div>
                        <input type="range" id="vug-allocation" min="0" max="100" step="5" value="25">
                    </div>
                    
                    <div id="allocation-warning" class="warning"></div>
                </div>
                
                <button id="calculate-button">Calculate Returns</button>
            </div>
            
            <div class="content">
                <div class="metrics">
                    <div class="metric-card">
                        <h4>Final Portfolio Value</h4>
                        <h3 id="final-value">$0.00</h3>
                        <p id="initial-value">Initial: $0.00</p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>Total Return
                            <span class="tooltip-trigger" data-tooltip="The total growth rate of your investment">
                                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="total-return">0.0%</h3>
                        <p id="annualized-return">
                            Annualized: 0.0% per year
                        </p>
                    </div>
                    
                    <div class="metric-card">
                        <h4>
                            Maximum Drawdown
                            <span class="tooltip-trigger" data-tooltip="The percentage drop from your investment's highest value to its lowest point during a specific period. Shows potential losses you might face before recovery.">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="max-drawdown">0.0%</h3>
                        <p>Largest decline from peak</p>
                    </div>
                    
                    <div class="metric-card" id="risk-card">
                        <h4>
                            Risk Level
                            <span class="tooltip-trigger" data-tooltip="Measures how dramatically an investment's price changes over time. Higher volatility means bigger price swings both up and down.">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="info-icon">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </span>
                        </h4>
                        <h3 id="volatility">Low (0.0%)</h3>
                        <p>Portfolio volatility</p>
                    </div>   
                </div>
                
                <div class="tab-container">
                    <ul class="tabs">
                        <li class="tab active" data-tab="growth">Portfolio vs S&P500</li>
                        <li class="tab" data-tab="drawdown">Drawdown Analysis</li>
                        <li class="tab" data-tab="comparison">ETF Comparison</li>
                        <li class="tab" data-tab="yearly">Yearly Returns</li>
                        <!-- Mavis & Angela -->
                        <li class="tab" data-tab="company">Company Weightage</li>
                        <li class="tab" data-tab="industry">Industry Weightage</li>
                    </ul>
                </div>
                
                <div class="charts">
                    <div id="growth" class="tab-content active">
                        <div class="chart-container">
                            <div id="portfolio-growth-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="growth-legend"></div>
                        </div>
                    </div>
                    
                    <div id="drawdown" class="tab-content">
                        <div class="chart-container">
                            <h3>Portfolio Drawdown Analysis</h3>
                            <div id="drawdown-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="comparison" class="tab-content">
                        <div class="chart-container">
                            <h3>ETF Performance Comparison</h3>
                            <div id="etf-comparison-chart">
                                <div class="loading">Loading data</div>
                            </div>
                            <div class="legend" id="comparison-legend"></div>
                        </div>
                    </div>
                    
                    <div id="yearly" class="tab-content">
                        <div class="chart-container">
                            <h3>Yearly Portfolio Returns</h3>
                            <div id="yearly-returns-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>

                    <!-- Mavis -->
                    <div id="company" class="tab-content">
                        <div class="chart-container">
                            <h3>ETF Company Weightage</h3>
                            <div id="company-weightage-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>

                    <!-- Angela -->
                    <div id="industry" class="tab-content">
                        <div class="chart-container">
                            <h3>Industry Weightage</h3>
                            <div id="industry-weightage-chart">
                                <div class="loading">Loading data</div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <!-- Add a tooltip div -->
    <div id="tooltip" class="tooltip"></div>

    <script>
        // API URLs
        const API_BASE_URL = 'http://localhost:5000';
        const API_DATE_RANGE = `${API_BASE_URL}/api/date-range`;
        const API_PORTFOLIO_VALUE = `${API_BASE_URL}/api/portfolio-value`;
        const API_TOTAL_RETURN = `${API_BASE_URL}/api/total-return`;
        const API_MAX_DRAWDOWN = `${API_BASE_URL}/api/max-drawdown`;
        const API_RISK_LEVEL = `${API_BASE_URL}/api/risk-level`;
        const API_PORTFOLIO_GROWTH = `${API_BASE_URL}/api/portfolio-growth`;
        const API_DRAWDOWN_ANALYSIS = `${API_BASE_URL}/api/drawdown-analysis`;
        const API_ETF_COMPARISON = `${API_BASE_URL}/api/etf-comparison`;
        const API_YEARLY_RETURNS = `${API_BASE_URL}/api/yearly-returns`;
        const API_CALCULATE_ALL = `${API_BASE_URL}/api/calculate-all`;
        

        // Global variables
        let minDate, maxDate;
        let selectedStartDate, selectedEndDate;
        let portfolioData = null;
        let drawdownData = null;
        let etfPerformance = null;
        let yearlyReturns = null;
        
        // Main application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize tooltips
            const tooltip = d3.select('#tooltip');
            
            // Initialize date range
            fetchDateRange();
            
            // Initialize allocation sliders
            initializeAllocationSliders();
            
            // Set up tabs
            initializeTabs();
            
            // Set up time period buttons
            initializeTimePeriodButtons();
            
            // Set up calculate button
            document.getElementById('calculate-button').addEventListener('click', function() {
                calculateAndFetchResults();
            });
            
            setTimeout(() => {
                createCompanyWeightageChart();
            }, 500);
            // Initial calculation will be triggered after date range is fetched
        });

        /////


        // Utility function to wait for elements to exist in the DOM
function waitForElement(elementId, callback, checkFrequencyInMs, timeoutInMs) {
    var startTimeInMs = Date.now();
    var checkElementAndCallback = function() {
        var element = document.getElementById(elementId);
        if (element) {
            console.log(elementId + " element found!");
            callback(element);
            return;
        }
        
        if (timeoutInMs && Date.now() - startTimeInMs > timeoutInMs) {
            console.log(elementId + " element not found within timeout period");
            return;
        }
        
        setTimeout(checkElementAndCallback, checkFrequencyInMs);
    };
    
    checkElementAndCallback();
}

// Helper function to find the parent metric card of an element
function findParentCard(elementId) {
    const element = document.getElementById(elementId);
    if (!element) {
        console.log("Element with ID " + elementId + " not found");
        return null;
    }
    
    // Find parent metric card
    const parentCard = element.closest('.metric-card');
    if (parentCard) {
        console.log("Found parent card for " + elementId);
        return parentCard;
    } else {
        console.log("Could not find parent card for " + elementId);
        return null;
    }
}

// 1. RISK/VOLATILITY MONITORING
function setupRiskMonitoring(volatilityElement) {
    console.log("Setting up risk/volatility monitoring");
    
    // Find the risk card element
    const riskCard = findParentCard('volatility');
    
    if (riskCard) {
        setupRiskObserver(volatilityElement, riskCard);
    } else {
        console.error("Could not find parent card for volatility");
    }
}

function setupRiskObserver(volatilityElement, cardElement) {
    function updateRiskCardColor() {
        const volatilityText = volatilityElement.innerText || volatilityElement.textContent;
        console.log("Volatility text:", volatilityText);
        
        if (volatilityText.includes('Very Low') || volatilityText.includes('Low')) {
            cardElement.style.backgroundColor = 'rgba(40, 167, 69, 0.15)'; // light green
            console.log("Set risk card to green");
        } else if (volatilityText.includes('High') || volatilityText.includes('Very High')) {
            cardElement.style.backgroundColor = 'rgba(220, 53, 69, 0.15)'; // light red
            console.log("Set risk card to red");
        } else {
            cardElement.style.backgroundColor = 'rgba(255, 193, 7, 0.15)'; // light yellow for Moderate
            console.log("Set risk card to yellow");
        }
    }
    
    // Initial update
    updateRiskCardColor();
    
    // Create a separate observer for risk
    const riskObserver = new MutationObserver(function() {
        console.log("Risk observer triggered");
        updateRiskCardColor();
    });
    
    // Start observing
    riskObserver.observe(volatilityElement, { 
        childList: true, 
        characterData: true,
        subtree: true 
    });
    
    console.log("Risk monitoring setup complete");
}

// 2. DRAWDOWN MONITORING
function setupDrawdownMonitoring(drawdownElement) {
    console.log("Setting up drawdown monitoring");
    
    // Find the drawdown card element
    const drawdownCard = findParentCard('max-drawdown');
    
    if (drawdownCard) {
        setupDrawdownObserver(drawdownElement, drawdownCard);
    } else {
        console.error("Could not find parent card for drawdown");
    }
}

function setupDrawdownObserver(drawdownElement, cardElement) {
    function updateDrawdownCardColor() {
        const drawdownText = drawdownElement.innerText || drawdownElement.textContent;
        console.log("Drawdown text:", drawdownText);
        
        const cleanText = drawdownText.replace(/[^\d.-]/g, '');
        const drawdownValue = parseFloat(cleanText);
        
        if (isNaN(drawdownValue)) {
            console.error("Could not parse a valid number from drawdown text");
            return;
        }
        
        console.log("Drawdown value:", drawdownValue);
        
        if (drawdownValue <= -15) {
            cardElement.style.backgroundColor = '#ffe6e6'; // Light red
            console.log("Set drawdown card to red");
        } else {
            cardElement.style.backgroundColor = '#e6f7e6'; // Light green
            console.log("Set drawdown card to green");
        }
    }
    
    // Initial update
    updateDrawdownCardColor();
    
    // Create a separate observer for drawdown
    const drawdownObserver = new MutationObserver(function() {
        console.log("Drawdown observer triggered");
        updateDrawdownCardColor();
    });
    
    // Start observing
    drawdownObserver.observe(drawdownElement, { 
        childList: true, 
        characterData: true,
        subtree: true 
    });
    
    console.log("Drawdown monitoring setup complete");
}

// 3. PORTFOLIO RETURN MONITORING (FOR BOTH PORTFOLIO VALUE AND TOTAL RETURN CARDS)
function setupReturnMonitoring(annualizedReturnElement) {
    console.log("Setting up annualized return monitoring");
    
    // Find both card elements
    const portfolioValueCard = findParentCard('final-value');
    const totalReturnCard = findParentCard('total-return');
    
    if (!portfolioValueCard) {
        console.error("Could not find portfolio value card");
    }
    
    if (!totalReturnCard) {
        console.error("Could not find total return card");
    }
    
    // Set up the monitoring if at least one card was found
    if (portfolioValueCard || totalReturnCard) {
        setupReturnObserver(annualizedReturnElement, portfolioValueCard, totalReturnCard);
    }
}

function setupReturnObserver(annualizedReturnElement, portfolioValueCard, totalReturnCard) {
    function updateReturnCards() {
        const returnText = annualizedReturnElement.innerText || annualizedReturnElement.textContent;
        console.log("Annualized return text:", returnText);
        
        // Extract the percentage value (looking for a number followed by % per year)
        const matches = returnText.match(/(-?\d+\.?\d*)%/);
        if (!matches || matches.length < 2) {
            console.error("Could not parse annualized return percentage");
            return;
        }
        
        const annualizedReturnValue = parseFloat(matches[1]);
        console.log("Parsed annualized return value:", annualizedReturnValue);
        
        // Apply the appropriate background color based on the threshold
        if (annualizedReturnValue >= 6) {
            console.log("Setting cards to green (>= 6%)");
            if (portfolioValueCard) portfolioValueCard.style.backgroundColor = '#e6f7e6'; // Light green
            if (totalReturnCard) totalReturnCard.style.backgroundColor = '#e6f7e6'; // Light green
        } else {
            console.log("Setting cards to red (< 6%)");
            if (portfolioValueCard) portfolioValueCard.style.backgroundColor = '#ffe6e6'; // Light red
            if (totalReturnCard) totalReturnCard.style.backgroundColor = '#ffe6e6'; // Light red
        }
    }
    
    // Initial update
    updateReturnCards();
    
    // Create an observer for the annualized return
    const returnObserver = new MutationObserver(function() {
        console.log("Annualized return observer triggered");
        updateReturnCards();
    });
    
    // Start observing
    returnObserver.observe(annualizedReturnElement, { 
        childList: true, 
        characterData: true,
        subtree: true 
    });
    
    console.log("Annualized return monitoring setup complete");
}

// Initialize all monitors when the page loads
window.addEventListener('load', function() {
    console.log("Window loaded, setting up all monitors");
    
    // 1. Set up risk/volatility monitoring
    waitForElement('volatility', setupRiskMonitoring, 100, 10000);
    
    // 2. Set up maximum drawdown monitoring
    waitForElement('max-drawdown', setupDrawdownMonitoring, 100, 10000);
    
    // 3. Set up return monitoring (for both portfolio value and total return cards)
    waitForElement('annualized-return', setupReturnMonitoring, 100, 10000);
});


        /////
        
        // Function to fetch date range from API
function fetchDateRange() {
    fetch(API_DATE_RANGE)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            // Parse dates explicitly to avoid format confusion
            minDate = parseISODate(data.min_date);
            maxDate = parseISODate(data.max_date);
            
            console.log("Parsed date range:", {
                minDate: minDate.toISOString(),
                maxDate: maxDate.toISOString()
            });
            
            // Set default selected dates to max range
            selectedStartDate = minDate;
            selectedEndDate = maxDate;
            
            // Display date range text initially
            updateDateRangeDisplay();
            
            // Display ETF returns if needed
            const etfReturns = data.etf_returns;
            for (const etf in etfReturns) {
                const returnEl = document.getElementById(`${etf.toLowerCase()}-return`);
                if (returnEl) {
                    returnEl.textContent = `${etfReturns[etf].toFixed(2)}%`;
                }
            }
            
            // Now that we have the date range, trigger the initial calculation
            calculateAndFetchResults();
        })
        .catch(error => {
            showApiError(`Failed to fetch date range: ${error.message}`);
        });
}
function parseISODate(dateString) {
    // Check if the date is in ISO format (YYYY-MM-DD)
    if (!dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
        console.error("Date string is not in ISO format (YYYY-MM-DD):", dateString);
        // Return current date as fallback
        return new Date();
    }
    
    // Split the date string into components
    const [year, month, day] = dateString.split('-').map(Number);
    
    // Create a new date - JavaScript months are 0-indexed
    const date = new Date(year, month - 1, day);
    
    // Verify the date is valid
    if (isNaN(date.getTime())) {
        console.error("Invalid date created from:", dateString);
        return new Date(); // Fallback to current date
    }
    
    return date;
}

 // Function to initialize time period buttons
function initializeTimePeriodButtons() {
    const buttons = document.querySelectorAll('.time-btn');
    
    buttons.forEach(button => {
        button.addEventListener('click', function() {
            // Remove active class from all buttons
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // Add active class to clicked button
            this.classList.add('active');
            
            // Get the selected period
            const period = this.getAttribute('data-period');
            
            // Always use the last available date from the dataset as the end date
            selectedEndDate = new Date(maxDate);
            
            // Calculate start date based on period
            if (period === 'MAX') {
                selectedStartDate = new Date(minDate);
            } else {
                selectedStartDate = calculateStartDate(period);
            }
            
            // Update the date range display
            updateDateRangeDisplay();
            
            // Show date range display
            document.getElementById('date-range-display').style.display = 'block';
            
            // If allocations are valid, trigger calculation
            if (checkAllocation()) {
                calculateAndFetchResults();
            }
        });
    });
}

// Function to calculate start date based on period
function calculateStartDate(period) {
    const endDate = new Date(maxDate);
    const startDate = new Date(endDate);
    
    switch (period) {
        case '1M':
            startDate.setMonth(endDate.getMonth() - 1);
            break;
        case '6M':
            startDate.setMonth(endDate.getMonth() - 6);
            break;
        case '1Y':
            startDate.setFullYear(endDate.getFullYear() - 1);
            break;
        case '3Y':
            startDate.setFullYear(endDate.getFullYear() - 3);
            break;
        case '5Y':
            startDate.setFullYear(endDate.getFullYear() - 5);
            break;
        default:
            startDate = new Date(minDate);
    }
    
    // Ensure the start date is not earlier than the minimum available date
    if (startDate < minDate) {
        startDate = new Date(minDate);
    }
    
    return startDate;
}

    // Function to update the date range display
    function updateDateRangeDisplay() {
        const dateDisplay = document.getElementById('date-range-display');
        dateDisplay.textContent = `From ${formatDate(selectedStartDate)} to ${formatDate(selectedEndDate)}`;
        dateDisplay.style.display = 'none';
    }

        // Function to initialize allocation sliders ['SPY', 'GBTC', 'BRK-B', 'VUG']
        function initializeAllocationSliders() {
            const spySlider = document.getElementById('spy-allocation');
            const gbtcSlider = document.getElementById('gbtc-allocation');
            const brkbSlider = document.getElementById('brkb-allocation');
            const vugSlider = document.getElementById('vug-allocation');
            
            const spyValue = document.getElementById('spy-value');
            const gbtcValue = document.getElementById('gbtc-value');
            const brkbValue = document.getElementById('brkb-value');
            const vugValue = document.getElementById('vug-value');
            
            spySlider.addEventListener('input', function() {
                spyValue.textContent = `${spySlider.value}%`;
                checkAllocation();
            }); 
            
            gbtcSlider.addEventListener('input', function() {
                gbtcValue.textContent = `${gbtcSlider.value}%`;
                checkAllocation();
            }); 
            
            brkbSlider.addEventListener('input', function() {
                brkbValue.textContent = `${brkbSlider.value}%`;
                checkAllocation();
            });
            
            vugSlider.addEventListener('input', function() {
                vugValue.textContent = `${vugSlider.value}%`;
                checkAllocation();
            });  
        }
        
        // Function to check if allocations sum to 100% ['SPY', 'GBTC', 'BRK-B', 'VUG']
        function checkAllocation() {
            const spyValue = parseInt(document.getElementById('spy-allocation').value);
            const gbtcValue = parseInt(document.getElementById('gbtc-allocation').value);
            const brkbValue = parseInt(document.getElementById('brkb-allocation').value);
            const vugValue = parseInt(document.getElementById('vug-allocation').value);
            
            const total = spyValue + gbtcValue + brkbValue + vugValue;
            const warningEl = document.getElementById('allocation-warning');
            
            if (total !== 100) {
                warningEl.textContent = `Total allocation: ${total}% (should be 100%)`;
                return false;
            } else {
                warningEl.textContent = '';
                return true;
            }
        }
        
        // Function to initialize tabs
        function initializeTabs() {
                    const tabs = document.querySelectorAll('.tab');
                    
                    tabs.forEach(tab => {
                        tab.addEventListener('click', function() {
                            const tabId = this.getAttribute('data-tab');
                            
                            // Remove active class from all tabs and tab content
                            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                            
                            // Add active class to clicked tab and corresponding content
                            this.classList.add('active');
                            document.getElementById(tabId).classList.add('active');
                            
                            // Re-render charts when tab becomes visible to fix layout issues
                            setTimeout(() => {
                                if (tabId === 'growth' && portfolioData) {
                                    // Use the new comparison chart instead of the old growth chart
                                    createPortfolioAgainstSpyChart(portfolioData, portfolioData);
                                } else if (tabId === 'drawdown' && portfolioData) {
                                    createDrawdownChart(portfolioData);
                                } else if (tabId === 'comparison' && portfolioData) {
                                    createComparisonChart(portfolioData, etfPerformance);
                                } else if (tabId === 'yearly' && yearlyReturns) {
                                    createYearlyReturnsChart(yearlyReturns);
                                } else if (tabId === 'company') {
                                    createCompanyWeightageChart(); // Mavis
                                } else if (tabId === 'industry') {
                                    createIndustryWeightageChart(); // Angela
                                }
                            }, 50);
                        });
                    });
                }

        // Helper function to get current allocations
        function getCurrentAllocations() {
            return {
                'SPY': parseInt(document.getElementById('spy-allocation').value),
                'GBTC': parseInt(document.getElementById('gbtc-allocation').value),
                'BRK-B': parseInt(document.getElementById('brkb-allocation').value),
                'VUG': parseInt(document.getElementById('vug-allocation').value)
            };
        }
        
        // Function to calculate and fetch results from API
        function calculateAndFetchResults() {
            // Check if allocations are valid
            if (!checkAllocation()) {
                alert('Total allocation must be 100%. Please adjust your allocations.');
                return;
            }
            
            // Get input values
            const initialInvestment = parseFloat(document.getElementById('initial-investment').value);
            const spyAllocation = parseInt(document.getElementById('spy-allocation').value);
            const gbtcAllocation = parseInt(document.getElementById('gbtc-allocation').value);
            const brkbAllocation = parseInt(document.getElementById('brkb-allocation').value);
            const vugAllocation = parseInt(document.getElementById('vug-allocation').value);
            
            // Use the selected date range
            const startDate = formatDateForAPI(selectedStartDate);
            const endDate = formatDateForAPI(selectedEndDate);
            
            // Prepare API request payload
            const payload = {
                initial_investment: initialInvestment,
                allocations: {
                    'SPY': spyAllocation,
                    'GBTC': gbtcAllocation,
                    'BRK-B': brkbAllocation,
                    'VUG': vugAllocation
                },
                start_date: startDate,
                end_date: endDate
            };
            
            // Show loading state
            document.querySelectorAll('.loading').forEach(el => {
                el.style.display = 'block';
            });
            
            // Clear any previous error messages
            hideApiError();
            
            // Fetch all data at once
            fetchAllData(payload);
        }

// Helper function to format dates for API (YYYY-MM-DD)
function formatDateForAPI(date) {
    if (!date) return null;
    
    try {
        const d = new Date(date);
        if (isNaN(d.getTime())) {
            console.error("Invalid date for API formatting:", date);
            return null;
        }
        
        const year = d.getFullYear();
        // JavaScript months are 0-indexed, so add 1
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        
        return `${year}-${month}-${day}`;
    } catch (error) {
        console.error("Error formatting date for API:", error);
        return null;
    }
}
        
        // Function to fetch all data from the API
        function fetchAllData(payload) {
            updateDateRangeDisplay();
            // Use the calculate-all endpoint
            fetch(API_CALCULATE_ALL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        try {
                            const err = JSON.parse(text);
                            throw new Error(err.error || `HTTP error! Status: ${response.status}`);
                        } catch(e) {
                            throw new Error(`HTTP error! Status: ${response.status}, Body: ${text.substring(0, 100)}...`);
                        }
                    });
                }
                return response.text().then(text => {
                    // Replace NaN with null in the response to handle JSON parsing issues
                    const cleanedText = text.replace(/NaN/g, 'null');
                    return JSON.parse(cleanedText);
                });
            })
            .then(data => {
                // Store the data
                const metrics = data.metrics;
                portfolioData = data.portfolio_data;
                etfPerformance = data.etf_performance;
                yearlyReturns = data.yearly_returns;
                
                console.log("Data received:", {
                    portfolioDataPoints: portfolioData?.length || 0,
                    etfPerformanceEntries: Object.keys(etfPerformance || {}).length,
                    yearlyReturnsPoints: yearlyReturns?.length || 0
                });
                
                // Update metrics display
                updateMetricsDisplay(metrics, payload.initial_investment);
                
                // We'll use SPY data for comparison - extract it from portfolio data
                // (Since we need the same date range as our portfolio data)
                
                // Create charts - using the new comparison chart instead of growth chart
                createPortfolioAgainstSpyChart(portfolioData, portfolioData); // Use same data source for both
                createDrawdownChart(portfolioData);
                createComparisonChart(portfolioData, etfPerformance);
                createYearlyReturnsChart(yearlyReturns);
                createCompanyWeightageChart(); // Mavis
                createIndustryWeightageChart(); // Angela 
                
                // Hide loading indicators
                document.querySelectorAll('.loading').forEach(el => {
                    el.style.display = 'none';
                });
            })
            .catch(error => {
                showApiError(`Failed to fetch portfolio data: ${error.message}`);
                
                // Hide loading indicators
                document.querySelectorAll('.loading').forEach(el => {
                    el.style.display = 'none';
                });
            });
        }

        // Helper function to show API error
        function showApiError(message) {
            const errorEl = document.getElementById('api-error');
            const messageEl = document.getElementById('error-message');
            messageEl.textContent = message;
            errorEl.style.display = 'block';
        }

        // Helper function to hide API error
        function hideApiError() {
            const errorEl = document.getElementById('api-error');
            errorEl.style.display = 'none';
        }

// Helper function to format date for display
function formatDate(date) {
    if (!date) return "Invalid Date";
    
    try {
        const d = new Date(date);
        if (isNaN(d.getTime())) {
            return "Invalid Date";
        }
        
        const options = { year: 'numeric', month: 'short', day: 'numeric' };
        return d.toLocaleDateString('en-US', options);
    } catch (error) {
        console.error("Error formatting date for display:", error);
        return "Error";
    }
}
        
        // Function to update metrics display
        function updateMetricsDisplay(metrics, initialInvestment) {
            document.getElementById('final-value').textContent = formatCurrency(metrics.final_value);
            document.getElementById('initial-value').textContent = `Initial: ${formatCurrency(initialInvestment)}`;
            document.getElementById('total-return').textContent = formatPercentage(metrics.total_return);
            document.getElementById('annualized-return').textContent = `Annualized: ${formatPercentage(metrics.annualized_return)} per year`;
            document.getElementById('max-drawdown').textContent = formatPercentage(metrics.max_drawdown);
            document.getElementById('volatility').textContent = `${metrics.risk_level} (${formatPercentage(metrics.volatility)})`;
        }

        // Helper function to format currency
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value);
        }

        // Helper function to format percentage
        function formatPercentage(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'percent',
                minimumFractionDigits: 1,
                maximumFractionDigits: 1
            }).format(value);
        }


// Enhanced portfolio vs SPY chart function with improved hover behavior
function createPortfolioAgainstSpyChart(portfolioData, spyData) {
    const chartContainer = document.getElementById('portfolio-growth-chart');
    chartContainer.innerHTML = '';
    
    // Check if we have data
    if (!portfolioData || portfolioData.length === 0 || !spyData || spyData.length === 0) {
        chartContainer.innerHTML = '<div class="error">No data available for comparison</div>';
        return;
    }
    
    const margin = {top: 20, right: 80, bottom: 50, left: 80};
    const width = chartContainer.clientWidth - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;
    
    const svg = d3.select(chartContainer)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
    
    // Make sure dates are Date objects and sort chronologically
    const processedPortfolioData = portfolioData.map(d => ({
        ...d,
        Date: d.Date instanceof Date ? d.Date : new Date(d.Date)
    })).sort((a, b) => a.Date - b.Date);
    
    const processedSpyData = spyData.map(d => ({
        ...d,
        Date: d.Date instanceof Date ? d.Date : new Date(d.Date)
    })).sort((a, b) => a.Date - b.Date);
    
    // For comparison, we need to normalize both portfolio and SPY to start at 1
    // Make sure the first value is valid, or default to 1 if not
    const firstPortfolioValue = processedPortfolioData[0]?.total_value || 1;
    const firstSpyValue = processedSpyData[0]?.SPY || 1;
    
    // Create normalized data for comparison with validation
    const normalizedPortfolioData = processedPortfolioData
        .map(d => {
            if (!d.total_value || !firstPortfolioValue || isNaN(d.total_value)) {
                return { Date: d.Date, value: null };
            }
            return {
                Date: d.Date,
                value: d.total_value / firstPortfolioValue
            };
        })
        .filter(d => d.value !== null && !isNaN(d.value));
    
    const normalizedSpyData = processedSpyData
        .map(d => {
            if (!d.SPY || !firstSpyValue || isNaN(d.SPY)) {
                return { Date: d.Date, value: null };
            }
            return {
                Date: d.Date,
                value: d.SPY / firstSpyValue
            };
        })
        .filter(d => d.value !== null && !isNaN(d.value));
    
    // Check if we have any valid data points
    if (normalizedPortfolioData.length === 0 || normalizedSpyData.length === 0) {
        chartContainer.innerHTML = '<div class="error">No valid data points for the selected period</div>';
        return;
    }
    
    // Get date range for x-axis (use the portfolio data range)
    const dateExtent = d3.extent(normalizedPortfolioData, d => d.Date);
    
    // Find max value for y-axis scaling with validation
    const maxPortfolioValue = d3.max(normalizedPortfolioData, d => d.value) || 1;
    const maxSpyValue = d3.max(normalizedSpyData, d => d.value) || 1;
    const maxValue = Math.max(maxPortfolioValue, maxSpyValue);
    
    // X scale
    const x = d3.scaleTime()
        .domain(dateExtent)
        .range([0, width]);
    
    // Y scale with 10% padding
    const y = d3.scaleLinear()
        .domain([0, maxValue * 1.1])
        .range([height, 0]);
    
    // X axis
    svg.append('g')
        .attr('class', 'axis')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x)
            .ticks(width > 500 ? 10 : 5)
            .tickFormat(d3.timeFormat('%b %Y')))
        .selectAll('text')
        .style('text-anchor', 'end')
        .attr('dx', '-.8em')
        .attr('dy', '.15em')
        .attr('transform', 'rotate(-45)');
    
    // Y axis
    svg.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(y)
            .tickFormat(d => d3.format('.1f')(d)));
    
    // Grid lines to improve readability
    svg.append('g')
        .attr('class', 'grid')
        .call(d3.axisLeft(y)
            .ticks(10)
            .tickSize(-width)
            .tickFormat(''))
        .style('stroke', '#e0e0e0')
        .style('stroke-opacity', 0.7)
        .style('shape-rendering', 'crispEdges');
    
    // Add Y axis label
    svg.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('y', -60)
        .attr('x', -height / 2)
        .attr('text-anchor', 'middle')
        .text('Value (Normalized)')
        .style('fill', '#666');
    
    // Add chart title
    svg.append('text')
        .attr('text-anchor', 'middle')
        .attr('x', width / 2)
        .attr('y', -margin.top / 2 + 10)
        .text('Portfolio vs. S&P 500 Performance')
        .style('font-size', '16px')
        .style('font-weight', 'bold')
        .style('fill', '#2c3e50');
    
    // Colors for lines
    const portfolioColor = '#2c3e50';  // Portfolio in dark blue
    const spyColor = '#1f77b4';        // SPY in lighter blue
    
    // Line generator that handles missing data
    const line = d3.line()
        .x(d => x(d.Date))
        .y(d => y(d.value))
        .defined(d => d.value !== null && !isNaN(d.value)) // Skip missing/invalid values
        .curve(d3.curveMonotoneX);
    
    // Draw portfolio line
    svg.append('path')
        .datum(normalizedPortfolioData)
        .attr('class', 'portfolio-line')
        .attr('fill', 'none')
        .attr('stroke', portfolioColor)
        .attr('stroke-width', 3)
        .attr('d', line);
    
    // Draw SPY line
    svg.append('path')
        .datum(normalizedSpyData)
        .attr('class', 'spy-line')
        .attr('fill', 'none')
        .attr('stroke', spyColor)
        .attr('stroke-width', 1.5)
        .attr('stroke-dasharray', '5,5')  // Make SPY line dashed
        .attr('d', line);
    
    // Add tooltip circles to highlight points
    const portfolioCircle = svg.append('circle')
        .attr('r', 5)
        .attr('fill', portfolioColor)
        .attr('stroke', 'white')
        .attr('stroke-width', 2)
        .style('opacity', 0)
        .style('pointer-events', 'none');
        
    const spyCircle = svg.append('circle')
        .attr('r', 5)
        .attr('fill', spyColor)
        .attr('stroke', 'white')
        .attr('stroke-width', 2)
        .style('opacity', 0)
        .style('pointer-events', 'none');
    
    // Add vertical tracker line
    const verticalLine = svg.append('line')
        .attr('stroke', '#888')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '3,3')
        .style('opacity', 0)
        .style('pointer-events', 'none');
    
    // Create tooltip
    const tooltip = d3.select('#tooltip');
    
    // Create a bisector for finding closest data point
    const bisect = d3.bisector(d => d.Date).left;
    
    // Add transparent overlay for mouse interaction
    svg.append('rect')
        .attr('width', width)
        .attr('height', height)
        .style('fill', 'none')
        .style('pointer-events', 'all')
        .on('mouseover', () => {
            tooltip.style('opacity', 1);
            portfolioCircle.style('opacity', 1);
            spyCircle.style('opacity', 1);
            verticalLine.style('opacity', 1);
        })
        .on('mouseout', () => {
            tooltip.style('opacity', 0);
            portfolioCircle.style('opacity', 0);
            spyCircle.style('opacity', 0);
            verticalLine.style('opacity', 0);
        })
        .on('mousemove', function(event) {
            // Get mouse x-position in data space
            const mouseX = d3.pointer(event)[0];
            const x0 = x.invert(mouseX);
            
            // Find closest portfolio data point
            let i = bisect(normalizedPortfolioData, x0, 1);
            if (i >= normalizedPortfolioData.length) {
                i = normalizedPortfolioData.length - 1;
            }
            
            // Get closest portfolio point
            let portfolioPoint = null;
            if (i > 0) {
                const d0 = normalizedPortfolioData[i - 1];
                const d1 = normalizedPortfolioData[i];
                if (d0 && d1) {
                    portfolioPoint = x0 - d0.Date > d1.Date - x0 ? d1 : d0;
                } else if (d0) {
                    portfolioPoint = d0;
                } else if (d1) {
                    portfolioPoint = d1;
                }
            } else if (i === 0 && normalizedPortfolioData.length > 0) {
                portfolioPoint = normalizedPortfolioData[0];
            }
            
            if (!portfolioPoint) return;
            
            // Update portfolio circle
            portfolioCircle
                .attr('cx', x(portfolioPoint.Date))
                .attr('cy', y(portfolioPoint.value));
                
            // Update vertical line
            verticalLine
                .attr('x1', x(portfolioPoint.Date))
                .attr('x2', x(portfolioPoint.Date))
                .attr('y1', 0)
                .attr('y2', height);
            
            // Find closest SPY data point to the same date
            let spyPoint = null;
            for (let j = 0; j < normalizedSpyData.length; j++) {
                const s = normalizedSpyData[j];
                if (!spyPoint || Math.abs(s.Date - portfolioPoint.Date) < Math.abs(spyPoint.Date - portfolioPoint.Date)) {
                    spyPoint = s;
                }
            }
            
            // Update SPY circle if we found a point
            if (spyPoint) {
                spyCircle
                    .attr('cx', x(spyPoint.Date))
                    .attr('cy', y(spyPoint.value))
                    .style('opacity', 1);
            } else {
                spyCircle.style('opacity', 0);
            }
            
            // Format date for tooltip
            const formattedDate = formatDate(portfolioPoint.Date);
            
            // Calculate outperformance
            let outperformanceHTML = '';
            if (spyPoint && portfolioPoint.Date.getTime() === spyPoint.Date.getTime()) {
                const diff = portfolioPoint.value - spyPoint.value;
                const percentDiff = (diff / spyPoint.value) * 100;
                const diffColor = diff >= 0 ? '#28a745' : '#dc3545';
                
                outperformanceHTML = `
                    <div style="margin-top: 8px; padding-top: 5px; border-top: 1px solid #eee;">
                        <span style="color: ${diffColor}; font-weight: bold;">
                            ${diff >= 0 ? 'Outperforming' : 'Underperforming'} by 
                            ${Math.abs(percentDiff).toFixed(2)}%
                        </span>
                    </div>
                `;
            }
            
            // Create tooltip content
            tooltip.html(`
                <div style="font-weight: bold; margin-bottom: 5px;">${formattedDate}</div>
                <div>
                    <span style="display: inline-block; width: 12px; height: 12px; background: ${portfolioColor}; margin-right: 5px;"></span>
                    Portfolio: ${portfolioPoint.value.toFixed(2)}x
                </div>
                ${spyPoint ? `
                <div style="margin-top: 5px;">
                    <span style="display: inline-block; width: 12px; height: 12px; background: ${spyColor}; margin-right: 5px;"></span>
                    S&P 500: ${spyPoint.value.toFixed(2)}x
                </div>` : ''}
                ${outperformanceHTML}
            `)
            .style('left', (event.pageX + 15) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        });
    
    // Create legend
    const legend = document.getElementById('growth-legend');
    legend.innerHTML = '';
    
    // Portfolio legend item
    const portfolioLegend = document.createElement('div');
    portfolioLegend.className = 'legend-item';
    
    const portfolioColor1 = document.createElement('div');
    portfolioColor1.className = 'legend-color';
    portfolioColor1.style.backgroundColor = portfolioColor;
    
    const portfolioText = document.createElement('span');
    portfolioText.textContent = 'Your Portfolio';
    
    portfolioLegend.appendChild(portfolioColor1);
    portfolioLegend.appendChild(portfolioText);
    legend.appendChild(portfolioLegend);
    
    // SPY legend item
    const spyLegend = document.createElement('div');
    spyLegend.className = 'legend-item';
    
    const spyColor1 = document.createElement('div');
    spyColor1.className = 'legend-color';
    spyColor1.style.backgroundColor = spyColor;
    
    const spyText = document.createElement('span');
    spyText.textContent = 'S&P 500 (SPY)';
    
    spyLegend.appendChild(spyColor1);
    spyLegend.appendChild(spyText);
    legend.appendChild(spyLegend);
}

        function createDrawdownChart(portfolioData) {
            const chartContainer = document.getElementById('drawdown-chart');
            chartContainer.innerHTML = '';
            
            // Check if we have data
            if (!portfolioData || portfolioData.length === 0) {
                chartContainer.innerHTML = '<div class="error">No data available for drawdown analysis</div>';
                return;
            }
            
            // Check container width first
            const containerWidth = chartContainer.clientWidth;
            
            if (containerWidth <= 0) {
                // Wait for the layout to stabilize (e.g., tab becoming visible)
                setTimeout(() => createDrawdownChart(portfolioData), 100);
                return;
            }
            
            // Use smaller margins if container is narrow
            const margin = containerWidth < 400 
                ? {top: 20, right: 30, bottom: 50, left: 40}
                : {top: 20, right: 80, bottom: 50, left: 80};
            
            const width = Math.max(containerWidth - margin.left - margin.right, 100); // Ensure minimum width
            const height = 400 - margin.top - margin.bottom;
            
            const svg = d3.select(chartContainer)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Make sure dates are Date objects and sort data chronologically
            portfolioData = portfolioData
                .map(d => ({
                    ...d,
                    Date: d.Date instanceof Date ? d.Date : new Date(d.Date),
                    // Ensure drawdown is numeric and within reasonable bounds
                    drawdown: typeof d.drawdown === 'number' && !isNaN(d.drawdown) ? 
                            Math.max(Math.min(d.drawdown, 0), -1) : 0,
                    total_value: typeof d.total_value === 'number' && !isNaN(d.total_value) ?
                                d.total_value : 0,
                    peak_value: typeof d.peak_value === 'number' && !isNaN(d.peak_value) ?
                                d.peak_value : 0
                }))
                .sort((a, b) => a.Date - b.Date);
            
            // If we have fewer than 2 data points after filtering, show error
            if (portfolioData.length < 2) {
                chartContainer.innerHTML = '<div class="error">Not enough valid data points for drawdown analysis</div>';
                return;
            }
            
            // Calculate domain for drawdown
            const minDrawdown = d3.min(portfolioData, d => d.drawdown);
            
            // X scale
            const x = d3.scaleTime()
                .domain(d3.extent(portfolioData, d => d.Date))
                .range([0, width]);
            
            // Y scale for drawdown (negative values)
            // Set a reasonable minimum (e.g., -0.1 for -10% if no drawdown)
            const yMin = Math.min(minDrawdown * 1.1 || -0.1, -0.1);
            
            const y = d3.scaleLinear()
                .domain([yMin, 0]) 
                .range([height, 0]);
            
            // X axis
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(width > 500 ? 10 : 5)
                    .tickFormat(d3.timeFormat('%b %Y')))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            // Y axis
            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y)
                    .tickFormat(d => `${d3.format('.0%')(d)}`));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -margin.left + 20) // Adjust based on margin
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Drawdown (%)')
                .style('fill', '#666');
            
            // Create the area generator for drawdown visualization
            const area = d3.area()
                .x(d => x(d.Date))
                .y0(d => y(d.drawdown))  // Bottom of the area is at the drawdown value
                .y1(y(0))                // Top of the area is at zero
                .defined(d => !isNaN(d.drawdown))
                .curve(d3.curveMonotoneX); // Add smooth curve
            
            // Draw the area in red (representing drawdown)
            svg.append('path')
                .datum(portfolioData)
                .attr('fill', 'rgba(255, 0, 0, 0.3)')
                .attr('d', area);
            
            // Draw the drawdown line
            const line = d3.line()
                .x(d => x(d.Date))
                .y(d => y(d.drawdown))
                .defined(d => !isNaN(d.drawdown))
                .curve(d3.curveMonotoneX); // Add smooth curve
            
            svg.append('path')
                .datum(portfolioData)
                .attr('fill', 'none')
                .attr('stroke', 'rgb(255, 0, 0)')
                .attr('stroke-width', 2)
                .attr('d', line);
            
            // Add a zero line
            svg.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', y(0))
                .attr('y2', y(0))
                .attr('stroke', '#888')
                .attr('stroke-dasharray', '3,3');
            
            // Add grid lines for better readability
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y)
                    .tickValues([-0.1, -0.2, -0.3, -0.4, -0.5]) // 10%, 20%, 30%, 40%, 50% drawdown lines
                    .tickSize(-width)
                    .tickFormat(''))
                .style('stroke', '#e0e0e0')
                .style('stroke-opacity', 0.7)
                .style('shape-rendering', 'crispEdges');
            
            // Add vertical grid lines
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(10)
                    .tickSize(-height)
                    .tickFormat(''))
                .style('stroke', '#e0e0e0')
                .style('stroke-opacity', 0.5)
                .style('shape-rendering', 'crispEdges');
            
            // Add tooltip elements
            const tooltip = d3.select('#tooltip');
            const bisect = d3.bisector(d => d.Date).left;
            
            // Add tooltip vertical line and dot
            const tooltipLine = svg.append("line")
                .attr("stroke", "#666")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3")
                .attr("y1", 0)
                .attr("y2", height)
                .style("opacity", 0);
                
            const tooltipDot = svg.append("circle")
                .attr("r", 5)
                .attr("fill", "rgb(255, 0, 0)")
                .attr("stroke", "white")
                .attr("stroke-width", 2)
                .style("opacity", 0);
            
            // Add transparent overlay for mouse interaction
            svg.append('rect')
                .attr('width', width > 0 ? width : 0) // Ensure width is not negative
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mouseover', function() {
                    tooltip.style('opacity', 1);
                    tooltipLine.style('opacity', 1);
                    tooltipDot.style('opacity', 1);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                    tooltipLine.style('opacity', 0);
                    tooltipDot.style('opacity', 0);
                })
                .on('mousemove', function(event) {
                    const mouseX = d3.pointer(event)[0];
                    const x0 = x.invert(mouseX);
                    const i = bisect(portfolioData, x0, 1);
                    
                    if (i >= portfolioData.length) return;
                    
                    const d0 = portfolioData[i - 1];
                    const d1 = portfolioData[i];
                    if (!d0 || !d1) return;
                    
                    const d = x0 - d0.Date > d1.Date - x0 ? d1 : d0;
                    
                    // Update tooltip line position
                    tooltipLine
                        .attr("x1", x(d.Date))
                        .attr("x2", x(d.Date));
                        
                    // Update tooltip dot position
                    tooltipDot
                        .attr("cx", x(d.Date))
                        .attr("cy", y(d.drawdown));
                    
                    // Format tooltip content
                    tooltip.style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <div style="font-weight: bold; margin-bottom: 5px;">${formatDate(d.Date)}</div>
                            <div style="color: ${d.drawdown < -0.1 ? '#dc3545' : '#6c757d'}">
                                <strong>Drawdown:</strong> ${d3.format('.2%')(d.drawdown)}
                            </div>
                            <div style="margin-top: 5px;">
                                <strong>Peak Value:</strong> ${formatCurrency(d.peak_value)}
                            </div>
                            <div>
                                <strong>Current Value:</strong> ${formatCurrency(d.total_value)}
                            </div>
                            <div>
                                <strong>Decline Amount:</strong> ${formatCurrency(d.total_value - d.peak_value)}
                            </div>
                        `);
                });
            
            // Add annotations for major drawdown events
            // Find significant drawdowns (below -20%)
            const significantDrawdowns = portfolioData.filter(d => d.drawdown < -0.2);
            
            if (significantDrawdowns.length > 0) {
                // Find local minimums in drawdowns by comparing neighbors
                const drawdownEvents = [];
                
                for (let i = 1; i < portfolioData.length - 1; i++) {
                    const prev = portfolioData[i-1];
                    const curr = portfolioData[i];
                    const next = portfolioData[i+1];
                    
                    // If current point is a local minimum and below -15%
                    if (curr.drawdown < -0.15 && 
                        curr.drawdown <= prev.drawdown && 
                        curr.drawdown <= next.drawdown) {
                        
                        // Check if we already have a similar drawdown event nearby
                        const isUnique = !drawdownEvents.some(event => 
                            Math.abs(event.Date - curr.Date) < 30 * 24 * 60 * 60 * 1000 && // Within 30 days
                            Math.abs(event.drawdown - curr.drawdown) < 0.05 // Within 5% drawdown difference
                        );
                        
                        if (isUnique) {
                            drawdownEvents.push(curr);
                        }
                    }
                }
                
                // Sort by severity and take top 3
                drawdownEvents.sort((a, b) => a.drawdown - b.drawdown);
                const topDrawdowns = drawdownEvents.slice(0, 3);
                
                // Add annotations
                topDrawdowns.forEach(event => {
                    // Create annotation
                    svg.append("line")
                        .attr("x1", x(event.Date))
                        .attr("x2", x(event.Date))
                        .attr("y1", y(event.drawdown))
                        .attr("y2", y(event.drawdown) - 40)
                        .attr("stroke", "#ff0000")
                        .attr("stroke-width", 1)
                        .attr("stroke-dasharray", "3,3");
                        
                    svg.append("circle")
                        .attr("cx", x(event.Date))
                        .attr("cy", y(event.drawdown))
                        .attr("r", 4)
                        .attr("fill", "#ff0000");
                        
                    svg.append("text")
                        .attr("x", x(event.Date))
                        .attr("y", y(event.drawdown) - 45)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "10px")
                        .text(`${d3.format('.1%')(event.drawdown)}`)
                        .style("fill", "#ff0000");
                });
            }
        }

        // Function to create ETF comparison chart
        function createComparisonChart(portfolioData, etfPerformance) {
            const chartContainer = document.getElementById('etf-comparison-chart');
            chartContainer.innerHTML = '';
            
            // Check if we have the required data
            if (!portfolioData || !etfPerformance || portfolioData.length === 0) {
                chartContainer.innerHTML = '<div class="error">No ETF comparison data available</div>';
                console.error("Missing portfolio data or ETF performance data");
                return;
            }
            
            // Check container width
            const containerWidth = chartContainer.clientWidth;
            if (containerWidth <= 0) {
                setTimeout(() => createComparisonChart(portfolioData, etfPerformance), 100);
                return;
            }
            
            const margin = {top: 20, right: 80, bottom: 50, left: 80};
            const width = Math.max(containerWidth - margin.left - margin.right, 100);
            const height = 400 - margin.top - margin.bottom;
            
            const svg = d3.select(chartContainer)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Make sure dates are Date objects and sort chronologically
            portfolioData = portfolioData.map(d => {
                return {
                    ...d,
                    Date: d.Date instanceof Date ? d.Date : new Date(d.Date)
                };
            }).sort((a, b) => a.Date - b.Date);
            
            // Get list of ETFs in the performance data
            const etfs = Object.keys(etfPerformance);
            
            if (etfs.length === 0) {
                chartContainer.innerHTML = '<div class="error">No ETF data found in performance data</div>';
                return;
            }
            
            // Process data to get normalized returns for each ETF
            // First, check what normalization fields are available
            const sampleEntry = portfolioData[0];
            const normFields = etfs.map(etf => `${etf}_norm`).filter(field => field in sampleEntry);
            
            // Calculate normalized data with proper handling of missing values
            let normalizedData;
            
            if (normFields.length === etfs.length) {
                // Use existing normalization data
                normalizedData = portfolioData.map(d => {
                    const result = { Date: d.Date };
                    etfs.forEach(etf => {
                        const normField = `${etf}_norm`;
                        if (normField in d && !isNaN(d[normField])) {
                            // Convert to percentage, but don't subtract 1 if already normalized
                            result[etf] = (d[normField] - 1) * 100;
                        }
                    });
                    return result;
                });
            } else {
                // Manually calculate normalization
                const firstDayValues = {};
                etfs.forEach(etf => {
                    if (etf in portfolioData[0] && !isNaN(portfolioData[0][etf])) {
                        firstDayValues[etf] = portfolioData[0][etf];
                    }
                });
                
                normalizedData = portfolioData.map(d => {
                    const result = { Date: d.Date };
                    etfs.forEach(etf => {
                        if (etf in d && etf in firstDayValues && 
                            !isNaN(d[etf]) && firstDayValues[etf] > 0) {
                            result[etf] = ((d[etf] / firstDayValues[etf]) - 1) * 100;
                        }
                    });
                    return result;
                });
            }
            
            // Validate data and ensure there are no huge gaps
            const validEtfs = etfs.filter(etf => 
                normalizedData.some(d => etf in d && !isNaN(d[etf]))
            );
            
            if (validEtfs.length === 0) {
                chartContainer.innerHTML = '<div class="error">No valid ETF data after normalization</div>';
                return;
            }
            
            // X scale
            const x = d3.scaleTime()
                .domain(d3.extent(normalizedData, d => d.Date))
                .range([0, width]);
            
            // Find min and max values across all ETFs
            const allValues = [];
            normalizedData.forEach(d => {
                validEtfs.forEach(etf => {
                    if (etf in d && !isNaN(d[etf])) {
                        allValues.push(d[etf]);
                    }
                });
            });
            
            const minValue = d3.min(allValues) || -5;
            const maxValue = d3.max(allValues) || 5;
            
            // Y scale with padding
            const y = d3.scaleLinear()
                .domain([Math.min(minValue, -5), Math.max(maxValue * 1.05, 5)])
                .range([height, 0]);
            
            // X axis
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(width > 500 ? 10 : 5)
                    .tickFormat(d3.timeFormat('%b %Y')))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            // Y axis
            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y)
                    .tickFormat(d => `${d3.format('.0f')(d)}%`));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -60)
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Return (%)');
            
            // Add a zero line
            svg.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', y(0))
                .attr('y2', y(0))
                .attr('stroke', '#888')
                .attr('stroke-dasharray', '3,3');
            
            // Colors for ETFs
            const colors = {
                'SPY': '#00897B',
                'GBTC': '#3F51B5',
                'BRK-B': '#FF9800',
                'VUG': '#E91E63'
            };
            
            // Create line generator with curve
            const line = d3.line()
                .x(d => x(d.Date))
                .y(d => y(d.value))
                .defined(d => !isNaN(d.value))
                .curve(d3.curveMonotoneX); // Add a curve for smoother lines
            
            // Create lines for each ETF
            validEtfs.forEach(etf => {
                // Filter for consecutive valid data points to avoid large jumps
                const etfData = [];
                let lastValidIndex = -1;
                
                normalizedData.forEach((d, i) => {
                    if (d[etf] !== undefined && !isNaN(d[etf])) {
                        // If there's a large gap between points, start a new segment
                        if (lastValidIndex !== -1 && i - lastValidIndex > 5) {
                            // End the previous segment
                            svg.append('path')
                                .datum(etfData)
                                .attr('fill', 'none')
                                .attr('stroke', colors[etf] || '#999')
                                .attr('stroke-width', 2)
                                .attr('d', line);
                            
                            // Start a new array for the next segment
                            etfData.length = 0;
                        }
                        
                        etfData.push({
                            Date: d.Date,
                            value: d[etf]
                        });
                        
                        lastValidIndex = i;
                    }
                });
                
                // Draw the final segment if we have data
                if (etfData.length > 1) {
                    svg.append('path')
                        .datum(etfData)
                        .attr('fill', 'none')
                        .attr('stroke', colors[etf] || '#999')
                        .attr('stroke-width', 2)
                        .attr('d', line);
                }
            });
            
            // Create a tooltip for comparison
            const tooltip = d3.select('#tooltip');
            const bisect = d3.bisector(d => d.Date).left;
            
            // Add vertical line for tooltip
            const tooltipLine = svg.append("line")
                .attr("stroke", "#ddd")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3")
                .attr("y1", 0)
                .attr("y2", height)
                .style("opacity", 0);
                
            // Add circles to highlight points
            const tooltipDots = {};
            validEtfs.forEach(etf => {
                tooltipDots[etf] = svg.append("circle")
                    .attr("r", 4)
                    .attr("fill", colors[etf] || '#999')
                    .attr("stroke", "white")
                    .attr("stroke-width", 2)
                    .style("opacity", 0);
            });
            
            svg.append('rect')
                .attr('width', width > 0 ? width : 0)
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mousemove', function(event) {
                    const mouseX = d3.pointer(event)[0];
                    const x0 = x.invert(mouseX);
                    const i = bisect(normalizedData, x0, 1);
                    
                    if (i >= normalizedData.length) return;
                    
                    const d0 = normalizedData[i - 1];
                    const d1 = normalizedData[i];
                    const d = x0 - d0.Date > d1.Date - x0 ? d1 : d0;
                    
                    // Show vertical line
                    tooltipLine
                        .attr("x1", x(d.Date))
                        .attr("x2", x(d.Date))
                        .style("opacity", 1);
                    
                    // Show dots at each valid point
                    validEtfs.forEach(etf => {
                        if (etf in d && !isNaN(d[etf])) {
                            tooltipDots[etf]
                                .attr("cx", x(d.Date))
                                .attr("cy", y(d[etf]))
                                .style("opacity", 1);
                        } else {
                            tooltipDots[etf].style("opacity", 0);
                        }
                    });
                    
                    const tooltipContent = `<strong>Date:</strong> ${formatDate(d.Date)}<br>` + 
                        validEtfs.map(etf => {
                            if (etf in d && !isNaN(d[etf])) {
                                return `<span style="color:${colors[etf]}"><strong>${etf}:</strong> ${d[etf].toFixed(2)}%</span>`;
                            }
                            return '';
                        }).filter(s => s !== '').join('<br>');
                    
                    tooltip.style('opacity', 1)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(tooltipContent);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                    tooltipLine.style("opacity", 0);
                    Object.values(tooltipDots).forEach(dot => dot.style("opacity", 0));
                });
            
            // Create the legend
            const legend = document.getElementById('comparison-legend');
            legend.innerHTML = '';
            
            validEtfs.forEach(etf => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = colors[etf] || '#999';
                
                const text = document.createElement('span');
                text.textContent = etf;
                
                item.appendChild(colorBox);
                item.appendChild(text);
                legend.appendChild(item);
            });
        }

        // Function to create yearly returns chart
        function createYearlyReturnsChart(yearlyReturns) {
            const chartContainer = document.getElementById('yearly-returns-chart');
            chartContainer.innerHTML = '';
            
            // Debug logging
            console.log("Yearly Returns Data:", yearlyReturns);
            
            // Check if we have the required data
            if (!yearlyReturns || yearlyReturns.length === 0) {
                chartContainer.innerHTML = '<div class="error">No yearly returns data available</div>';
                console.error("Missing yearly returns data");
                return;
            }
            
            // Check container width
            const containerWidth = chartContainer.clientWidth;
            if (containerWidth <= 0) {
                setTimeout(() => createYearlyReturnsChart(yearlyReturns), 100);
                return;
            }
            
            const margin = {top: 20, right: 80, bottom: 50, left: 80};
            const width = Math.max(containerWidth - margin.left - margin.right, 100);
            const height = 400 - margin.top - margin.bottom;
            
            const svg = d3.select(chartContainer)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Filter out invalid data
            const validReturns = yearlyReturns.filter(d => 
                d.year !== undefined && 
                d.yearly_return !== undefined && 
                !isNaN(d.yearly_return)
            );
            
            console.log("Valid yearly returns:", validReturns);
            
            if (validReturns.length === 0) {
                chartContainer.innerHTML = '<div class="error">No valid yearly returns data</div>';
                return;
            }
            
            // Make sure years are parsed as numbers
            validReturns.forEach(d => {
                if (typeof d.year === 'string') {
                    d.year = parseInt(d.year, 10);
                }
            });
            
            // Sort by year
            validReturns.sort((a, b) => a.year - b.year);
            
            // X scale
            const x = d3.scaleBand()
                .domain(validReturns.map(d => d.year))
                .range([0, width])
                .padding(0.2);
            
            // Find min and max values
            const minReturnValue = d3.min(validReturns, d => d.yearly_return) * 100;
            const maxReturnValue = d3.max(validReturns, d => d.yearly_return) * 100;
            
            console.log("Value range:", {minReturnValue, maxReturnValue});
            
            // Y scale - set minimum to at least -15%
            const yMin = Math.min(minReturnValue, -60); // Ensure y-axis goes down to at least -60%
            const yMax = Math.max(maxReturnValue, 5);   // Ensure y-axis goes up to at least 5%
            
            const y = d3.scaleLinear()
                .domain([yMin, yMax])
                .range([height, 0]);
            
            // X axis
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .tickFormat(d => d.toString()));
            
            // Y axis
            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y)
                    .tickFormat(d => `${d3.format('.0f')(d)}%`)
                    .tickValues([-60, -40, -20, 0, 20, 40, 60, 80, 100, 120].filter(v => v >= yMin && v <= yMax))
                );
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -60)
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Return (%)');
            
            // Add a zero line
            svg.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', y(0))
                .attr('y2', y(0))
                .attr('stroke', '#888')
                .attr('stroke-dasharray', '3,3');
            
            // Create bars
            svg.selectAll('.bar')
                .data(validReturns)
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('x', d => x(d.year))
                .attr('width', x.bandwidth())
                .attr('y', d => d.yearly_return >= 0 ? y(d.yearly_return * 100) : y(0))
                .attr('height', d => Math.abs(y(d.yearly_return * 100) - y(0)))
                .attr('fill', d => d.yearly_return >= 0 ? 'rgb(0, 153, 76)' : 'rgb(204, 0, 0)');
            
            // Add text labels to bars
            svg.selectAll('.label')
                .data(validReturns)
                .enter()
                .append('text')
                .attr('class', 'label')
                .attr('x', d => x(d.year) + x.bandwidth() / 2)
                .attr('y', d => d.yearly_return >= 0 ? y(d.yearly_return * 100) - 5 : y(d.yearly_return * 100) + 15)
                .attr('text-anchor', 'middle')
                .attr('fill', d => d.yearly_return >= 0 ? 'black' : 'black')
                .text(d => `${(d.yearly_return * 100).toFixed(1)}%`);
            
            // Create a tooltip for yearly returns
            const tooltip = d3.select('#tooltip');
            
            svg.selectAll('.bar')
                .on('mouseover', function(event, d) {
                    tooltip.style('opacity', 1)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <strong>Year:</strong> ${d.year}<br>
                            <strong>Return:</strong> ${(d.yearly_return * 100).toFixed(2)}%
                        `);
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
            
            console.log("Yearly returns chart created successfully");
        }

        function createCompanyWeightageChart() {
            // Ensure the chart container is cleared
            const companyTab = document.querySelector('.tab[data-tab="company-weightage"]');
            if (companyTab) {
                // Simulate clicking the tab
                companyTab.click();
            }
            const chartContainer = document.getElementById('company-weightage-chart');
            chartContainer.innerHTML = ''; // Clear previous chart
        
            // Get current allocations dynamically from sliders
            const allocations = {
            'SPY': parseInt(document.getElementById('spy-allocation').value) / 100,
            'GBTC': parseInt(document.getElementById('gbtc-allocation').value) / 100,
            'BRK-B': parseInt(document.getElementById('brkb-allocation').value) / 100,
            'VUG': parseInt(document.getElementById('vug-allocation').value) / 100
            };

            const payload = {
                tickers: {
                    'SPY': allocations['SPY'] * 100,
                    'GBTC': allocations['GBTC'] * 100,
                    'BRK-B': allocations['BRK-B'] * 100,
                    'VUG': allocations['VUG'] * 100
                }
            };

            // Fetch company weightage data from dedicated microservice
            fetch('http://localhost:5004/portfolio-company-weightage', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to fetch company weightage data');
                }
                return response.json();
            })
            .then(data => {
                const companyData = data.portfolio_company_allocation || [];
            
                // Merge duplicate companies by summing their weights
                const mergedData = [];
                const companyMap = new Map();
            
                companyData.forEach(d => {
                    const companyName = d.Company;
                
                    // Check if the company name contains "U.S. Treasury" and merge them
                    if (companyName.includes('U.S. Treasury')) {
                        if (companyMap.has('U.S. Treasury Note')) {
                            companyMap.set('U.S. Treasury Note', companyMap.get('U.S. Treasury Note') + d.Weight);
                        } else {
                            companyMap.set('U.S. Treasury Note', d.Weight);
                        }
                    } else {
                        if (companyMap.has(companyName)) {
                            companyMap.set(companyName, companyMap.get(companyName) + d.Weight);
                        } else {
                            companyMap.set(companyName, d.Weight);
                        }
                    }
                });
            
                // Convert map to an array for D3 processing
                companyMap.forEach((weight, company) => {
                    mergedData.push({ Company: company, Weight: weight });
                });
            
                // Sort by weight in descending order
                mergedData.sort((a, b) => b.Weight - a.Weight);
            
                // Dimensions for the tree map
                const width = chartContainer.clientWidth;
                const height = 500;
                const radius = Math.min(width, height) / 2;
            
                // Create SVG
                const svg = d3.select(chartContainer)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .append('g')
            
                // Set color scale for the tree map
                const color = d3.scaleSequential(d3.interpolateBlues)
                    .domain([mergedData.length, 0]);
            
                // Create treemap layout
                const treemap = d3.treemap()
                    .size([width, height])
                    .padding(1)
                    .round(true);
            
                // Prepare hierarchical data for D3 processing
                const root = d3.hierarchy({
                    name: 'Portfolio',
                    children: mergedData.map(d => ({
                        name: d.Company,
                        value: d.Weight
                    }))
                }).sum(d => d.value);
            
                // Generate treemap layout
                treemap(root);
            
                // Create rectangles for each company in the treemap
                const cell = svg.selectAll('g')
                    .data(root.leaves())
                    .enter().append('g')
                    .attr('transform', d => `translate(${d.x0},${d.y0})`);
            
                cell.append('rect')
                    .attr('width', d => d.x1 - d.x0)
                    .attr('height', d => d.y1 - d.y0)
                    .attr('fill', (d, i) => color(i)) // Color by index
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
            
                // Add text labels for company names (truncate if too long)
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 15)
                    .text(d => {
                        const maxLength = 20;
                        const name = d.data.name;
                        return name.length > maxLength
                            ? name.substring(0, maxLength) + '...'
                            : name;
                    })
                    .attr('font-size', '12px')
                    .attr('fill', 'white')
                    .attr('font-weight', 'bold');
                
                // Add percentage labels for weight
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 30)
                    .text(d => `${d.data.value.toFixed(1)}%`)
                    .attr('font-size', '10px')
                    .attr('fill', 'white');
                
                // Create a tooltip for hover interactions
                const tooltip = d3.select('#tooltip');
                cell.on('mouseover', function (event, d) {
                    tooltip.style('opacity', 1)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <strong>${d.data.name}</strong><br>
                            Weight: ${d.data.value.toFixed(2)}%
                        `);
                })
                    .on('mouseout', function () {
                        tooltip.style('opacity', 0);
                    });
                })
            .catch(error => {
                console.error('Error fetching company weightage:', error);
                chartContainer.innerHTML = `<p>Error loading company weightage: ${error.message}</p>`;
            });
        }

        function createIndustryWeightageChart() {
            // Ensure the chart container is cleared
            const industryTab = document.querySelector('.tab[data-tab="industry-weightage"]');
            if (industryTab) {
                // Simulate clicking the tab
                industryTab.click();
            }
            
            const chartContainer = document.getElementById('industry-weightage-chart');
            chartContainer.innerHTML = ''; // Clear previous chart
        
            // Get current allocations dynamically from sliders
            const allocations = {
                'SPY': parseInt(document.getElementById('spy-allocation').value) / 100,
                'GBTC': parseInt(document.getElementById('gbtc-allocation').value) / 100,
                'BRK-B': parseInt(document.getElementById('brkb-allocation').value) / 100,
                'VUG': parseInt(document.getElementById('vug-allocation').value) / 100
            };
        
            const payload = {
                tickers: {
                    'SPY': allocations['SPY'] * 100,
                    'GBTC': allocations['GBTC'] * 100,
                    'BRK-B': allocations['BRK-B'] * 100,
                    'VUG': allocations['VUG'] * 100
                }
            };
        
            // Fetch industry weightage data from the backend service
            fetch('http://localhost:5006/portfolio-industry-weightage', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to fetch industry weightage data');
                }
                return response.json();
            })
            .then(data => {
                const industryData = data.portfolio_industry_allocation || [];
                
                // Sort the data by weight in descending order
                industryData.sort((a, b) => b.Weight - a.Weight);
            
                // Dimensions for the tree map
                const width = chartContainer.clientWidth;
                const height = 500;
                
                // Create SVG
                const svg = d3.select(chartContainer)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .append('g');
            
                // Set color scale for the tree map
                const color = d3.scaleSequential(d3.interpolateBlues)
                    .domain([industryData.length, 0]);
            
                // Create treemap layout
                const treemap = d3.treemap()
                    .size([width, height])
                    .padding(1)
                    .round(true);
            
                // Prepare hierarchical data for D3 processing
                const root = d3.hierarchy({
                    name: 'Portfolio',
                    children: industryData.map(d => ({
                        name: d.Industry,
                        value: d.Weight
                    }))
                }).sum(d => d.value);
            
                // Generate treemap layout
                treemap(root);
            
                // Create rectangles for each industry in the treemap
                const cell = svg.selectAll('g')
                    .data(root.leaves())
                    .enter().append('g')
                    .attr('transform', d => `translate(${d.x0},${d.y0})`);
            
                cell.append('rect')
                    .attr('width', d => d.x1 - d.x0)
                    .attr('height', d => d.y1 - d.y0)
                    .attr('fill', (d, i) => color(i)) // Color by index
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
            
                // Add text labels for industry names (truncate if too long)
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 15)
                    .text(d => {
                        const maxLength = 20;
                        const name = d.data.name;
                        return name.length > maxLength
                            ? name.substring(0, maxLength) + '...'
                            : name;
                    })
                    .attr('font-size', '12px')
                    .attr('fill', 'white')
                    .attr('font-weight', 'bold');
                
                // Add percentage labels for weight
                cell.append('text')
                    .attr('x', 5)
                    .attr('y', 30)
                    .text(d => `${d.data.value.toFixed(1)}%`)
                    .attr('font-size', '10px')
                    .attr('fill', 'white');
                
                // Create a tooltip for hover interactions
                const tooltip = d3.select('#tooltip');
                cell.on('mouseover', function (event, d) {
                    tooltip.style('opacity', 1)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 28) + 'px')
                        .html(`
                            <strong>${d.data.name}</strong><br>
                            Weight: ${d.data.value.toFixed(2)}%
                        `);
                })
                .on('mouseout', function () {
                    tooltip.style('opacity', 0);
                });
            })
            .catch(error => {
                console.error('Error fetching industry weightage:', error);
                chartContainer.innerHTML = `<p>Error loading industry weightage: ${error.message}</p>`;
            });
        }


        // Helper function to show API error
        function showApiError(message) {
            const errorEl = document.getElementById('api-error');
            const messageEl = document.getElementById('error-message');
            messageEl.textContent = message;
            errorEl.style.display = 'block';
        }
        
        // Helper function to hide API error
        function hideApiError() {
            const errorEl = document.getElementById('api-error');
            errorEl.style.display = 'none';
        }
        
        // Helper function to format currency
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value);
        }
        
        // Helper function to format percentage
        function formatPercentage(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'percent',
                minimumFractionDigits: 1,
                maximumFractionDigits: 1
            }).format(value);
        }
        
        // Helper function to format date
        function formatDate(date) {
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }
    </script>
</body>
</html>